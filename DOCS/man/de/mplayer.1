.\" MPlayer (C) 2000-2023 MPlayer Team
.\" Diese Man-Page wurde/wird von Moritz Bunkus, Sebastian Krämer,
.\" Tobias Diedrich gepflegt.
.\"
.\" In sync with r28126
.
.\" --------------------------------------------------------------------------
.\" Makrodefinitionen
.\" --------------------------------------------------------------------------
.
.\" Einrückung für Suboptionen
.nr SS 5
.\" neue Suboption hinzufügen
.de IPs
.IP "\\$1" \n(SS
..
.\" Beginn des ersten Suboptionen-Levels, endet mit .RE
.de RSs
.RS 10
..
.\" Beginn des zweiten Suboptionen-Levels
.de RSss
.PD 0
.RS \n(SS+3
..
.\" Ende des zweiten Levels von Suboptionen
.de REss
.RE
.PD 1
..
.
.\" --------------------------------------------------------------------------
.\" Titel
.\" --------------------------------------------------------------------------
.
.TH MPlayer 1 "27.02.2022" "Das MPlayer Projekt"
.
.SH NAME
mplayer  \- Movie Player
.br
mencoder \- Movie Encoder
.
.\" --------------------------------------------------------------------------
.\" Synopsis
.\" --------------------------------------------------------------------------
.
.SH SYNOPSIS
.na
.nh
.B mplayer
[Optionen] [Datei|URL|Playlist|\-]
.
.br
.B mplayer
[Optionen] Datei1
[spezielle Optionen] [Datei2] [spezielle Optionen]
.
.br
.B mplayer
[Optionen]
{Liste von Dateien und Optionen}
[spezifische Optionen für die Optionen der Liste]
.
.br
.B mplayer
[dvd|dvdnav]://[Titel|[Starttitel]\-Endtitel][/Gerät]
[Optionen]
.
.br
.B mplayer
vcd://Titel[/Gerät]
.
.br
.B mplayer
tv://[Kanal][/input_id]
[Optionen]
.
.br
.B mplayer
radio://[Kanal oder Frequenz][/capture]
[Optionen]
.
.br
.B mplayer
pvr://
[Optionen]
.
.br
.B mplayer
dvb://[Kartennummer@]Kanal
[Optionen]
.
.br
.B mplayer
mf://[Dateimaske|@Listendatei]
[Optionen für \-mf] [Optionen]
.
.br
.B mplayer
[cdda|cddb]://Titel[\-Endtitel][:Geschwindigkeit][/Gerät]
[Optionen]
.
.br
.B mplayer
cue://Datei[:Titel]
[Optionen]
.
.br
.B mplayer
[file|mms[t]|http|http_proxy|rt[s]p|ftp|udp|unsv|icyx|noicyx|smb]://
[Benutzer:Passwort@]URL[:Port] [Optionen]
.
.br
.B mplayer
sdp://Datei
[Optionen]
.
.br
.B mplayer
mpst://Rechnername[:Port]/URL
[Optionen]
.
.br
.B mplayer
tivo://Rechnername/[list|llist|fsid]
[Optionen]
.
.br
.B gmplayer
[Optionen] [Datei|URL|Playlist]
[\-skin\ Skin]
.
.br
.B mencoder
[Optionen] Datei
[Datei|URL|\-] [\-o Datei | file://Datei |
smb://[Benutzer:Passwort@]Host/Verzeichnis]
.
.br
.B mencoder
Optionen Datei1
[spezielle Optionen] [Datei2] [spezielle Optionen]
.ad
.hy

.\" --------------------------------------------------------------------------
.\" Beschreibung
.\" --------------------------------------------------------------------------
.
.SH BESCHREIBUNG
.B mplayer
ist ein Movie-Player für Linux (der auch auf vielen anderen Plattformen und
CPU-Architekturen läuft, siehe Dokumentation).
Er spielt die meisten Dateien in den Formaten
MPEG/\:VOB, AVI, ASF/\:WMA/\:WMV, RM, QT/\:MOV/\:MP4, OGG/\:OGM, MKV
VIVO, FLI, NuppelVideo, yuv4mpeg, FILM und RoQ ab, unterstützt von vielen
eingebauten und binären Codecs.
Es können VCDs, SVCDs, DVDs, 3ivx-, DivX 3/4/5-, WMV- und sogar H.264-Filme
angeschaut werden.
.PP
MPlayer unterstützt eine große Auswahl an Video- und Audioausgabetreibern.
Er funktioniert mit X11, XV, DGA, OpenGL, SVGAlib, fbdev, AAlib, libcaca,
DirectFB, Quartz und Mac OS X CoreVideo, du kannst ihn aber auch mit GGI, SDL
(und damit allen von SDL unterstützen Treiber), VESA (mit jeder VESA-kompatiblen
Grafikkarte, auch ohne X11) sowie mit einigen kartenspezifischen
Low-Level-Treibern (für Matrox, 3Dfx und ATI) und ein paar
Hardware-MPEG-Decoderkarten wie der Siemens DVB, Hauppauge PVR (IVTV), DXR2
und DXR3/\:Hollywood+ benutzen.
Die meisten von ihnen unterstützen Software- oder Hardwareskalierung,
so dass die Vollbildwiedergabe kein Problem ist.
.PP
MPlayer verfügt über ein On-Screen-Display (OSD) für Statusinformationen,
schöne, große, schattierte und kantengeglättete Untertitel und visuelles
Feedback bei Tastatureingaben.
Europäische/\:ISO 8859\-1,2 (Ungarisch, Englisch, Tschechisch etc), Kyrillische
und Koreanische Schriftarten werden ebenso wie zwölf Untertitelformate
(MicroDVD, SubRip, OGM, SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub,
PJS und unser eigenes: MPsub) unterstützt, ebenso wie DVD-Untertitel
(SPU-Streams, VOBsub und Closed Captions).
.PP
.B mencoder
(MPlayer's Movie Encoder) ist ein einfacher Movie-Encoder, der so entworfen
wurde, dass er alle von MPlayer abspielbaren Filme (siehe oben) in andere
von MPlayer abspielbare Formate (siehe unten) umwandeln kann.
Er encodiert nach MPEG-4 (DivX/Xvid), jeden der libavcodec-Codecs und Audio
nach PCM/\:MP3/\:VBRMP3, das ganze in 1, 2 oder 3 Durchgängen.
Des weiteren kann er Streams kopieren und verfügt über ein mächtiges
Filtersystem (Entfernen (cropping) und Hinzufügen (expanding) von Rändern,
horizontales Spiegeln, Postprocessing (Nachbearbeitung), Rotation, Skalierung,
Rauschunterdrückung (denoising), RGB/\:YUV-Konvertierung und mehr).
.PP
.B gmplayer
ist die Bezeichnung für MPlayer mit einem graphischen Benutzerinterface.
Neben einigen eigenen Optionen, die in gui.conf gespeichert werden, verfügt
er über die gleichen Optionen wie MPlayer. Einige der MPlayer-Optionen werden
allerdings in gui.conf gespeichert und können so unabhängig von MPlayer
gewählt werden. (Siehe GUI-KONFIGURATIONSDATEI weiter unten.)
.PP
Beispiele zum Gebrauch, die dir zu einem schnellen Start verhelfen,
findest Du am Ende dieser Manpage.
.PP
.B Siehe auch die HTML-Dokumentation!
.
.
.\" --------------------------------------------------------------------------
.\" Keyboard control
.\" --------------------------------------------------------------------------
.
.SH "INTERAKTIVE STEUERUNG"
MPlayer besitzt eine Kontrollfunktion, die befehlsgesteuert ist und sich komplett
konfigurieren lässt.
Die Steuerung geschieht mittels Tastatur, Maus, Joystick oder Fernbedienung
(funktionierende LIRC-Unterstützung vorausgesetzt).
Bei der Option \-input findest du Beschreibungen, wie man diese Funktionen
anpassen kann.
.
.TP
.B Tastatursteuerung
.PD 0
.RSs
.IPs "links und rechts"
Springe 10 Sekunden zurück/\:vor.
.IPs "hoch und runter"
Springe 1 Minute vor/\:zurück.
.IPs "BildHoch und BildRunter (bzw.\& PGUP/\:PGDOWN)"
Springe 10 Minuten vor/\:zurück.
.IPs "[ und ]"
Verringert/erhöht die Abspielgeschwindigkeit um 10%.
.IPs "{ und }"
Halbiert/verdoppelt die Abspielgeschwindigkeit.
.IPs "Rücktaste (Backspace)"
Setzt die Abspielgeschwindigkeit zurück.
.IPs "< und >"
zurück/\:vor in der Playlist
.IPs "Eingabetaste (Enter)"
nächster Eintrag der Playlist, auch über das Ende hinaus.
.IPs "Pos1 und Ende"
nächster/\:voriger Eintrag des Wiedergabebaums der aktuellen Liste
.IPs "Einfg und Entf"
nächste/\:vorige alternative Quelle
.IPs "p / Leertaste"
Wiedergabe pausieren (erneutes Drücken unterbricht die Pause).
.IPs ".\ \ \ \ "
Einen Schritt vorwärts.
Einmaliges Drücken pausiert die Wiedergabe, jedes weitere wird einen Frame
abspielen und die Wiedergabe erneut anhalten (jede andere Taste hebt die Pause
auf).
.IPs "q / Esc"
Stoppt die Wiedergabe und beendet MPlayer.
.IPs "U\ \ \ \ "
Stoppt die Wiedergabe (und beendet, wenn \-idle nicht verwendet wurde).
.IPs "+ und \-"
Passt die Audioverzögerung um +/\- 0.1 Sekunde an.
.IPs "/ und *"
Verringert/\:erhöht die Lautstärke.
.IPs "9 und 0"
Verringert/\:erhöht die Lautstärke.
.IPs "( und )"
Passt Ton-Balance an bezüglich dem linken/\:rechten Kanal.
.IPs "m\ \ \ \ "
Ton-Stummschaltung.
.IPs "_ (nur bei MPEG-TS, AVI und libavformat)"
Wechselt zwischen den verfügbaren Videospuren.
.IPs "# (nur bei DVD, MPEG, Matroska, AVI und libavformat)"
Wechselt zwischen den verfügbaren Audiospuren.
.IPs "Tabulator (nur bei MPEG-TS und libavformat)"
Wechselt zwischen den verfügbaren MPEG-Programmen.
.IPs "f\ \ \ \ "
Ändert Vollbild-Wiedergabe (ein/\:aus, siehe auch \-fs).
.IPs "T\ \ \ \ "
Ändert Stay-on-top-Eigenschaft (ein/\:aus, siehe auch \-fs).
.IPs "w und e"
Verringert/\:erhöht den Panscan-Bereich.
.IPs "o\ \ \ \ "
Wechselt zwischen OSD-Anzeigen: keine / Suche / Suche+Zeit /
Suche+Zeit+Gesamtzeit.
.IPs "d\ \ \ \ "
Wechselt zwischen verschiedenen Framedropping-Einstellungen:  keine /
überspringe
Display / überspringe Decodierung (siehe auch \-framedrop und \-hardframedrop).
.IPs "v\ \ \ \ "
Ändert Sichtbarkeit der Untertitel (aus/\:ein).
.IPs "j\ \ \ \ "
Wechselt durch die verfügbaren Untertitel.
.IPs "F\ \ \ \ "
Ändert die Anzeige der "erzwungenen Untertitel".
.IPs "a\ \ \ \ "
Ändert die Positionierung der Untertitel: oben / mittig / unten.
.IPs "x und z"
Passt die Untertitel-Anzeige um +/\- 0.1 Sekunde an.
.IPs "r und t"
Bewegt die Untertitel nach oben/unten.
.IPs "i (nur im Modus \-edlout)"
Setze Beginn oder Ende eines EDL-Sprungs und schreibe es in die angegebene
Datei.
.IPs "s (nur bei \-vf screenshot)"
Mache einen Schnappschuss.
.IPs "S (nur bei \-vf screenshot)"
Beginne/beende die Aufnahme von Schnappschüssen.
.IPs "I\ \ \ \ "
Zeige den Dateinamen im OSD.
.IPs "P\ \ \ \ "
Zeige den Fortschrittsbalken, die abgelaufene Zeit und die Gesamtzeit im OSD.
.IPs "! und @"
Spult zum Anfang des vorigen/nächsten Kapitels.
.IPs "D (nur bei \-vo xvmc, \-vf yadif, \-vf kerndeint)"
Aktiviere/deaktiviere Deinterlacer.
.IPs "A"
Wechselt bei DVD durch die verfügbaren Perspektiven.
.RE
.PD 1
.PP
.RS
(Die folgenden Tasten funktionieren nur in Verbindung mit
hardwarebeschleunigter
Videoausgabe (xv, (x)vidix, (x)mga, etc.\&), dem Softwareequalizer-
(\-vf eq oder \-vf eq2) oder dem Farbtonfilter (\-vf hue).)
.RE
.PP
.PD 0
.RSs
.IPs "1 und 2"
Passe Kontrast an.
.IPs "3 und 4"
Passe Helligkeit an.
.IPs "5 und 6"
Passe Farbton an.
.IPs "7 und 8"
Passe Sättigung an.
.RE
.PD 1
.PP
.RS
(Die folgenden Tasten sind nur gültig bei Benutzung der Videoausgabetreiber
quartz und corevideo.)
.RE
.PP
.PD 0
.RSs
.IPs "Apfel + 0"
Ändere die Größe des Wiedergabefensters auf die Hälfte der Originalgröße.
.IPs "Apfel + 1"
Ändere die Größe des Wiedergabefensters auf die Originalgröße.
.IPs "Apfel + 2"
Ändere die Größe des Wiedergabefensters auf das doppelte der Originalgröße.
.IPs "Apfel + f"
Ändert Vollbild-Wiedergabe (ein/\:aus, siehe auch \-fs).
.IPs "Apfel + [ und Apfel + ]"
Setze Alphawert des Abspielfensters.
.RE
.PD 1
.PP
.RS
(Die folgenden Tasten sind nur gültig bei Benutzung des Videoausgabetreibers
sdl.)
.RE
.PP
.PD 0
.RS
.IPs "c\ \ \ \ "
Wechsle durch verfügbare Vollbildmodi.
Stelle ursprünglichen Modus wieder her.
.RE
.PD 1
.PP
.RS
(Die folgenden Tasten sind nur für Tastaturen mit Multimedia-Tasten gültig.)
.RE
.PP
.PD 0
.RSs
.IPs PAUSE
Pause.
.IPs "STOP\ "
Wiedergabe anhalten und beenden.
.IPs "ZURÜCK und VORWÄRTS"
Im Minutenschritt zurück-/\:vorwärts spulen.
.RE
.PD 1
.PP
.RS
(Die folgenden Tasten sind nur gültig, falls MPlayer mit Unterstützung
für TV-Karten oder DVB-Input übersetzt wurde und haben Vorrang vor den oben
definierten Tasten.)
.RE
.PP
.PD 0
.RSs
.IPs "h und k"
Wählt vorigen/\:nächsten Kanal.
.IPs "n\ \ \ \ "
Ändert Norm (PAL/\:NTSC).
.IPs "u\ \ \ \ "
Ändert die Anzeige der Liste der Kanäle.
.RE
.PD 1
.PP
.RS
(Die folgenden Tasten sind nur gültig, falls MPlayer mit dvdnav-Unterstützung
übersetzt wurde: Sie werden benutzt, um durch die Menüs zu navigieren.)
.RE
.PP
.PD 0
.RS
.IPs "Tastenfeld 8"
Wähle Knopf hoch.
.IPs "Tastenfeld 2"
Wähle Knopf runter.
.IPs "Tastenfeld 4"
Wähle Knopf links.
.IPs "Tastenfeld 6"
Wähle Knopf rechts.
.IPs "Tastenfeld 5"
Kehre zum Hauptmenü zurück.
.IPs "Tastenfeld 7"
Kehre zum nächsten Menü zurück (Vorzug erhält Kapitel->Titel->Ursprung, in
dieser Reihenfolge).
.IPs "Tastenfeld ENTER"
Bestätige die Auswahl.
.RE
.PD 1
.PP
.RS
.
(Die folgenden Tasten sind nur gültig, falls Unterstützung für Videotext
bei der Compilierung aktiviert wurde: Sie werden verwendet, um TV-Videotext
zu steuern.)
.RE
.PP
.PD 0
.RS
.IPs "X\ \ \ \ "
Schaltet Videotext an/\:aus.
.IPs "Q und W"
Gehe zur nächsten/\:vorigen Videotextseite.
.RE
.PD 1
.PP
.RS
.
.TP
.B Maussteuerung
.PD 0
.RS
.IPs "Maustaste 3 und Maustaste 4"
Spule 1 Minute zurück/\:vor.
.IPs "Tasten 5 und 6"
Verringert/\:erhöht die Lautstärke.
.RE
.PD 1
.
.TP
.B Joysticksteuerung
.PD 0
.RS
.IPs "links und rechts"
Spule 10 Sekunden zurück/\:vor.
.IPs "hoch und runter"
Spule 1 Minute vor/\:zurück.
.IPs "Knopf 1"
Pause.
.IPs "Knopf 2"
Zwischen OSD-Zuständen wechseln: aus / Suche / Suche+Zeit /
Suche+Zeit+Gesamtzeit.
.IPs "Knopf 3 und 4"
Verringert/\:erhöht die Lautstärke.
.RE
.PD 1
.
.
.\" --------------------------------------------------------------------------
.\" Zum Umgang mit MPlayer
.\" --------------------------------------------------------------------------
.
.SH "ZUM UMGANG MIT MPLAYER"
Jede Option 'flag' kennt ein Gegenstück, 'noflag'.
Beispielsweise ist die Option '\-fs' das Gegenstück zu '\-nofs'.
.PP
Wenn eine Option als (nur bei XXX)-markiert ist, wird diese nur in Kombination
mit der XXX-Option funktionieren oder wenn XXX einkompiliert wurde.
.PP
.I HINWEIS:
Der Unteroptionsparser (z.B.\& für \-ao pcm Unteroptionen) unterstützt eine
spezielle Methode zum Escapen von Zeichenketten, die für externe GUIs gedacht
ist.
.br
Das Format ist folgendermaßen:
.br
%n%Zeichenkette_der_Länge_n
.br
.I BEISPIELE:
.br
mplayer \-ao pcm:file=%10%C:test.wav test.avi
.br
Oder in einem Skript:
.br
mplayer \-ao pcm:file=%`expr length "$NAME"`%"$NAME" test.avi
.PP
.
.\" --------------------------------------------------------------------------
.\" Konfigurationsdateien
.\" --------------------------------------------------------------------------
.
.SH "KONFIGURATIONSDATEIEN"
Du kannst jede Option in einer Konfigurationsdatei speichern, die bei jedem
Start von MPlayer/MEncoder gelesen wird.
Die systemweite Konfigurationsdatei 'mplayer.conf' liegt in deinem
Konfigurationsverzeichnis (z.B.\& /etc/\:mplayer oder
/usr/\:local/\:etc/\:mplayer), die benutzerspezifische Datei ist
\'~/\:.mplayer/\:config'.
Die Konfigurationsdatei für MEncoder ist 'mencoder.conf' in deinem
Konfigurationsverzeichnis (z.B.\& /etc/\:mplayer oder
/usr/\:local/\:etc/\:mplayer), die benutzerspezifische
ist '~/\:.mplayer/\:mencoder.conf'.
Benutzerspezifische Einstellungen haben Vorrang vor den systemweiten (im
Falle von
.B gmplayer
haben die Optionen in gui.conf Vorrang vor den benutzerspezifischen)
und Optionen auf der Kommandozeile überschreiben alle anderen.
Die Syntax der Konfigurationsdateien lautet 'Option=<Wert>'
und alles, was nach einem '#' kommt, wird als Kommentar verstanden und nicht
ausgewertet.
Optionen, die keine Werte benötigen, können aktiviert werden, wenn
du ihnen den Wert 'yes' oder '1' oder 'true' zuweist, deaktiviert werden sie
mit 'no' oder '0' oder 'false'.
Auch Suboptionen können in dieser Art angegeben werden.
.PP
.PP
Du kannst auch dateispezifische Konfigurationsdateien schreiben.
Wenn du für eine Datei namens 'movie.avi' eine Konfigurationsdatei schreiben
möchtest, dann nenne diese Datei 'movie.avi.conf' mit den für
diesen Film relevanten Optionen und speichere die Datei in ~/\:.mplayer/.
Du kannst die Konfigurationsdatei auch im selben Verzeichnis wie die Datei
ablegen, die abgespielt werden soll, solange du die Option \-use\-filedir\-conf
verwendest (entweder auf der Kommandozeile oder in deiner globalen
Konfigurationsdatei).
.PP
.I BEISPIEL FÜR DIE MPLAYER-KONFIGURATIONSDATEI:
.sp 1
.nf
# Benutze in der Voreinstellung den Matrox-Treiber
vo=xmga
# Ich stehe darauf, beim Zusehen einen Handstand zu machen.
flip=yes
# Decodiere/encodiere mehrere Dateien im PNG-Format,
# beginne mit mf://Dateimaske.
mf=type=png:fps=25
# Unheimliche Negativbilder sind cool.
vf=eq2=1.0:\-0.8
# Vertikale Positionierung der OSD-Fortschrittsanzeige
progbar-align=50
.fi
.PP
.I "BEISPIEL FÜR DIE MENCODER-KONFIGURATIONSDATEI:"
.sp 1
.nf
# Sorge dafür, dass MEncoder in eine Standarddatei
schreibt.
o=encodiert.avi
# Die nächsten vier Zeilen bewirken, dass mencoder tv:// sofort mit der
Aufnahme beginnt.
oac=pcm=yes
ovc=lavc=yes
lavcopts=vcodec=mjpeg
tv=driver=v4l2:input=1:width=768:height=576:device=/dev/video0:audiorate=48000
# eine Menge komplexerer Encodierungsoptionen
lavcopts=vcodec=mpeg4:autoaspect=1
lameopts=aq=2:vbr=4
ovc=lavc=1
oac=lavc=1
passlogfile=pass1stats.log
noautoexpand=1
subfont-autoscale=3
subfont-osd-scale=6
subfont-text-scale=4
subalign=2
subpos=96
spuaa=20
.fi
.PP
.I GUI-KONFIGURATIONSDATEI
.sp 1
GUI-eigene Optionen (Namen der MPlayer-Optionen in Klammern):
ao_alsa_device
.RB ( alsa:device= ") (nur mit ALSA),"
ao_alsa_mixer
.RB ( mixer ") (nur mit ALSA),"
ao_alsa_mixer_channel
.RB ( mixer-channel ") (nur mit ALSA),"
ao_esd_device
.RB ( esd: ") (nur mit ESD),"
ao_extra_stereo
.RB ( "af extrastereo" ") (Standard: 1.0),"
ao_extra_stereo_coefficient
.RB ( "af extrastereo=" "),"
ao_oss_device
.RB ( oss: ") (nur mit OSS),"
ao_oss_mixer
.RB ( mixer ") (nur mit OSS),"
ao_oss_mixer_channel
.RB ( mixer-channel ") (nur mit OSS),"
ao_sdl_subdriver
.RB ( sdl: ") (nur mit SDL),
ao_surround (unbenutzt),
ao_volnorm
.RB ( "af volnorm" "),"
autosync (aktiviert/deaktiviert),
autosync_size
.RB ( autosync "),"
cache (aktiviert/deaktiviert),
cache_size
.RB ( cache "),"
enable_audio_equ
.RB ( "af equalizer" "),"
equ_band_00 ... equ_band_59,
.RB ( "af equalizer=" "),"
equ_channel_1 ... equ_channel_6
.RB ( "af channels=" "),"
gui_main_pos_x,
gui_main_pos_y,
gui_save_pos (ja/nein),
gui_tv_digital (ja/nein),
gui_video_out_pos_x,
gui_video_out_pos_y,
playbar (aktiviert/deaktiviert),
replay_gain (aktiviert/deaktiviert),
replay_gain_adjustment (-30..10),
show_videowin (ja/nein),
vf_lavc
.RB ( "vf lavc" ") (nur mit DXR3),"
vf_pp
.RB ( "vf pp" "),"
vo_dxr3_device (unbenutzt) (nur mit DXR3).
.sp 1
MPlayer-Optionen, die in gui.conf gespeichert werden (Namen der GUI-Optionen,
Namen der MPlayer-Optionen in Klammern):
a_afm
.RB ( afm ),
ao_driver
.RB ( ao ),
ass_bottom_margin
.RB ( ass-bottom-margin ") (nur mit ASS),"
ass_enabled
.RB ( ass ") (nur mit ASS),"
ass_top_margin
.RB ( ass-top-margin ") (nur mit ASS),"
ass_use_margins
.RB ( ass-use-margins ") (nur mit ASS),"
cdrom_device
.RB ( cdrom-device ),
dvd_device
.RB ( dvd-device ),
font_autoscale
.RB ( subfont-autoscale ") (nur mit FreeType),"
font_blur
.RB ( subfont-blur ") (nur mit FreeType),"
font_encoding
.RB ( subfont-encoding ),
font_factor
.RB ( ffactor ),
font_name
.RB ( font ),
font_osd_scale
.RB ( subfont-osd-scale ") (nur mit FreeType),"
font_outline
.RB ( subfont-outline ") (nur mit FreeType),"
font_text_scale
.RB ( subfont-text-scale ") (nur mit FreeType),"
gui_skin
.RB ( skin ),
idle
.RB ( idle ),
load_fullscreen
.RB ( fs ),
osd_level
.RB ( osdlevel ),
playlist_support
.RB ( allow-dangerous-playlist-parsing ),
softvol
.RB ( softvol ),
stopxscreensaver
.RB ( stop-xscreensaver ),
sub_auto_load
.RB ( autosub ),
sub_cp
.RB ( subcp ") (nur mit iconv),"
sub_overlap
.RB ( overlapsub ),
sub_pos
.RB ( subpos ),
sub_unicode
.RB ( unicode ),
sub_utf8
.RB ( utf8 ),
v_flip
.RB ( flip ),
v_framedrop
.RB ( framedrop ),
v_idx
.RB ( idx ),
v_ni
.RB ( ni ),
v_vfm
.RB ( vfm ),
vf_autoq
.RB ( autoq ),
vo_direct_render
.RB ( panscan ),
vo_doublebuffering
.RB ( dr ),
vo_driver
.RB ( vo ),
vo_panscan
.RB ( double ).
.
.\" --------------------------------------------------------------------------
.\" Profile
.\" --------------------------------------------------------------------------
.
.SH "PROFILE"
Um die Arbeit mit verschiedenen Konfigurationsprofilen zu erleichtern, können
in den Konfigurationsdateien mehrere Profile definiert werden.
Ein Profil beginnt mit dessen Name in eckigen Klammern, z.B.\& '[mein-Profil]'.
Alle nachfolgenden Optionen werden Teil des Profils sein.
Eine Beschreibung (gezeigt durch \-profile help) kann mit der Option
profile-desc definiert werden.
Um das Profil abzuschließen, beginne ein neues oder benutze den
Profilnamen 'default', um mit normalen Optionen fortzufahren.
.fi
.PP
.I "BEISPIEL-PROFIL FÜR MPLAYER:"
.sp 1
.nf

[protocol.dvd]
profile-desc="Profil für dvd://-Streams"
vf=pp=hb/vb/dr/al/fd
alang=de

[protocol.dvdnav]
profile-desc="Profil für dvdnav://-Streams"
profile=protocol.dvd
mouse-movements=yes

[extension.flv]
profile-desc="Profil für .flv-Dateien"
flip=yes

[vo.pnm]
outdir=/tmp

[ao.alsa]
device=spdif
.fi
.PP
.I "BEISPIEL-PROFIL FÜR MENCODER:"
.sp 1
.nf

[mpeg4]
profile-desc="MPEG4-Encodierung"
ovc=lacv=yes
lavcopts=vcodec=mpeg4:vbitrate=1200

[mpeg4\-hq]
profile-desc="HQ MPEG4-Encodierung"
profile=mpeg4
lavcopts=mbd=2:trell=yes:v4mv=yes
.fi
.
.\" --------------------------------------------------------------------------
.\" Optionen
.\" --------------------------------------------------------------------------
.
.SH "ALLGEMEINE OPTIONEN"
.
.TP
.B \-codecs\-file <Dateiname> (siehe auch \-afm, \-ac, \-vfm, \-vc)
Überschreibe den Standardsuchpfad und benutze die angegebene Datei
anstelle der systemweit installierten oder
der eingebauten codecs.conf.
.
.TP
.B \-include <Konfigurationsdatei> (siehe auch \-gui-include)
Gib eine Konfigurationsdatei an, die nach den Standardkonfigurationsdateien
eingelesen werden soll.
.
.TP
.B \-list\-options
Gibt alle verfügbaren Optionen aus.
.
.TP
.B \-msgcharset <Zeichensatz>
Konvertiere Konsolenausgaben in den angegebenen Zeichensatz (Standard:
automatische Erkennung).
Der Text wird diejenige Codierung haben, die mit der configure-Option
\-\-charset angegeben wurde.
Setze dies auf "noconv", um jegliche Konvertierung zu deaktivieren (z.B.\& bei
Problemen mit iconv).
.br
.I ANMERKUNG:
Diese Option tritt nach dem Einlesen der Kommandozeile in Kraft.
Die Umgebungsvariable MPLAYER_CHARSET kann dir helfen, fehlerhafte erste
Zeilen der Ausgabe loszuwerden.
.
.TP
.B \-msgcolor
Aktiviere farbenfrohe Konsolenausgaben auf Terminals, die ANSI-Farben
unterstützen.
.
.TP
.B \-msglevel <all=<Level>:<Modul>=<Level>:...>
Steuert die Ausführlichkeit der Ausgabe für jedes einzelne Modul.
Das 'all'-Modul steuert alle nicht explizit auf der Kommandozeile angegebenen
Module.
Siehe '\-msglevel help' für eine Liste der verfügbaren Module.
.br
.I ANMERKUNG:
Manche Meldungen werden ausgegeben, bevor die Kommandozeile eingelesen wird,
und bleiben daher von \-msglevel unberührt.
Um diese Meldungen zu kontrollieren, musst du die Umgebungsvariable
MPLAYER_VERBOSE verwenden, für Details siehe deren Beschreibung unten.
.br
Verfügbare Levels:
.PD 0
.RSs
.IPs \-1
Absolute Stille
.IPs 0
Nur fatale Fehlermeldungen
.IPs 1
Fehlermeldungen
.IPs 2
Warnmeldungen
.IPs 3
Kurze Hinweise
.IPs 4
Informationen
.IPs 5
Statusmeldungen (Standard)
.IPs 6
Ausführliche Meldungen
.IPs 7
Debuglevel 2
.IPs 8
Debuglevel 3
.IPs 9
Debuglevel 4
.RE
.PD 1
.
.TP
.B \-msgmodule
Fügt vor jeder Konsolenausgabe den Modulnamen an.
.
.TP
.B \-noconfig <Optionen>
Lies die gewählten Konfigurationsdateien nicht ein.
.br
.I ANMERKUNG:
Werden auf der Kommandozeile die Optionen \-include oder \-use\-filedir\-conf
angegeben, so werden sie berücksichtigt.
.sp 1
Verfügbare Optionen sind:
.PD 0
.RSs
.IPs "all\ \ "
alle Konfigurationsdateien
.IPs "gui (nur bei GUI)"
GUI-Konfigurationsdatei
.IPs system
Systemkonfigurationsdatei
.IPs "user\ "
benutzerspezifische Konfigurationsdatei
.RE
.PD 1
.
.TP
.B "\-quiet \ "
Konsolenausgaben werden weniger ausführlich; insbesondere wird damit die
Statuszeile (z.B.\& A:   0.7 V:   0.6 A-V:  0.068 ...) nicht angezeigt.
Besonders nützlich ist dies bei langsamen Terminals oder fehlerhaften, die
Zeilenvorschübe nicht richtig verarbeiten (z.B.\& \\r).
.
.TP
.B \-priority <Priorität> (nur bei Windows)
Setzt die Prozesspriorität für MPlayer anhand der von Windows vordefinierten
Prioritäten.
Mögliche Werte für <Priorität>:
.RSs
idle|belownormal|normal|abovenormal|high|realtime
.RE
.sp 1
.RS
.I WARNUNG:
Echtzeitpriorität (realtime) zu benutzen kann das System einfrieren.
.RE
.
.TP
.B \-profile <Profil1,Profil2,...>
Benutze eins (oder mehrere) der angegebenen Profile, \-profile help gibt eine
Liste der definierten Profile aus.
.
.TP
.B \-really\-quiet (siehe auch \-quiet)
Zeige noch weniger Ausgaben und Statusmeldungen an als mit \-quiet.
Verhindert außerdem Dialoge mit Fehlermeldungen in der GUI.
.
.TP
.B \-show\-profile <Profil>
Zeige eine Beschreibung und den Inhalt eines Profils an.
.
.TP
.B \-use\-filedir\-conf
Schaue nach einer dateispezifischen Konfigurationsdatei im selben Verzeichnis
wie die Datei, die abgespielt wird.
.br
.I WARNUNG:
Kann gefährlich sein beim Abspielen von nicht-vertrauenswürdigen Medien.
.
.TP
.B "\-v\ \ \ \ \ "
Erhöht die Ausführlichkeit der Ausgaben um eine Stufe für jedes \-v auf der
Kommandozeile.
.
.
.
.SH "PLAYER-SPEZIFISCHE OPTIONEN (NUR FÜR MPLAYER)"
.
.TP
.B \-autoq <Qualität> (zusammen mit \-vf [s]pp)
Ändert dynamisch das Qualitätslevel (der Nachbearbeitung (Postprocessing)), je
nachdem, wieviel CPU-Zeit gerade frei ist.
Das angegebene Level ist das maximal verwendete Level.
Normalerweise kannst du eine große Zahl wählen.
Um dieses Feature zu benutzen, muss \-vf [s]pp ohne Parameter aufgerufen
werden.
.
.TP
.B \-autosync <Faktor>
Ändert die Schrittweise der A/V-Synchronisation basierend auf den
Messungen der Audioverzögerung.
Mit \-autosync\ 0, dem Standardwert, wird das Bildtiming nur auf der
gemessenen Audioverzögerung basieren.
Angeben von \-autosync\ 1 wird das gleiche tun, den
A/\:V-Synchronisationsalgorithmus jedoch leicht verändern.
Bei einem Film mit nicht gleichbleibender Framerate, der mit \-nosound
problemlos abgespielt wird, kann \-autosync mit einem Wert größer 1
helfen.
Je höher der Wert, desto mehr ähnelt das Verhalten dem von \-nosound.
\-autosync\ 30 kann bei Problemen helfen, die bei Audiotreibern entstehen,
die keine perfekt funktionierende Messung der Audioverzögerung zulassen.
Falls große A/\:V-Synchronisationsunterschiede auftreten, dauert es mit mit
diesem Wert meist nur eine oder zwei Sekunden, bis die A/\:V-Synchronisation
wieder in Ordnung ist.
Diese Verzögerung bei der Reaktion auf abrupte A/\:V-Synchronisationsänderungen
sollte bei allen Sound-Treibern der einzige Nebeneffekt dieser Option sein.
.
.TP
.B \-benchmark
Gibt am Ende einige Statistiken über die CPU-Auslastung und ausgelassene
Frames aus.
Kann zusammen mit \-nosound und \-vo null benutzt werden,
um den Videocodec einem Geschwindigkeitstest zu unterziehen.
.br
.I ANMERKUNG:
Bei dieser Option ignoriert MPlayer die Abspieldauer eines Frames, wenn nur
Video abgespielt wird (das kannst Du Dir als unendlich hohe Framerate
vorstellen).
.
.TP
.B \-colorkey <Nummer>
Ändert den Farbwert auf einen RGB-Wert deiner Wahl.
0x000000 ist schwarz und 0xffffff ist weiß.
Wird nur von folgenden Videoausgabetreibern unterstützt: cvidix, fbdev,
svga, vesa, winvidix, xmga, xvidix, xover, xv (siehe \-vo xv:ck), xvmc
(siehe \-vo xv:ck) und directx.
.
.TP
.B \-nocolorkey
Schaltet die Wahl des Farbwertes ab.
Wird nur von folgenden Videoausgabetreibern unterstützt: cvidix, fbdev,
svga, vesa, winvidix, xmga, xvidix, xover, xv (siehe \-vo xv:ck), xvmc
(siehe \-vo xv:ck) und directx.
.
.TP
.B \-correct\-pts (EXPERIMENTELL)
Lässt mplayer in einen experimentellen Modus wechseln, in dem Zeitstempel für
Videoframes anders berechnet werden und in dem Filter, die neue Frames
hinzufügen oder Zeitstempel verändern, unterstützt werden.
Die genaueren Zeitstempel können beispielsweise sichtbar sein bei der
Wiedergabe von Untertiteln mit der Option \-ass, wenn die Untertitel zu
Szenenwechseln geschehen.
Ohne \-correct\-pts wird das Timing für Untertitel normalerweise um ein paar
Frames verschoben sein.
Diese Option funktioniert mit einigen Demuxern und Codecs nicht richtig.
.
.TP
.B \-crash\-debug (DEBUG-CODE)
Führt bei einem Absturz oder SIGTRAP automatisch gdb aus.
Unterstützung hierfür muss einkompiliert sein durch Ausführung von 'configure'
mit \-\-enable\-crash\-debug.
.
.TP
.B \-doubleclick\-time
Zeit in Millisekunden, um zwei aufeinander folgende Mausklicks als Doppelklick
zu erkennen (Standard: 300).
Setze dies auf 0, um deinen Window-Manager entscheiden zu lassen, was ein
Doppelklick ist (nur bei \-vo directx).
.br
.I ANMERKUNG:
Du wirst leicht unterschiedliches Verhalten erleben, je nach dem, ob du
MOUSE_BTN0_DBL oder MOUSE_BTN0\-MOUSE_BTN0_DBL bindest.
.
.TP
.B \-edlout <Dateiname>
Erstellt eine neue Datei und schreibt EDL (edit decision list) -Markierungen
hinein.
Während der Wiedergabe drückt der Benutzer 'i', um Beginn oder Ende eines
Blocks, der übersprungen werden soll, zu markieren.
Damit erhält  er eine Ausgangsbasis, die er an seine Bedürfnisse
anpassen kann.
Siehe http://www.mplayerhq.hu/\:DOCS/\:HTML/\:de/\:edl.html für Details.
.
.TP
.B \-enqueue (nur beim GUI)
Hänge die auf der Kommandozeile angegebenen Dateien an die Playlist an,
anstatt sie sofort abzuspielen.
.
.TP
.B \-fixed\-vo
Erzwingt dasselbe Videosystem für mehrere Dateien (einmalige Initialisierung
für alle Dateien).
Dementsprechend wird für alle Dateien nur ein Fenster geöffnet.
Momentan funktionieren die folgenden Treiber mit \-fixed\-vo: gl, gl2, mga,
svga, x11, xmga, xv, xvidix und dfbmga.
.
.TP
.B \-framedrop (siehe auch \-hardframedrop, experimentell ohne \-nocorrect\-pts)
Verwirft einige Frames, ohne sie anzuzeigen, um auf langsamen Systemen
die A/\:V-Synchronisation beizubehalten.
Videofilter werden auf diese Frames nicht angewendet.
B-Frames werden überhaupt nicht decodiert.
.
.TP
.B \-(no)gui
(De)aktiviert die GUI-Schnittstelle (Standard hängt vom Namen der Binärdatei
ab).
Funktioniert nur als erstes Argument auf der Kommandozeile.
Funktioniert nicht als Option in einer Konfigurationsdatei.
.
.TP
.B \-gui-include <GUI-Konfigurationsdatei> (siehe auch \-include) (nur beim GUI)
Gibt eine GUI-Konfigurationsdatei an, die nach der Standardkonfigurationsdatei
gui.conf eingelesen werden soll.
.
.TP
.B \-h, \-help, \-\-help
Zeigt eine kurze Zusammenfassung der Optionen an.
.
.TP
.B \-hardframedrop (experimentell ohne \-nocorrect\-pts)
Noch rabiateres Verwerfen von Frames (verhindert evtl. korrekte
Decodierung).
Führt zu Bildstörungen!
Beachte, dass vor allem der libmpeg2-Decoder mit dieser Einstellung abstürzen
kann, ziehe also Benutzung von "\-vc ffmpeg12," in Betracht.
.
.TP
.B \-heartbeat\-cmd
Befehl, der während der Wiedergabe alle 30 Sekunden via system() - z.B.\& in
der Shell - ausgeführt wird.
.sp 1
.I ANMERKUNG:
MPlayer verwendet diesen Befehl ohne jegliche Überprüfung, es ist in deiner
Verantwortung sicherzustellen, dass dies keine Sicherheitsrisiken birgt
(stelle z.B.\& sicher, dass der volle Pfad verwendet wird, wenn wie unter
Windows "." in deinem Pfad ist).
.sp 1
Dies kann "missbraucht" werden, um Bildschirmschoner zu deaktiveren, die
die passende X-API nicht unterstützen (siehe auch \-stop\-xscreensaver).
Wenn du meinst, dass dies zu kompliziert ist, bitte den Autor deines
Bildschirmschonerprogramms darum, die X-API entsprechend zu unterstützen.
.sp 1
.I BEISPIEL für xscreensaver:
mplayer \-heartbeat\-cmd "xscreensaver\-command \-deactivate" Datei
.sp 1
.I BEISPIEL für GNOME-Bildschirmschoner:
mplayer \-heartbeat\-cmd "gnome\-screensaver\-command \-p" Datei
.RE
.PD 1
.
.TP
.B \-identify
Kurzschreibweise für \-msglevel identify=6.
Zeigt Dateiparameter in einem leicht zu analysierenden Format an.
Gibt außerdem detailliertere Informationen zu Sprachen und IDs von
Untertiteln und Audiospuren aus.
Bei einer DVD oder Blu-ray werden zum Beispiel die Kapitel und die Länge der
einzelnen Titel sowie die Disk-ID angezeigt.
Kombiniert man dies mit \-frames 0, wird die gesamte Videoausgabe
unterdrückt.
Das Wrapper-Skript TOOLS/\:midentify unterdrückt die anderen MPlayer-Ausgaben
und führt (hoffentlich) ein Shell-Escaping für die Dateinamen aus.
Man erhält weniger Informationen durch Verwendung von \-msglevel identify=4.
.
.TP
.B \-idle (siehe auch \-slave)
MPlayer wartet nichtstuend anstatt zu beenden, wenn keine Datei
abzuspielen ist.
Hauptsächlich für den Slave-Modus nützlich, in dem MPlayer
durch Eingabekommandos gesteuert werden kann.
.br
Für
.B gmplayer
ist \-idle der Standard, \-noidle beendet die GUI, nachdem alle Dateien
wiedergegeben worden sind.
.
.TP
.B \-input <Kommandos>
Diese Option kann benutzt werden, um bestimmte Teile von MPlayers
Eingabesystem zu konfigurieren.
Pfadangaben sind relativ zu ~/.mplayer/.
.br
.I ANMERKUNG:
Automatische Wiederholung (autorepeat) wird momentan nur von Joysticks
unterstützt.
.sp 1
Die verfügbaren Kommandos lauten:
.sp 1
.PD 0
.RSs
.IPs conf=<Dateiname>
Gib eine andere Konfigurationsdatei als die Standarddatei
~/\:.mplayer/\:input.conf an.
Wenn kein Pfadname angegeben wird, dann wird ~/\:.mplayer/\:<Dateiname>
angenommen.
.IPs ar-dev=<Gerät>
Gerät, das als Apple-Infrarotfernbedienung verwendet werden soll (Standard ist
automatische Erkennung, nur bei Linux).
.IPs ar-delay
Zeit in Millisekunden, bevor ein Tastendruck automatisch wiederholt
wird (0 deaktiviert dies).
.IPs ar-rate
Anzahl der Tastendrücke pro Sekunde bei automatisch wiederholtem
Drücken der Tasten (0 deaktiviert dies).
.IPs keylist
Zeigt alle Tastennamen an, die mit Kommandos belegt werden können.
.IPs cmdlist
Zeigt alle Kommandos an, die zugewiesen werden können.
.IPs js-dev
Gibt das zu benutzende Joystickgerät an (Standard: /dev/\:input/\:js0).
.IPs file=<Datei>
Liest Kommandos aus der angegeben Datei.
Ist mit einem FIFO am sinnvollsten.
.br
.I ANMERKUNG:
Falls die angegebene Datei ein FIFO ist, öffnet MPlayer beide Enden, so dass
mehrere 'echo "seek 10" > mp_pipe' ausgeführt werden können und die Pipe in
Ordnung bleibt.
.RE
.PD 1
.
.TP
.B \-key\-fifo\-size <2\-65000>
Gibt die Größe des FIFO an, der Schlüsselevents zwischenspeichert (Standard:
7).
Ein FIFO der Größe n kann (n-1) Events zwischenspeichern.
Wenn er zu klein ist, können manche Events verlorengehen (was zu
"hängenden Mausbuttons" und ähnlichen Effekten führen kann).
Ist er zu groß, kann es zu einem scheinbar aufgehängten MPlayer führen,
während die zwischengespeicherten Events abgearbeitet werden.
Um ein Verhalten wie vor der Einführung dieser Option zu erhalten, setze den
Wert auf 2 für Linux oder 1024 für Windows.
.
.TP
.B \-lircconf <Dateiname> (nur bei LIRC)
Gibt eine Konfigurationsdatei für LIRC an (Standard: ~/.lircrc).
.
.TP
.B \-list\-properties
Gibt eine Liste der verfügbaren Eigenschaften aus.
.
.TP
.B \-loop <Anzahl>
Wiederholt die Wiedergabe <Anzahl> mal.
0 bedeutet ständige Wiederholung.
.
.TP
.B \-menu
Aktiviere das OSD-Menü.
.
.TP
.B \-menu\-cfg <Dateiname>
Benutze eine andere menu.conf.
.
.TP
.B \-menu\-chroot <Pfad> (nur bei OSD-Menü)
Chroot auf das angegebene Verzeichnis für den Datei-Auswahldialog
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-menu\-chroot /home"
Wird den Datei-Auswahldialog auf /\:home und darunter beschränken (z.B.\&
wird kein Zugriff auf / möglich sein, auf /home/benutzer_name jedoch schon).
.RE
.PD 1
.
.TP
.B \-menu\-keepdir (nur bei OSD-Menü)
Der Datei-Browser startet von der zuletzt bekannten Stelle anstatt dem
aktuellen Verzeichnis.
.
.TP
.B \-menu\-root <Wert>
Gib das Hauptmenü an.
.
.TP
.B \-menu\-startup
Zeige das Hauptmenü beim Start von MPlayer.
.
.TP
.B \-mouse\-movements
Erlaube MPlayer, Mauszeiger-Events zu empfangen, die vom Videoausgabetreiber
gesendet werden (momentan werden nur die Derivate von X11 unterstützt).
Nötig, um in DVD-Menüs Schaltflächen auszuwählen.
.
.TP
.B \-noar
Schaltet Unterstützung für Apple-Infrarotfernbedienung ab.
.
.TP
.B \-noconsolecontrols
Für Ereignisse wird von MPlayer nicht die Standardeingabe (stdin) verwendet.
Das ist nützlich beim Lesen von Daten von der Standardeingabe.
Diese Option wird automatisch aktiviert, wenn \- auf der Kommandozeile
gefunden wird.
Es gibt auch Situationen, in denen du sie manuell setzen musst, z.B.\&
wenn du /dev/\:stdin (oder das Äquivalent auf deinem System) öffnest, stdin in
einer Playlist öffnest, oder vorhast, irgendwann später von stdin via loadfile
oder loadlist Slave-Kommandos zu lesen.
.
.TP
.B \-nojoystick
Schaltet die Joystickunterstützung aus.
.
.TP
.B \-nolirc
Schaltet Unterstützung für LIRC aus.
.
.TP
.B \-nomouseinput
Sperrt die Eingabe mittels Mausbuttons (Buttonpress/\:-release) (diese Option
wird unter anderem von mozplayerxp verwendet, um ein eigenes Kontextmenü
anzuzeigen).
.
.TP
.B \-rtc (nur bei RTC)
Aktiviert die Benutzung der Linux-Echtzeituhr (real-time clock (RTC) \-
/dev/\:rtc) als Zeitgeber.
Dies weckt den Prozess alle 1/1024 Sekunden, um die aktuelle Zeit zu
überprüfen.
Dies ist nutzlos mit modernen Linuxkernels, die für Desktopbenutzung
konfiguriert sind, da diese den Prozess bei normal zeitgesteuerten Pausen
schon mit ähnlicher Genauigkeit aufwecken.
.
.TP
.B \-playing\-msg <Zeichenkette>
Gibt vor Beginn der Wiedergabe eine Zeichenkette aus.
Folgende Erweiterungen werden unterstützt:
.RSs
.IPs ${NAME}
Erweitere um den Wert der Eigenschaft NAME.
.IPs ?(NAME:TEXT)
Erweitere TEXT nur, wenn die Eigenschaft NAME verfügbar ist.
.IPs ?(!NAME:TEXT)
Erweitere TEXT nur, wenn die Eigenschaft NAME nicht verfügbar ist.
.RE
.
.TP
.B \-playlist <Dateiname>
Spiele die in der Datei angegebenen Dateien ab (eine Datei pro Zeile,
oder eine Datei im Winamp-, SMIL- oder ASX-Format).
.br
.I Anmerkung:
Diese Option wird als ein Eintrag gesehen, so dass alle Optionen danach nur auf
die Elemente dieser Playlist angewendet werden.
.br
FIXME: Dies muss noch genauer angegeben und ordentlich dokumentiert werden.
.
.TP
.B \-rtc\-device <Gerät>
Benutze das angegebene Gerät als Echtzeituhr.
.
.TP
.B \-shuffle
Spielt die Dateien in zufälliger Reihenfolge ab.
.
.TP
.B \-skin <Name> (nur mit GUI)
Lädt eine Oberfläche (skin) aus dem angegebenen Verzeichnis, das sich in einem
der beiden Standardoberflächenverzeichnisse
~/.mplayer/\:skins/ und /usr/\:local/\:share/\:mplayer/\:skins/\: befindet.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-skin fittyfene"
Probiert zuerst ~/.mplayer/\:skins/\:fittyfene und
anschließend /usr/\:local/\:share/\:mplayer/\:skins/\:fittyfene.
.RE
.PD 1
.
.TP
.B \-slave (siehe auch \-input)
Diese Option aktiviert den Slave-Modus, der dazu gedacht ist, MPlayer von
anderen Programmen aus zu steuern.
Anstatt Tastatureingaben abzufangen, liest MPlayer durch Zeilenumbruchszeichen
(\\n) getrennte Kommandos von stdin.
.br
.I ANMERKUNG:
Siehe \-input cmdlist für eine Liste der Slave-Kommandos und
DOCS/\:tech/\:slave.txt (englisch) für deren Beschreibung.
.
.TP
.B \-softsleep
Steuert die Zeit für Frames, indem wiederholt die aktuelle Zeit abgefragt wird,
anstatt den Kernel anzuweisen, MPlayer bei der angegebenen Zeit aufzuwecken.
Nützlich, wenn der Zeitgeber deines Kernels ungenau ist und du auch nicht RTC
benutzen kannst.
Der Preis dafür ist eine höhere CPU-Auslastung.
.
.TP
.B \-sstep <Sekunden>
Überspringt <Sekunden> Sekunden nach jedem Frame.
Die normale Framerate des Films wird beibehalten, die Wiedergabe ist also
beschleunigt.
Da MPlayer nur zum nächsten Keyframe springen kann, kann diese Option ungenau
sein.
.
.
.
.SH "DEMUXER-/STREAM-OPTIONEN"
.
.TP
.B \-a52drc <Level>
Gibt das Level der Dynamic Range Compression für AC-3-Audiostreams an.
<Level> ist ein Fließkommawert im Bereich von 0 bis 1, wobei 0 keine
Kompression
und 1 volle Kompression bedeutet (laute Passagen werden leiser und umgekehrt).
Diese Option zeigt nur Wirkung, wenn im AC-3-Stream die Range Compression
Information vorhanden ist (Standard: 1).
.
.TP
.B \-aid <ID> (siehe auch \-alang)
Gibt die zu verwendende Audiospur an (MPEG: 0\-31 AVI/\:OGM: 1\-99
ASF/\:RM: 0\-127 VOB(LPCM): 160\-191 MPEG-TS: 17\-8190).
MPlayer gibt alle verwendbaren Audio-IDs aus, wenn er im ausführlichen Modus
(\-v) gestartet wird.
Beim Abspielen eines MPEG-TS-Streams wählt MPlayer/\:MEncoder das erste
Programm (falls vorhanden) mit der gewählten Audiospur.
.
.TP
.B \-alang <Sprachcode[,Sprachcode,...]> (siehe auch \-aid)
Gibt eine Prioritätenliste der abzuspielenden Audiospuren an.
Verschiedene Containerformate verwenden unterschiedliche Ländercodes.
DVDs benutzen den zweibuchstabigen ISO 639\-1\-Sprachcode, Matroska, MPEG-TS und
NUT benutzen den dreibuchstabigen ISO 639\-2\-Sprachcode, während OGM einen
formlosen Bezeichner verwendet.
MPlayer gibt alle vorhandenen Sprachen aus, wenn er im ausführlichen Modus
(\-v) gestartet wird.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "mplayer dvd://1 \-alang hu,en"
Wählt die ungarische Sprachspur einer DVD und wählt die englische, wenn
Ungarisch nicht verfügbar ist.
.IPs "mplayer \-alang jpn example.mkv"
Spielt eine Matroskadatei auf japanisch ab.
.RE
.PD 1
.
.TP
.B \-audio\-demuxer <+Name> (nur bei \-audiofile)
Erzwingt den Audiodemuxertyp für \-audiofile.
Setze ein '+' vor den Namen, um den Demuxer zu erzwingen, dann werden
einige Überprüfungen nicht durchgeführt!
Gib den Demuxernamen an, wie er von \-audio\-demuxer help angezeigt wird.
Zur Rückwärtskompatibilität wird auch die Demuxer-ID, wie sie in
subreader.h definiert wird, akzeptiert.
\-audio\-demuxer audio oder \-audio\-demuxer 17 erzwingt das Abspielen als MP3.
.
.TP
.B \-audiofile <Dateiname>
Spielt Audio aus einer externen Datei (WAV, MP3 oder Ogg Vorbis) zu einem
Film ab.
.
.TP
.B \-audiofile\-cache <kBytes>
Aktiviert das Zwischenspeichern des von \-audiofile benutzten Streams; benutzt
dafür die angegebene Menge Speicher.
.
.TP
.B \-reuse\-socket (nur bei udp://)
Erlaubt, dass ein Socket von einem anderen Prozess wiederverwendet wird,
sobald es geschlossen wird.
.
.TP
.B \-bandwidth <Wert> (nur bei Netzwerk)
Gibt die maximal zu benutzende Bandbreite für Netzwerkstreaming an (bei
Servern, die Streams in verschiedenen Bitraten senden können).
Nützlich, wenn du Live-Streams über eine langsame Verbindung ansehen
möchtest.
Im Falle von Real-RTSP-Streaming wird dies auch verwendet, um die maximale
Zuführungsbandbreite festzulegen, was schnelleres Auffüllen des Caches und
Stream-Dumping ermöglicht.
.
.TP
.B \-cache <kBytes>
Diese Option gibt an, wieviel Speicher (in kBytes) MPlayer zum
Precachen einer Datei oder URL benutzt.
Besonders bei langsamen Medien sinnvoll.
.
.TP
.B \-nocache
Deaktiviert Zwischenspeicherung.
.
.TP
.B \-cache\-min <Prozent>
Die Wiedergabe startet, wenn der Cache bis zu <Prozent> der Gesamtgröße gefüllt
ist.
.TP
.
.B \-cache\-seek\-min <Prozent>
Falls ein Sprung zu einer Position nicht weiter als <Prozent> der Cachegröße
von der aktuellen Position gemacht wird, wartet MPlayer bis der Cache
zu dieser Stelle gefüllt ist, anstatt einen Sprung im Datenstrom zu machen
(Standard: 50).
.
.TP
.B \-cdda <Option1:Option2> (nur bei CDDA)
Diese Option kann benutzt werden, um die CD-Audio-Auslesefeatures von
MPlayer zu verfeinern.
sp 1
Vorhandene Optionen sind folgende:
.RSs
.IPs speed=<Wert>
Setzt die CD-Umdrehungsgeschwindigkeit.
.IPs paranoia=<0\-2>
Setzt den Paranoia-Wert.
.RSss
0: deaktiviert Fehlererkennung (Standard)
.br
1: nur Überlappungstest
.br
2: komplette Datenkorrektur und -überprüfung
.REss
.IPs generic-dev=<Wert>
Benutzt das angegebene generische SCSI-Gerät.
.IPs sector-size=<Wert>
Setzt die atomare Lesegröße.
.IPs overlap=<Wert>
Erzwingt eine minimal zu durchsuchende Überlappung bei der Datenüberprüfung
von <Wert> Sektoren.
.IPs toc-bias
Nimm an, dass der Startoffset von Spur 1, wie er in der TOC steht, als
LBA 0 adressiert wird.
Einige Toshiba-Laufwerke benötigen diese Option, um die Spurgrenzen richtig
zu erkennen.
.IPs toc-offset=<Wert>
Addiere <Wert> Sektoren zu den ermittelten Werten bei der Adressierung
der Spuren.
Kann negativ sein.
.IPs (no)skip
Akzeptiere (niemals) nicht perfekte Datenrekonstruktion.
.RE
.
.TP
.B \-cdrom\-device <Pfad zum Gerät>
Gibt das CD-ROM-Gerät an (Standard: /dev/\:cdrom).
.
.TP
.B \-channels <Anzahl> (siehe auch \-af channels)
Ändere die Anzahl der wiederzugebenden Kanäle (Standard: 2).
MPlayer weist den Decoder an, den Ton in soviele Kanäle wie angegeben zu
decodieren.
Dann liegt es am Decoder, diese Anforderung zu erfüllen.
Dies ist normalerweise nur wichtig bei der Wiedergabe von AC-3-Audio (wie bei
DVDs).
In diesem Falle erledigt bei der Standardeinstellung liba52 die Decodierung
und mischt den Ton auf die angegebene Anzahl Kanäle herunter.
Um die Anzahl der Ausgabekanäle unabhängig von der Anzahl der decodierten
Kanäle zu kontrollieren, benutze den Filter channels.
.br
.I ANMERKUNG:
.br
Diese Option wird von den Codecs (nur AC-3), den Filtern (surround)
und den Audioausgabetreibern (zumindest von OSS) beachtet.
.sp 1
Verfügbare Optionen sind:
.sp 1
.PD 0
.RSs
.IPs 2
Stereo
.IPs 4
Surround
.IPs 6
volles 5.1
.RE
.PD 1
.
.TP
.B \-chapter <Kapitel-ID>[\-<ID des letzten Kapitels>](nur dvd:// und dvdnav://)
Gibt das Kapitel an, ab dem abgespielt werden soll.
Optional kann angegeben werden, nach welchem Kapitel mit dem Abspielen
aufgehört werden soll (Standard: 1).
.
.TP
.B \-cookies (nur bei Netzwerk)
Sende Cookies bei HTTP-Anfragen.
.
.TP
.B \-cookies\-file <Dateiname>) (nur bei Netzwerk)
Lies HTTP-Cookies aus <Dateiname> und überspringe die Suche in den
Standardverzeichnissen (Standard: ~/.mozilla/ und ~/.netscape/).
Es wird angenommen, dass die Datei im Netscape-Format vorliegt.
.
.TP
.B \-delay <Sekunden>
Audioverzögerung in Sekunden (postive oder negative Fließkommazahl)
.br
Negative Werte verzögern den Ton, positive Werte verzögern das Video.
Beachte, dass dies das genaue Gegenteil der MEncoder-Option \-audio\-delay
ist.
.br
.I HINWEIS:
Falls diese Option mit MEncoder benutzt wird, funktioniert sie im Zusammenhang
mit \-ovc copy nicht notwendigerweise; benutze stattdessen \-audio\-delay.
.
.TP
.B \-ignore\-start
Ignoriere die angegebene Startzeit für Streams in AVI-Dateien.
In MPlayer setzt dies Streamverzögerungen, die mit der Option \-audio\-delay
encodiert wurden, auf null.
Bei Encodierungen verhindert diese Option, dass MEncoder die originalen
Startzeiten der Streams in die neue Datei überträgt; die Option \-audio\-delay
ist davon nicht betroffen.
Beachte, dass MEncoder manchmal die Startzeiten von Streams automatisch
anpasst, um angenommene Decodierungsverzögerungen zu kompensieren.
Benutze diese Option für Encodierungen daher nicht, ohne vorher zu testen.
.
.TP
.B \-demuxer <[+]Name>
Erzwingt den Demuxertyp.
Setze ein '+' vor den Namen um den Demuxer zu erzwingen, dann werden
einige Überprüfungen nicht durchgeführt!
Gib den Demuxernamen, wie er von \-demuxer help angezeigt wird, an.
Zur Rückwärtskompatibilität wird auch die Demuxer-ID, wie in
libmpdemux/\:demuxer.h definiert, akzeptiert.
.
.TP
.B \-dumpaudio (nur MPlayer)
Schreibt den unbehandelten, komprimierten Audiostream nach ./\:stream.dump
(nützlich bei MPEG/\:AC-3), in den meisten anderen Fällen wird die
resultierende Datei nicht abspielbar sein.
.
.TP
.B \-dumpfile <Dateiname> (nur MPlayer)
Gibt den Dateinamen an, in den MPlayer schreiben soll.
Sollte in Verbindung mit \-dumpaudio / \-dumpvideo / \-dumpstream benutzt
werden.
.
.TP
.B \-dumpstream (nur MPlayer)
Schreibt den unbehandelten Stream nach ./\:stream.dump.
Nützlich, um DVD- oder Netzwerk-Streams zu rippen.
Falls mehr als eine der Optionen \-dumpaudio, \-dumpvideo oder \-dumpstream
angegeben wurde, gilt nur die zuletzt angegebene.
.
.TP
.B \-dumpvideo (nur bei MPlayer)
Schreibt den unbehandelten, komprimierten Videostream nach ./stream.dump
(nicht sehr nützlich).
Falls mehr als eine der Optionen \-dumpaudio, \-dumpvideo oder \-dumpstream
angegeben wurde, gilt nur die zuletzt angegebene.
.
.TP
.B \-dvbin <Optionen> (nur bei DVB)
Übergibt die folgenden Parameter an das DVB-Inputmodul und überschreibt dabei
die Standardeinstellungen:
.sp 1
.PD 0
.RSs
.IPs card=<1\-4>
Benutze Karte 1\-4 (Standard: 1).
.IPs file=<Dateiname>
Weist MPlayer an, die Liste der Kanäle aus <Dateiname> zu lesen
Standardeinstellung ist ~/\:.mplayer/\:channels.conf.{sat,ter,cbl,atsc} (je
nach Kartentyp)
oder ~/\:.mplayer/\:channels.conf als letzte Möglichkeit.
.IPs timeout=<1\-30>
Maximale Anzahl Sekunden, die benutzt werden, um eine Frequenz einzustellen,
bevor aufgegeben wird (Standard: 30).
.RE
.PD 1
.
.TP
.B \-dvd\-device <Pfad\ zum\ Gerät> (nur bei DVD)
Gib das DVD-Gerät oder .iso-Dateinamen an (Standard: /dev/\:dvd).
Du kannst auch ein Verzeichnis angeben, das die zuvor direkt von DVD kopierten
Dateien enthält (z.B.\& von vobcopy).
.
.TP
.B \-dvd\-speed <Faktor oder Geschwindigkeit in KB/s> (nur bei DVD)
Versuche die DVD-Geschwindigkeit zu begrenzen (Standard: 0, keine Änderung).
Die Grundgeschwindigkeit bei DVD ist ungefähr 1350KB/s, ein 8-fach Laufwerk
kann also mit bis zu 10800KB/s lesen.
Bei langsameren Geschwindigkeiten ist das Laufwerk leiser, 2700KB/s
sollten zum Anschauen von DVDs ausreichen und leise sein.
Beim Schließen setzt MPlayer die Geschwindigkeit auf den Standardwert
des Laufwerks zurück.
Werte kleiner als 100 entsprechen Vielfachen von 1350KB/s,
d.h.\& \-dvd\-speed 8 entspricht 10800KB/s (8-fach).
.br
.I ANMERKUNG:
Für die Änderung der Geschwindigkeit benötigst Du Schreibzugriff auf
das DVD-Gerät.
.
.TP
.B \-dvdangle <Winkel-ID> (nur bei DVD)
Einige DVDs beinhalten Szenen, die aus verschiedenen Perspektiven/\:Winkeln
betrachtet werden können.
Mit dieser Option kannst du MPlayer vorschreiben, welche Perspektive er
wiedergeben soll (Standard: 1).
.
.TP
.B \-edl <Dateiname>
Aktiviert EDL-Aktionen (Edit Decision List) während der Wiedergabe.
Teile des Videos werden entsprechend den Einträgen der angegebenen
Datei übersprungen und Teile des Audios stummgeschaltet.
Siehe http://www.mplayerhq.hu/\:DOCS/\:HTML/\:de/\:edl.html für Details, wie
du dieses
Feature benutzen kannst.
.
.TP
.B \-endpos <[[hh:]mm:]ss[.ms]|Größe[b|kb|mb]> (siehe auch \-ss und \-sb)
Beende zu angegebener Zeit oder Byteposition.
.br
.I ANMERKUNG:
Byteposition ist nur für MEncoder aktiviert und wird nicht genau sein, da
MEncoder nur an Bildgrenzen anhalten kann.
In Verbindung mit der Option \-ss wird die Zeit für \-endpos um die mit \-ss
angegebenen Sekunden nach hinten verschoben.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-endpos 56"
Encodiere nur 56 Sekunden.
.IPs "\-endpos 01:10:00"
Encodiere nur 1 Stunde 10 Minuten.
.IPs "\-endpos 100mb"
Encodiere nur 100 MBytes.
.RE
.PD 1
.
.TP
.B \-forceidx
Erzwingt Indexneugenerierung.
Nützlich für Dateien mit defektem Index (A/V-Desynchronisation etc.\&).
Das ermöglicht das Spulen in Dateien, in denen dies vorher nicht möglich war.
Mit MEncoder kann der Index permanent repariert werden (siehe Dokumentation).
.br
.I ANMERKUNG:
Diese Option funktioniert nur, wenn das zugrunde liegende Medium Spulen
unterstützt (z.B.\& nicht bei Standardeingabe, Pipe etc.\&)
.
.TP
.B \-fps <Fließkommazahl>
Überschreibt die Framerate.
Nützlich, falls dieser Wert falsch ist oder fehlt.
.
.TP
.B \-frames <Anzahl>
Nur die ersten <Anzahl> Bilder werden wiedergegeben/\:encodiert, danach wird
MPlayer beendet.
.
.TP
.B \-hr\-mp3\-seek (nur bei MP3)
Hi-res mp3-Spulen.
Standardmäßig ist diese Option an, wenn ein externes MP3 abgespielt wird,
da MPlayer an die exakte Position spulen muss, um die A/V-Syncronisation
beizubehalten.
Kann langsam sein, vor allem dann, wenn zurückgespult wird, da dann erst
zum Anfang gespult wird, um die genaue Stelle zu finden.
.
.TP
.B \-idx (siehe auch \-forceidx)
Erstellt den Index neu, wenn kein Index gefunden wurde, und ermöglicht somit
Spulen.
Nützlich bei defekten/\:unvollständigen Downloads oder bei schlecht
erstellten Dateien.
.br
.I ANMERKUNG:
Diese Option ist nur nutzbar, wenn das zugrundeliegende Medium spulen
unterstützt (z.B.\& nicht bei Standardeingabe, Pipe, etc.\&)
.
.TP
.B \-noidx
Überspringe die Neugenerierung der Indexdatei.
MEncoder überspringt bei dieser Option das Schreiben des Index.
.
.TP
.B \-ipv4\-only\-proxy (nur bei Netzwerk)
Überspringt Proxy-Server bei IPv6-Adressen.
Für IPv4-Verbindungen wird er aber benutzt.
.
.TP
.B \-loadidx <Index-Datei>
Die Datei, von der die von \-saveidx gespeicherten Indexdaten für das Video
gelesen werden.
Dieser Index wird zum Spulen benutzt, dabei wird der im AVI enthaltene Index
überschrieben.
MPlayer wird nicht verhindern, dass du einen Index einer anderen AVI-Datei
benutzt, aber dies wird sicherlich zu ungewünschten Resultaten führen.
.br
.I ANMERKUNG:
Diese Option ist veraltet, da MPlayer nun Unterstützung für OpenDML hat.
.
.TP
.B \-mc <Sekunden/Frame>
maximale A/V-Synchronisationsanpassung pro Frame (in Sekunden)
.
.TP
.B \-mf <Option1:Option2:...>
Wird benutzt, wenn mehrere PNG- oder JPEG-Dateien decodiert werden.
.sp 1
Verfügbare Optionen sind folgende:
.sp 1
.PD 0
.RSs
.IPs w=<Wert>
Breite der Eingabedatei (Standard: automatische Erkennung)
.IPs h=<Wert>
Höhe der Eingabedatei (Standard: automatische Erkennung)
.IPs fps=<Wert>
Frames pro Sekunde bei der Ausgabe (Standard: 25)
.IPs type=<Wert>
Typ der Quelldateien (mögliche Typen sind: jpeg, png, tga, sgi)
.RE
.PD 1
.
.TP
.B \-ni (nur bei AVI)
Erzwingt die Benutzung des nicht-interleaved-AVI-Parsers (was die Wiedergabe
einiger schlechter AVI-Dateien ermöglicht).
.
.TP
.B \-nobps (nur bei AVI)
Benutze nicht den durchschnittlichen Bytes/\:Sekunde-Wert für die
A/\:V-Synchronisation.
Hilft bei einigen AVI-Dateien mit defektem Header.
Dies kann den Speicherbedarf beträchtlich erhöhen, weshalb es wohl besser
wäre, das Interleaving der betroffenen Dateien in Ordnung zu bringen.
.
.TP
.B \-noextbased
Deaktiviert die auf Dateinamenserweiterungen basierende Demultiplexerauswahl.
Wenn der Dateityp (und damit der Demultiplexer) nicht zweifelsfrei
festgestellt werden kann (z.B. wenn die Datei keinen Header besitzt
oder dieser nicht zuverlässig genug ist), dann wird normalerweise ein
Demultiplexer anhand der Dateiendung gewählt.
Die inhaltsbasierte Demultiplexerauswahl wird bei Problemen immer
vorgenommen.
.
.TP
.B \-passwd <Passwort> (siehe auch \-user) (nur bei Netzwerk)
Gibt das Passwort für die HTTP-Authentifizierung an.
.
.TP
.B \-prefer\-ipv4 (nur bei Netzwerk)
Benutzt IPv4 bei Netzwerkverbindungen.
Greift automatisch auf IPv6-Verbindungen zurück.
.
.TP
.B \-prefer\-ipv6 (nur bei IPv6-Netzwerk)
Benutzt IPv6 bei Netzwerkverbindungen.
Greift automatisch auf IPv4-Verbindungen zurück.
.
.TP
.B \-psprobe <Byte-Position>
Beim Abspielen eines MPEG-PS- oder MPEG-PES-Streams lässt dich diese Option
wählen, wie viele Bytes des Streams MPlayer untersuchen soll, um den zu
benutzenden Videocodec zu identifizieren.
Diese Option ist nötig, um EVO- oder VDR-Dateien abzuspielen, die H.264-Streams
enthalten.
.
.TP
.B \-pvr <Option1:Option2:...> (nur bei PVR)
Diese Option nimmt verschiedene Feineinstellungen der Eigenschaften für die
Encodierung des PVR-Capture-Moduls vor.
Es muss mit irgendeiner auf einem Hardware-MPEG-Encoder basierenden Karte
verwendet werden, die vom V4L2-Treiber unterstützt wird.
Die Hauppauge WinTV PVR\-150/250/350/500 und alle IVTV-basierten Karten sind
als PVR-Capture-Karten bekannt.
Beachte, dass nur Linuxkernel Version 2.6.18 oder höher in der Lage sind,
MPEG-Layer durch die V4L2-Schicht zu verarbeiten.
Für das Einfangen eines MPEG-Streams und um diesen mit MPlayer/Mencoder
anzuschauen, verwende 'pvr://' als Film-URL.
.sp 1
Verfügbare Optionen sind folgende:
.RSs
.IPs aspect=<0\-3>
Gib den Aspekt der Eingabe an:
.RSss
0: 1:1
.br
1: 4:3 (Standard)
.br
2: 16:9
.br
3: 2.21:1
.REss
.IPs arate=<32000\-48000>
Gib die Audio-Rate für die Encodierung an (Standard: 48000 Hz, verfügbar:
32000, 44100 und 48000 Hz).
.IPs alayer=<1\-5>
Gib die Encodierung des MPEG-Audio-Layers an (Standard: 2).
.IPs abitrate=<32\-448>
Gib die Bitrate für die Audioencodierung in kbps an (Standard: 384).
.IPs amode=<Wert>
Gib den Modus für die Audioencodierung an.
Verfügbare Preset-Werte sind 'stereo', 'joint_stereo', 'dual' und 'mono'
(Standard: stereo).
.IPs vbitrate=<Wert>
Gib die durchschnittliche Bitrate für die Videoencodierung an (Standard:
6).
.IPs vmode=<Wert>
Gib den Modus für die Videoencodierung an:
.RSss
vbr: variable Bitrate (Standard)
.br
cbr: konstante Bitrate
.REss
.IPs vpeak=<Wert>
Gib den Höchstwert für die Bitrate der Videoencodierung an
(nur nützlich für VBR-Encodierung, Standard: 9.6).
.IPs fmt=<Wert>
Wähle ein MPEG-Format für die Encodierung:
.RSss
ps:    MPEG-2 Program Stream (Standard)
.br
ts:    MPEG-2 Transport Stream
.br
mpeg1: MPEG-1 System Stream
.br
vcd:   Video CD-kompatibler Stream
.br
svcd:  Super Video CD-kompatibler Stream
.br
dvd:   DVD-kompatibler Stream
.REss
.RE
.PD 1
.
.TP
.B \-radio <Option1:Option2:...> (Radio only)
Diese Optionen setzen verschiedene Parameter des Radio-Capture-Moduls.
Für das Radiohören mit MPlayer benutze 'radio://<Frequenz>'
(wenn die Option channels nicht gegeben ist) oder 'radio://<Kanal_Nummer>'
(wenn die Option channels angegeben wurde) als Film-URL.
Du kannst dir den erlaubten Frequenzbereich anzeigen lassen, indem du MPlayer
mit der Option '\-v' startest.
Um das Aufnahme-Subsystem zu starten, benutze
\'radio://<Frequenz oder Kanal>/capture'.
Wenn das Schlüsselwort capture nicht gegeben ist, kannst du nur mit einem
Line-In-Kabel Radio hören.
Capture zu verwenden für das Anhören wird nicht empfohlen wegen
Synchronisationsproblemen, was diesen Prozess unkomfortabel macht.
.sp 1
Verfügbare Optionen sind folgende:
.RSs
.IPs device=<Wert>
Radiogerät, das verwendet werden soll (Standard: /dev/radio0 für Linux und
/dev/tuner0 für *BSD).
.IPs driver=<Wert>
Radiotreiber, der verwendet werden soll (Standard: v4l2 wenn verfügbar, v4l
sonst).
Momentan werden die Treiber v4l und v4l2 unterstützt.
.IPs volume=<0..100>
Lautstärke für das Radiogerät (Standard: 100)
.IPs "freq_min=<Wert> (nur bei *BSD BT848)"
minimal erlaubte Frequenz (Standard: 87.50)
.IPs "freq_max=<Wert> (nur bei *BSD BT848)"
maximal erlaubte Frequenz (Standard: 108.00)
.IPs channels=<Frequenz>\-<Name>,<Frequenz>\-<Name>,...
Setzt die Liste der Kanäle.
Benutze _ für Leerzeichen in Namen (oder spiele mit der Quotierung ;-).
Die Kanalnamen werden dann mittels OSD geschrieben, und für eine Fernbedienung
(siehe LIRC) werden die Slave-Kommandos radio_step_channel und radio_set_channel
nutzbar sein.
Falls angegeben, wird die Nummer in einer Film-URL als Kanalposition in der
Kanalliste verstanden.
.br
.I BEISPIELE:
radio://1, radio://104.4, radio_set_channel 1
.IPs "adevice=<Wert> (nur bei Radio Capture)"
Name des Geräts, von dem der Ton aufgenommen werden soll.
Ohne einen solchen Namen wird die Aufnahme deaktiviert, selbst wenn das
Schlüsselwort capture in der URL auftaucht.
Benutze dies für ALSA-Geräte in der Form hw=<Karte>.<Gerät>.
Wenn der Gerätename ein '=' enthält, wird das Modul ALSA für die Aufnahme
verwenden, sonst OSS.
.IPs "arate=<Wert> (nur bei Radio Capture)"
Rate in Samples pro Sekunde (Standard: 44100).
.br
.I ANMERKUNG:
Bei Verwendung von Audioaufnahme setze auch die Option \-rawaudio rate=<Wert>
mit dem selben Wert wie für arate.
Wenn du Probleme mit der Tongeschwindigkeit hast (zu schnell läuft), versuche
es mit verschiedenen Werten für die Rate (z.B.\& 48000,44100,32000,...)
abzuspielen.
.IPs "achannels=<Wert> (nur bei Radio Capture)"
Anzahl der aufzunehmenden Audiokanäle.
.RE
.
.TP
.B \-rawaudio <Option1:Option2:...>
Mit dieser Option können raw-Audiodateien abgespielt werden.
Sie kann auch verwendet werden, um Audio-CDs abzuspielen, die nicht mit 44KHz
16-Bit Stereo aufgenommen wurden.
Benutze zum Abspielen von RAW-AC-3-Streams \-rawaudio format=0x2000 \-demuxer
rawaudio.
.sp 1
Verfügbare Optionen sind folgende:
.sp 1
.PD 0
.RSs
.IPs channels=<Wert>
Anzahl der Kanäle
.IPs rate=<Wert>
Rate in Samples pro Sekunde
.IPs samplesize=<Wert>
Sample-Größe in Bytes
.IPs format=<Wert>
FourCC als Hexadezimalwert oder String-Konstante.
Verwende \-rawvideo format=help für eine Liste gültiger Zeichenketten.
.RE
.PD 1
.
.TP
.B \-rawvideo <option1:option2:...>
Mit dieser Option kannst du Dateien abspielen, die nur aus Videodaten bestehen.
Du musst außerdem \-demuxer rawvideo angeben.
.sp 1
Verfügbare Optionen sind folgende:
.sp 1
.PD 0
.RSs
.IPs fps=<Wert>
Anzahl der Bilder pro Sekunde (Standard: 25.0)
.IPs sqcif|qcif|cif|4cif|pal|ntsc
setzt die Standardbildgröße
.IPs w=<Wert>
Bildbreite in Pixeln
.IPs h=<Wert>
Bildhöhe in Pixeln
.IPs i420|yv12|yuy2|y8
wählt den Farbraum
.IPs format=<Wert>
Farbraum (FourCC) als Hexadezimalwert
.IPs size=<Wert>
Framegröße in Bytes
.REss
.sp 1
.RS
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs "mplayer foreman.qcif \-demuxer rawvideo \-rawvideo qcif"
Spielt das berühmte "foreman" Beispielvideo.
.IPs "mplayer sample-720x576.yuv \-demuxer rawvideo \-rawvideo w=720:h=576"
Spielt ein raw-YUV-Beispielvideo.
.RE
.PD 1
.
.TP
.B \-rtsp\-port
Wird bei 'rtsp://'-URLs benutzt, um die Portnummer des Clients zu erzwingen.
Diese Option kann nützlich sein, wenn du hinter einem Router bist und den
RTSP-Stream vom Server an einen bestimmten Client weiterleiten möchtest.
.
.TP
.B \-rtsp\-destination
Wird zusammen mit 'rtsp://'-DLLs benutzt, um zu erzwingen, dass die
Ziel-IP-Adresse gebunden wird.
Diese Option kann nützlich sein bei einem RTSP-Server, der RTP-Pakete nicht an
die richtige Schnittstelle schickt.
Wenn die Verbindung zu dem RTSP-Server fehlschlägt, benutze \-v, um zu sehen,
welche IP-Adresse MPlayer zu binden versucht.
Versuche, die Adresse zu erzwingen, die deinem Computer zugewiesen wurde.
.
.TP
.B \-rtsp\-stream\-over\-tcp (nur bei LIVE555 und NEMESI)
Kann zusammen mit 'rtsp://'-URLs verwendet werden, um anzugeben, dass die
daraus resultierenden eingehenden RTP- und RTCP-Pakete per TCP
übertragen werden (mit der gleichen TCP-Verbindung wie RTSP).
Diese Option kann hilfreich sein, wenn deine Internetverbindung eingehende
UDP-Pakete nicht durchlässt (siehe http://www.live555.com/\:mplayer/).
.
.TP
.B \-saveidx <Dateiname>
Erzwingt Neugenerierung des Index und schreibt den Index in <Dateiname>.
Funktioniert momentan nur mit AVI-Dateien.
.br
.I ANMERKUNG:
Diese Option ist veraltet, da MPlayer nun OpenDML unterstützt.
.
.TP
.B \-sb <Byteposition> (siehe auch \-ss)
Springt an die Byteposition.
Nützlich beim Abspielen von CD-ROM-Abbildern / .VOB-Dateien mit Müll
am Anfang.
.
.TP
.B \-speed <0.01\-100>
Erhöht oder verringert die Abspielgeschwindigkeit abhängig vom angegebenen
Faktor.
Es wird nicht garantiert, dass diese Option zusammen mit \-ovc copy
funktioniert.
.
.TP
.B \-srate <Hz>
Erzwingt eine zu benutzende Audioabspielrate (natürlich haben Soundkarten
diesbezüglich Beschränkungen).
Falls die gewählte Samplefrequenz verschieden von der des aktuellen Mediums
ist, wird der resample oder lavcresample Audiofilter in die Audiofilterschicht
eingefügt, um den Unterschied auszugleichen.
Der Resampling-Typ kann mit der Option \-af\-adv gesteuert werden.
Standard ist ein schnelles Resampling, das Störungen verursachen kann.
.
.TP
.B \-ss <Zeit> (siehe auch \-sb)
Springt zu der angegebenen Zeitposition.
.sp 1
.I BEISPIELE:
.PD 0
.RSs
.IPs "\-ss 56"
Springt zu 56 Sekunden.
.IPs "\-ss 01:10:00"
Springt zu 1 Stunde 10 Minuten.
.RE
.PD 1
.
.TP
.B \-tskeepbroken
Sorgt dafür, dass MPlayer solche TS-Pakete, die als unbrauchbar markiert
wurden, nicht ignoriert.
Diese Option wird manchmal gebraucht, um korrupte MPEG-TS-Dateien abzuspielen.
.
.TP
.B \-tsprobe <Byteposition>
Beim Abspielen eines MPEG-TS-Streams kannst du mit dieser Option auswählen,
wie viele Bytes MPlayer nach den gewünschten Audio- und Video-IDs durchsuchen
soll.
.
.TP
.B \-tsprog <1\-65534>
Beim Abspielen eines MPEG-TS-Streams kann mit dieser Option ausgewählt werden,
welches Programm (falls vorhanden) abgespielt werden soll.
Kann in Verbindung mit \-vid und \-aid benutzt werden.
.
.TP
.B \-tv <Option1:Option2:...> (nur bei TV/\:PVR)
Diese Option steuert verschiedene Einstellungen des TV-Empfang-Moduls.
Um mit MPlayer fernzusehen, benutze die Optionen 'tv://'
oder 'tv://<Kanalnummer>' oder sogar 'tv://<Kanalname>' (siehe unten die
Option channels für die Kanalnamen) als Film-URL.
Du kannst auch 'tv:///<input_id>' verwenden, um ein Video vom Composite- oder
S-Video-Eingang zu schauen (siehe Option input für Details).
.sp 1
Verfügbare Optionen:
.RSs
.IPs noaudio
kein Sound
.IPs "automute=<0\-255> (nur bei v4l und v4l2)"
Wenn die vom Gerät gemeldete Signalstärke geringer ist als dieser Wert,
werden Ton und Video stummgeschaltet.
In den meisten Fällen wird automute=100 ausreichen.
Standardwert ist 0 (automute deaktiviert).
.IPs driver=<Wert>
Siehe \-tv driver=help für eine Liste eincompilierter TV-Eingabetreiber.
mögliche Werte: dummy, v4l, v4l2, bsdbt848 (Standard: automatische Erkennung)
.IPs device=<Wert>
Gibt ein anderes TV-Gerät als /dev/\:video0 an.
.I ANMERKUNG:
Dem bsdbt848-Treiber kannst du sowohl bktr- als tuner-Gerätenamen übergeben,
indem du sie durch Komma trennst, tuner hinter bktr (z.B.\& \-tv
device=/dev/bktr1,/dev/tuner1).
.IPs input=<Wert>
Gibt den Eingang an (Standard: 0 (TV), siehe Ausgaben in der Konsole für
mögliche Eingänge).
.IPs freq=<Wert>
Gibt die Frequenz an, auf die der Tuner gesetzt wird (z.B.\& 511.250).
Kann nicht zusammen mit dem Parameter channels benutzt werden.
.IPs outfmt=<Wert>
Gibt das Ausgabeformat des Tuners mit einer Voreinstellung des
V4L-Treibers (yv12, rgb32, rgb24, rgb16, rgb15, uyvy, yuy2, i420) oder ein
frei wählbares Format als hexadezimalen Wert an.
Angabe von outfm=help listet alle wählbaren Formate.
.IPs width=<Wert>
Breite des Ausgabefensters
.IPs height=<Wert>
Höhe des Ausgabefensters
.IPs fps=<Wert>
Framerate, mit der das Video aufgenommen wird (Bilder pro Sekunde, frames per
second).
.IPs buffersize=<Wert>
Maximalgröße des Capture-Puffers in Megabytes (Standard: dynamisch)
.IPs norm=<Wert>
Für bsdbt848 und v4l sind die Normen PAL, SECAM und NTSC verfügbar.
Für v4l2 siehe Option normid und die Ausgabe von MPlayer für eine Liste der
verfügbaren TV-Normen.
.IPs "normid=<Wert> (nur bei V4L2)"
Setzt die TV-Norm auf die angegebene numerische ID.
Die TV-Norm hängt von der Videokarte ab.
Siehe MPlayer-Output für eine Liste der verfügbaren TV-Normen.
.IPs channel=<Wert>
Setzt den Tuner auf Kanal <Wert>.
.IPs chanlist=<Wert>
Werte: argentina, australia, china-bcast, europe-east, europe-west, france,
ireland, italy, japan-bcast, japan-cable, newzealand, russia, southafrica,
us-bcast, us-cable, us-cable-hrc
.IPs channels=<Kanal>\-<Name>[=<Norm>],<Kanal>\-<Name>[=<Norm>],...
Setzt Namen für Kanäle.
.I ANMERKUNG:
Wenn <Kanal> eine Ganzzahl größer als 1000 ist, wird sie als Frequenz (in
kHz) behandelt, ansonsten als Kanalname aus der Frequenztabelle.
.br
Benutze '_' anstelle von Leerzeichen bei Namen (oder spiele mit der
Shellquotierung rum ;-).
Die Sendernamen werden dann per OSD angezeigt, und die Slave-Kommandos
tv_step_channel, tv_set_channel und tv_last_channel werden per
Fernbedienung benutzbar sein (siehe LIRC).
Kann nicht zusammen mit dem frequency-Parameter benutzt werden.
.br
.I ANMERKUNG:
Die Sendernummer wird dann die Position des Eintrags in der 'channels'-Liste
sein, mit 1 beginnend.
.br
.I BEISPIEL:
tv://1, tv://TV1, tv_set_channel 1, tv_set_channel TV1
.IPs [brightness|contrast|hue|saturation]=<\-100\-100>
Setzt Werte des Bild-Equaliziers der Karte.
.IPs audiorate=<Wert>
Setzt die Audiobitrate für Capturing.
.IPs forceaudio
Capture auch dann Audio, wenn v4l keine Audioquellen zurückmeldet.
.IPs "alsa\ "
Benutze ALSA für Capturing.
.IPs amode=<0\-3>
Wählt einen Audiomodus:
.RSss
0: Mono
.br
1: Stereo
.br
2: Sprache 1
.br
3: Sprache 2
.REss
.IPs forcechan=<1\-2>
Normalerweise wird die Anzahl der aufgenommenen Audiokanäle automatisch
durch Ermitteln des Audiomodus der TV-Karte festgelegt.
Mit dieser Option kann Stereo/\:Mono unabhängig von dem von V4L
zurückgegebenen Audiomodus erzwungen werden.
Kann benutzt werden, wenn die TV-Karte den aktuellen Audiomodus nicht
angeben kann.
.IPs adevice=<Wert>
Setzt ein Audiogerät.
<Wert> sollte /dev/\:xxx bei OSS und eine Hardware-ID bei ALSA sein.
Du musst in der Hardware-ID von ALSA jedes ':' durch ein '.' ersetzen.
.IPs audioid=<Wert>
Wählt einen Audioausgang der TV-Karte, wenn diese mehrere hat.
.IPs "[volume|bass|treble|balance]=<0\-65535> (v4l1)"
.IPs "[volume|bass|treble|balance]=<0\-100> (v4l2)"
Diese Optionen setzen Parameter des Mixers auf der Capture-Karte.
Sie haben keinen Effekt, wenn deine Karte keinen Mixer hat.
Bei V4L2 steht 50 für den vom
Treiber angegebenen Default-Wert.
.IPs "gain=<0\-100> (v4l2)"
Setze die Kontrolle der Verstärkung für Videogeräte (normalerweise Webcams)
auf den gewünschten Wert und schalte die automatische Kontrolle aus.
Der Wert 0 aktiviert automatische Kontrolle.
Wird diese Option ausgelassen, wird die Verstärkungskontrolle nicht
geändert.
.IPs immediatemode=<bool>
Ein Wert von 0 bedeutet: Nimm Audio und Video zusammen in einem Puffer auf
(Standard für MEncoder).
Ein Wert von 1 bedeutet: Nimm nur Video direkt von der Karte und Audio
über ein externes Kabel von der TV-Karte zur Soundkarte auf (Standard
für MPlayer).
.IPs mjpeg
Benutzte Hardware-MJPEG-Kompression (wenn dies die Karte unterstützt).
Bei dieser Option musst du Breite und Höhe des Ausgabefensters nicht
angeben, denn MPlayer ermittelt diese Werte automatisch vom
Dezimierungswert (siehe unten).
.IPs decimation=<1|2|4>
Wählt die Bildgröße für die Hardware-MJPEG-Kompression:
.RSss
1: volle Größe
    704x576    PAL
    704x480    NTSC
.br
2: mittlere Größe
    352x288    PAL
    352x240    NTSC
.br
4: kleine Größe
    176x144    PAL
    176x120    NTSC
.REss
.IPs quality=<0\-100>
Wählt die Qualität der JPEG-Kompression.
(< 60 für volle Größe empfohlen)
.IPs tdevice=<Wert>
Gib Gerät für TV-Videotext an (Beispiel: /dev/\:vbi0) (Standard: kein).
.IPs tformat=<Format>
Gib das Anzeigeformat für TV-Videotext an (Standard: 0):
.RSss
0: opak
.br
1: transparent
.br
2: opak mit invertierten Farben
.br
3: transparent mit invertierten Farben
.REss
.IPs tpage=<100\-899>
Gib initiale Seitenzahl für TV-Videotext an (Standard: 100).
.IPs tlang=<\-1\-127>
Gib den Standardsprachcode für Videotext an (Standard: 0), der als primäre
Sprache verwendet wird, bis ein Typ-28-Paket empfangen wird.
Nützlich, wenn der Videotext keine lateinischen Buchstaben verwendet, die
Sprachcodes aus irgendwelchen Gründen aber nicht via Typ-28-Pakete
übertragen werden.
Setze diese Option auf \-1 für eine Liste der unterstützten Sprachcodes.
.IPs "hidden_video_renderer (nur bei dshow)"
Terminiere Stream mit Videorenderer anstelle mit Null-Renderer
(Standard: aus).
Nützlich, wenn Video einfriert, der Ton jedoch nicht.
.I ANMERKUNG:
Funktioniert möglicherweise nicht mit der Kombination \-vo directx und \-vf
crop.
.IPs "hidden_vp_renderer (nur bei dshow)"
Terminiere den VideoPort-Pin-Stream mit dem Videorenderer anstatt ihn vom
Graph zu entfernen (Standard: aus).
Nützlich, wenn deine Karte einen VideoPort-Pin hat und das Video ruckelt.
.I ANMERKUNG:
Funktioniert möglicherweise nicht mit der Kombination \-vo directx und \-vf
crop.
.IPs "system_clock (nur bei dshow)"
Verwende die Systemuhr als Synchronisationsquelle anstall der Standarduhr des
Graphen (normalerweise die Uhr von einer der Live-Quellen im Graph).
.IPs "normalize_audio_chunks (nur bei dshow)"
Erstelle Audiostücke von der Dauer gleich der eines Videoframes (Standard:
aus).
Manche Soundkarten produzieren Audiostücke von 0.5 Sekunden Länge, was
zusammen mit immediatemode=0 zu ruckelndem Video führt.
.RE
.
.TP
.B \-tvscan <Option1:Option2:...> (nur bei TV und MPlayer)
Mache Einstellungen für den TV-Kanal-Scanner.
MPlayer wird auch Werte für die Option "\-tv channels=" ausgeben,
inklusive der existierenden und der gerade gefundenen Kanäle.
.sp 1
Verfügbare Unteroptionen sind:
.RSs
.IPs autostart
Beginne Kanal-Scan unmittelbar nach dem Start (Standard: deaktiviert).
.IPs period=<0.1\-2.0>
Gib die Verzögerung an in Sekunden, bevor zum nächsten Kanal gewechselt wird
(Standard: 0.5).
Niedrigere Werte bewirken schnelleres Scannen, können inaktive TV-Kanäle
jedoch als aktiv erkennen.
.IPs threshold=<1\-100>
Schwellenwert für die Signalstärke (in Prozent), wie vom Gerät angegeben
(Standard: 50).
Eine Signalstärke höher als dieser Wert ist Anzeichen dafür, dass der
momentan gescannte Kanal aktiv ist.
.RE
.
.TP
.B \-user <Benutzername> (siehe auch \-passwd) (nur bei Netzwerk)
Gibt den Benutzernamen für die HTTP-Authentifizierung an.
.
.TP
.B \-user\-agent <Zeichenkette>
Benutze Zeichenkette als User-Agent beim HTTP-Streaming.
.
.TP
.B \-vid <ID>
Wählt die Videospur (MPG: 0\-15 ASF: 0\-255 MPEG-TS: 17\-8190).
Beim Abspielen von MPEG-TS-Streams benutzt MPlayer/\:MEncoder das erste
Programm (falls vorhanden) mit dem gewählten Video-Stream.
.
.TP
.B \-vivo <Unteroptionen> (DEBUG-CODE)
Erzwingt Audioparameter für den VIVO-Demuxer (nur für Debugging-Zwecke).
FIXME: Dokumentiere dies.
.
.
.
.SH "OSD-/UNTERTITEL-OPTIONEN"
.I ANMERKUNG:
Siehe auch \-vf expand.
.
.TP
.B \-ass (nur bei FreeType)
Schaltet das Zeichnen von SSA/ASS-Untertiteln ein.
Mit dieser Option wird libass für externe SSA/ASS-Untertitel und
Matroska-Spuren verwendet.
Du möchtest vielleicht auch \-embeddedfonts verwenden.
.br
.I ANMERKUNG:
Im Gegensatz zum normalen OSD verwendet libass fontconfig automatisch. Um
dies auszuschalten, verwende \-nofontconfig.
.
.TP
.B \-ass\-border\-color <Wert>
Setzt die Rahmen(rand)farbe für Textuntertitel.
Das Farbformat ist RRGGBBAA.
.
.TP
.B \-ass\-bottom\-margin <Wert>
Fügt einen schwarzen Streifen unten ins Bild hinzu.
Der SSA/ASS-Renderer kann Untertitel dorthin legen (mit \-ass\-use\-margins).
.
.TP
.B \-ass\-color <Wert>
Setzt die Farbe für Textuntertitel.
Das Farbformat ist RRGGBBAA.
.
.TP
.B \-ass\-font\-scale <Wert>
Setze den Skalierungskoeffizienten, der für Schriften im
SSA/ASS-Renderer verwendet werden soll.
.
.TP
.B \-ass\-force\-style <[Style.]Param=Wert[,...]>
Überschreibe Stil- oder Skriptinfo-Parameter.
.sp
.I EXAMPLE:
.PD 0
.RSs
\-ass\-force\-style FontName=Arial,Default.Bold=1
.br
\-ass\-force\-style PlayResY=768
.RE
.PD 1
.
.TP
.B \-ass\-hinting <Typ>
Setze den Typ für das Hinting.
<Typ> kann sein:
.PD 0
.RSs
.IPs 0
kein Hinting
.IPs 1
Autohinter von FreeType, light-Modus
.IPs 2
Autohinter von FreeType, normaler Modus
.IPs 3
nativer Hinter der Schrift
.IPs "0-3 + 4"
Das gleiche, Hinting wird jedoch nur durchgeführt, wenn das OSD auf
Bildschirmauflösung gezeichnet wird und daher nicht skaliert wird.
.RE
.RSs
Der Standardwert ist 7 (benutze nativen Hinter für unskaliertes OSD und sonst
kein Hinting).
.RE
.PD 1
.
.TP
.B \-ass\-line\-spacing <Wert>
Setzt den Wert für den Zeilenabstand für den SSA/ASS-Renderer.
.
.TP
.B \-ass\-styles <Dateiname>
Lade alle SSA/ASS-Styles, die in der angegebenen Datei gefunden wurden, und
verwende sie für das Zeichnen von Textuntertiteln.
Der Syntax der Datei ist genau wie der Abschnitt [V4 Styles] / [V4+ Styles]
von SSA/ASS.
.
.TP
.B \-ass\-top\-margin <Wert>
Fügt einen schwarzen Streifen oben ins Bild hinzu.
Der SSA/ASS-Renderer kann Obertitel dorthin legen (mit \-ass\-use\-margins).
.
.TP
.B \-ass\-use\-margins
Aktiviert die Platzierung der Ober- und Untertitel in schwarzen
Rändern, wenn sie verfügbar sind.
.
.TP
.B \-dumpjacosub (nur bei MPlayer)
Konvertiert den (mit der \-sub\-Option angegebenen) Untertitel in das
zeitbasierende JACOsub-Untertitelformat.
Erstellt eine Datei dumpsub.js im aktuellen Verzeichnis.
.
.TP
.B \-dumpmicrodvdsub (nur bei MPlayer)
Konvertiert den (mit der \-sub\-Option angegebenen) Untertitel in das
MicroDVD-Untertitelformat.
Erstellt eine Datei dumpsub.sub im aktuellen Verzeichnis.
.
.TP
.B \-dumpmpsub (nur bei MPlayer)
Konvertiert den (mit der \-sub\-Option angegebenen) Untertitel in das
MPlayer-Untertitelformat MPsub.
Erstellt eine Datei dump.mpsub im aktuellen Verzeichnis.
.
.TP
.B \-dumpsami (MPlayer only)
Konvertiert den (mit der \-sub\-Option angegebenen) Untertitel in das
zeitbasierende SAMI-Untertitelformat.
Erstellt eine Datei dumpsub.smi im aktuellen Verzeichnis.
.
.TP
.B \-dumpsrtsub (nur bei MPlayer)
Konvertiert den (mit der \-sub\-Option angegebenen) Untertitel in das
zeitbasierende SubViewer-Untertitelformat (SRT).
Erstellt eine Datei dumpsub.srt im aktuellen Verzeichnis.
.br
.I HINWEIS:
Einige Hardwareplayer können nicht mit SRT-Untertiteln mit Unix-Zeilenenden
umgehen.
Wenn du Pech hast und solch ein Gerät besitzt, solltest du unix2dos oder ein
ähnliches Programm benutzen,
um die Unix-Zeilenenden durch DOS/Windows-Zeilenenden zu ersetzen.
.
.TP
.B \-dumpsub (nur bei MPlayer) (BETA CODE)
Speichert den Untertitel-Substream eines VOB-Streams.
Siehe auch die Optionen \-dump*sub und \-vobsubout*.
.
.TP
.B \-embeddedfonts (nur bei FreeType)
Aktiviert die Extraktion von in Matroska eingebetteten Schriften (Standard:
deaktiviert).
Diese Schriften können für das Rendern von SSA/ASS-Untertiteln verwendet werden
(Option \-ass).
Schriftdateien werden im Verzeichnis ~/.mplayer/\:fonts angelegt.
.br
.I ANMERKUNG:
Bei der Verwendung von FontConfig 2.4.2 oder neuer werden eingebettete
Schriften direkt vom Speicher geöffnet; diese Option ist per Voreinstellung
aktiviert.
.
.TP
.B \-ffactor <Nummer>
Resampling der Alpha-Matrix der Schrift.
Mögliche Werte:
.PD 0
.RSs
.IPs 0
komplett weiße Schriften
.IPs 0.75
sehr dünner schwarzer Umriss (Standard)
.IPs 1
dünner schwarzer Umriss
.IPs 10
dicker schwarzer Umriss
.RE
.PD 1
.
.TP
.B \-flip\-hebrew (nur bei FriBiDi)
Schaltet horizontales Spiegeln der Untertitel mittels FriBiDi ein.
.
.TP
.B \-noflip\-hebrew\-commas
Ändere die Annahmen von FriBiDi über die Platzierung von Kommata in
Untertiteln.
Benutze dies, falls Kommata in Untertiteln am Anfang eines Satzes anstatt am
Ende angezeigt werden.
.TP
.B \-font <Pfad zur font.desc-Datei, Pfad zur Schriftdatei (FreeType), Schriftmuster (Fontconfig)>
Sucht nach den OSD-/\:Untertitelschriften in einem anderen Verzeichnis
(Standard für normale Schriften: ~/\:.mplayer/\:font/\:font.desc,
Standard für FreeType-Schriften: ~/.mplayer/\:subfont.ttf,
Standard für Fontconfig: "sans-serif").
.br
.I ANMERKUNG:
Bei FreeType gibt diese Option den Pfad zur Schriftdatei an.
Bei Fontconfig gibt diese Option das Fontconfig-Schriftmuster an.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-font ~/\:.mplayer/\:arial-14/\:font.desc
.br
\-font ~/\:.mplayer/\:arialuni.ttf
.br
\-font 'Bitstream Vera Sans'
.br
\-font 'Bitstream Vera Sans:style=Bold'
.RE
.PD 1
.
.TP
.B \-fontconfig (nur bei fontconfig)
Ermöglicht die Benutzung von Schriften, die von fontconfig verwaltet werden
(Standard: automatische Erkennung).
.br
.I ANMERKUNG:
Für durch libass gerenderte Untertitel wird fontconfig automatisch
verwendet, nicht jedoch für das OSD. Mit \-fontconfig wird es sowohl für
libass als auch das OSD verwendet, mit \-nofontconfig dagegen überhaupt
nicht, d. h. nur dann funktionieren \-font und \-subfont mit einem
angegebenen Dateinamen.
.
.TP
.B \-forcedsubsonly
Stelle nur erzwungene DVD-Untertitel in der z.B.\& mit \-slang gewählten
Sprache dar.
.
.TP
.B \-fribidi\-charset <Zeichensatzname> (nur bei FriBiDi)
Gibt den Zeichensatz an, der an FriBiDi übergeben wird, wenn Untertitel
decodiert werden, die nicht im UTF8-Format sind (Standard: ISO8859\-8).
.
.TP
.B \-ifo <VOBsub IFO-Datei>
Gibt die Datei an, aus der MPlayer die Palette und die Framegröße für
VOBsub-Untertitel lädt.
.
.TP
.B \-noautosub
Deaktiviert das automatische Laden von Untertiteln.
ANMERKUNG: VOBsub-Untertitel sind nicht betroffen.
.
.TP
.B \-osd\-duration <Zeit> (nur bei MPlayer)
Setzt die Anzeigedauer der OSD-Meldungen in ms (Standard: 1000).
.
.TP
.B \-osd\-fractions <0\-2>
Setzt die Art der Anzeige von Nachkommastellen des aktuellen Zeitstempels im
OSD:
.PD 0
.RSs
.IPs 0
Keine Anzeige der Nachkommastellen (Standard).
.IPs 1
Zeige die ersten beiden Nachkommastellen.
.IPs 2
Zeige genäherte Framezahl an.
Die angezeigte Framezahl ist nicht exakt, sondern nur genähert.
Für variable FPS ist die Näherung weit von der tatsächlichen Framezahl
entfernt.
.RE
.PD 1
.
.TP
.B \-osdlevel <0\-3> (nur bei MPlayer)
Gibt den Modus an, in dem das OSD startet:
.PD 0
.RSs
.IPs 0
nur Untertitel
.IPs 1
Lautstärkeleiste und Positionsanzeige (Standard)
.IPs 2
Lautstärkeleiste, Positionsanzeige, Zeitangabe und prozentuale Dateiposition
.IPs 3
Lautstärkeleiste, Positionsanzeige, Zeitangabe, prozentuale Dateiposition und
Gesamtzeit
.RE
.PD 1
.
.TP
.B \-overlapsub
Erlaubt die Anzeige des nächsten Untertitels, während der aktuelle noch
sichtbar ist.
(Standardverhalten ist, diese Unterstützung nur bei bestimmten Formaten zu
aktivieren).
.
.TP
.B \-progbar\-align <0-100>
Gibt die vertikale Positionierung der OSD-Fortschrittsanzeige an.
(0: oben, 100: unten, Standard ist 50, d. h. Mitte).
.
.TP
.B \-sid <ID> (siehe auch \-slang, \-vobsubid)
Zeigt den Untertitelstream an, der durch <ID> (0\-31) angegeben wird.
Mplayer gibt eine Liste der verfügbaren Untertitel-IDs aus, wenn er im
ausführlichen (\-v) Modus gestartet wird.
Wenn du einen der Untertitel einer DVD nicht auswählen kannst, versuche auch
die Option \-vobsubid.
.
.TP
.B \-slang <Sprachcode[,Sprachcode,...]> (siehe auch \-sid)
Gibt eine Prioritätenliste von zu benutzenden Untertitelsprachen an.
Verschiedene Containerformate verwenden unterschiedliche Sprachcodes.
DVDs benutzen ISO 639\-1\-Sprachcodes mit zwei Buchstaben, Matroska verwendet
ISO 639\-2\-Sprachcodes mit drei Buchstaben, während OGM einen formfreien
Bezeichner gebraucht.
Mplayer gibt eine Liste der verfügbaren Untertitel-IDs aus, wenn er im
ausführlichen (\-v) Modus gestartet wird.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "mplayer dvd://1 \-slang hu,en"
Wählt den ungarischen Untertitel einer DVD und verwendet die englischen
Untertitel, wenn es keine ungarischen gibt.
.IPs "mplayer \-slang jpn example.mkv"
Spielt eine Matroskadatei mit japanischen Untertiteln ab.
.RE
.PD 1
.
.TP
.B \-spuaa <Modus>
Antialiasing-/\:Skalierungsmodus für DVD/\:VOBsub.
Ein Wert von 16 kann zu <Modus> hinzuaddiert werden, um die Skalierung auch
dann zu erzwingen, wenn das Orignalbild und das skalierte Bild bereits die
gleiche Größe haben.
Dies kann benutzt werden, um z.B.\& die Untertitel mit einem Gaußschen
Unschärfefilter zu glätten.
Die verfügbaren Modi lauten:
.PD 0
.RSs
.IPs 0
nichts (am schnellsten, sehr hässlich)
.IPs 1
approximiert (kaputt?)
.IPs 2
komplett (langsam)
.IPs 3
bilinear (Standard, schnell und nicht zu übel)
.IPs 4
benutzt Gaußsche Unschärfe des Softwareskalierers (sieht sehr gut aus)
.RE
.PD 1
.
.TP
.B \-spualign <\-1\-2>
Gibt an, wie SPU-Untertitel (DVD/\:VOBsub) positioniert werden sollen.
.PD 0
.RSs
.IPs "\-1"
Originalposition
.IPs " 0"
Positioniere oben (Originalverhalten, Standard).
.IPs " 1"
Positioniere mittig.
.IPs " 2"
Positioniere unten.
.RE
.PD 1
.
.TP
.B \-spugauss <0.0\-3.0>
Varianzparameter des Gaußschen Weichzeichners bei Benutzung von \-spuaa 4.
Höhere Werte stehen für stärkere Weichzeichnung (Standard: 1.0).
.
.TP
.B \-sub <Untertiteldatei1, Untertiteldatei2,...>
Diese Untertitel werden benutzt/\:angezeigt.
Nur ein Untertitel kann zu einer Zeit angezeigt werden.
.
.TP
.B \-sub\-bg\-alpha <0\-255>
Gibt den Wert des Alphakanals bei Untertiteln und für OSD-Hintergründe an.
Große Werte bedeuten mehr Transparenz.
Der Wert 0 steht für vollständige Transparenz.
.
.TP
.B \-sub\-bg\-color <0\-255>
Gibt den Farbwert für Untertitel und den OSD-Hintergrund an.
Momentan werden Untertitel nur in Graustufen dargestellt, so dass dieser
Wert äquivalent zur Farbintensität ist.
Der Wert 255 steht für weiß und 0 für schwarz.
.
.TP
.B \-sub\-demuxer <[+]Name> (nur mit \-subfile) (BETA CODE)
Erzwinge Untertitel-Demuxertyp für \-subfile.
Benutze '+' vor dem Namen um den Typ zu erzwingen, dies wird ein paar
Überprüfungen überspringen!
Gib den Demuxernamen an wie durch \-sub\-demuxer help angezeigt.
Für Rückwärtskompatibilität wird auch die in libmpdemux/\:demuxer.h definierte
Demuxer-ID akzeptiert.
.
.TP
.B \-sub\-fuzziness <Modus>
Passe die Unschärfe für die Suche nach Untertiteln an (gilt nicht für
VOBsub):
.PD 0
.RSs
.IPs 0
exakte Übereinstimmung (Standard)
.IPs 1
Lade alle Untertitel, die den Filmnamen enthalten.
.IPs 2
Lade alle Untertitel im aktuellen Verzeichnis.
.RE
.PD 1
.
.TP
.B \-sub\-no\-text\-pp
Deaktiviert Text-Postprocessing jeder Art nach dem Laden der Untertitel.
Wird für Debugging-Zwecke verwendet.
.
.TP
.B \-subalign <0\-2>
Gibt an, welche Kante der Untertitel an der von \-subpos angegebenen Höhe
positioniert werden sollen.
.PD 0
.RSs
.IPs 0
Positioniere obere Untertitelkante  (Originalverhalten).
.IPs 1
Positioniere mittlere Untertitelkante.
.IPs 2
Positioniere untere Untertitelkante (Standard).
.RE
.PD 1
.
.TP
.B "\-subcc \ "
Zeigt DVD-Closed-Caption-Untertitel (CC) an.
Diese sind
.B keine
VOB-Untertitel
sondern spezielle ASCII-Untertitel für Hörgeschädigte, die
in VOB-Userdatenstreams auf den meisten Region-1-DVDs zu finden sind.
CC-Untertitel wurden bisher auf keinen DVDs für andere Regionen entdeckt.
.
.TP
.B \-subcp <Codepage> (nur bei iconv)
Wenn dein System iconv(3) unterstützt, kannst du mit dieser Option
die Codepage für die Untertitel angeben. Sie hat Vorrang sowohl vor \-utf8
wie auch vor \-unicode.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-subcp latin2
.br
\-subcp cp1250
.RE
.PD 1
.
.TP
.B \-subcp enca:<Sprache>:<alternative Codepage> (nur bei ENCA)
Du kannst eine Sprache im 2-Zeichen-Sprachcode angeben, um ENCA automatisch
eine Codepage erkennen zu lassen.
Wenn du nicht sicher bist, gib irgendetwas ein und sieh dir die Ausgaben von
mplayer \-v an, um die verfügbaren Sprachen zu sehen.
Benutze __ (zwei Unterstriche), falls deine Sprache nicht unterstützt wird.
Die alternative Codepage gibt die zu benutzende Codepage an, falls die
automatische Erkennung versagt.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-subcp enca:cs:latin2"
Nimm an, die Untertitel seien Tschechisch, und rate die Kodierung.
Wenn die Erkennung versagt, benutze latin2.
.IPs "\-subcp enca:pl:cp1250"
Rate die Kodierung für Polnisch, benutze sonst cp1250.
.IPs "\-subcp enca:__:latin1"
Allgemeine Erkennung (meistens Unicode) mit latin1 als Alternative.
.RE
.PD 1
.
.TP
.B \-subdelay <sek>
Verzögert die Untertitel um <sek> Sekunden.
Kann negativ sein.
.
.TP
.B \-subfile <Dateiname> (BETA CODE)
Zur Zeit unbrauchbar.
Das gleiche wie \-audiofile, jedoch für Untertitel-Streams (OggDS?).
.
.TP
.B \-subfont <Pfad zur Schriftdatei (FreeType), Schriftmuster (Fontconfig)> (nur bei FreeType)
Setzt die Schriftart für Untertitel.
Wenn kein \-subfont gegeben ist, wird \-font verwendet.
.
.TP
.B \-subfont\-autoscale <0\-3> (nur bei FreeType)
Setzt den Modus für automatische Skalierung der Untertitel.
.br
.I ANMERKUNG:
0 bedeutet, dass text-scale und osd-scale Schrifthöhen in Punkten sind.
.sp 1
Der Modus kann folgende Werte annehmen:
.sp 1
.PD 0
.RSs
.IPs 0
keine automatische Skalierung
.IPs 1
proportional zur Höhe des Films
.IPs 2
proportional zur Breite des Films
.IPs 3
proportional zur Diagonale des Films (Standard)
.RE
.PD 1
.
.TP
.B \-subfont\-blur <0\-8> (nur bei FreeType)
Setzt den Verwischradius für die Schriften (Standard: 2).
.
.TP
.B \-subfont\-encoding <Wert>
Setzt die Schriftcodierung.
Wenn 'unicode' angegeben wird, werden alle Zeichen der Schriftdatei
gerendert und Unicode wird benutzt werden (Standard: unicode). (Ohne FreeType
bewirkt jeder andere Wert, dass keine Unicode-Zeichen aus font.desc\-Dateien
gerendert werden. Mit FreeType und für andere Werte als 'unicode' muss dein
System iconv(3) unterstützen, um zu funktionieren.)
.
.TP
.B \-subfont\-osd\-scale <0\-100> (nur bei FreeType)
Setzt den Koeffizienten für die automatische Skalierung der OSD-Elemente
(Standard: 6).
.
.TP
.B \-subfont\-outline <0\-8> (nur bei FreeType)
Setzt die Schriftumrissstärke (Standard: 2).
.
.TP
.B \-subfont\-text\-scale <0\-100> (nur bei FreeType)
Setzt den Koeffizienten für die automatische Skalierung der Untertitel als
prozentualen Anteil der Anzeigegröße (Standard: 5).
.
.TP
.B \-subfps <Rate>
Gibt die Framerate der Untertitel an (Standard: Framerate des Films).
.br
.I ANMERKUNG:
<Rate> > Film-Fps beschleunigt Untertitel bei bildbasierten
Untertitel-Dateien und verlangsamt sie bei zeitbasierten.
.
.TP
.B \-subpos <0\-100> (nützlich mit \-vf expand)
Gibt die Position der Untertitel auf dem Bildschirm an.
Der Wert gibt die vertikale Position der Untertitel in % der Anzeigehöhe an.
.
.TP
.B \-subwidth <10\-100>
Gibt die maximale Breite der Untertitel an.
Nützlich für Ausgabe auf dem Fernseher.
Der Wert ist die Breite des Untertitels in %  der Bildschirmbreite.
.
.TP
.B \-noterm\-osd
Deaktiviert die Anzeige der OSD-Meldungen auf der Konsole bei nichtverfügbarer
Videoausgabe.
.
.TP
.B \-term\-osd\-esc
Gibt die Escapesequenz an, mit der OSD-Meldungen auf der Konsole eingeleitet
werden.
Die Escapesequenz sollte den Cursor zum Anfang der für OSD benutzten Zeile
bewegen und die Zeile löschen (Standard: ^[[A\\r^[[K).
.
.TP
.B \-unicode
Weist MPlayer an, die Untertiteldatei als Unicode zu behandeln. (Diese Option
ist nur wirksam, wenn weder \-subcp noch \-utf8 verwendet werden.)
.
.TP
.B \-unrarexec <Pfad zum unrar-Programm> (unter MingW nicht unterstützt)
Gib den Pfad zum unrar-Programm an, damit MPlayer es für den Zugriff auf
rar-komprimierte VOBsub-Dateien verwenden kann (Standard: nicht gesetzt, also
ist dieses Feature deaktiviert).
Der Pfad muss den Dateinamen des Programms beinhalten, z.B.\&
/usr/local/bin/unrar.
.
.TP
.B "\-utf8 \ \ "
Weist MPlayer an, die Untertiteldatei als UTF-8 zu behandeln. (Diese Option
ist nur wirksam, wenn \-subcp nicht verwendet wird, und sie hat Vorrang vor
\-unicode.)
.
.TP
.B \-vobsub <VOBsub-Datei ohne Erweiterung>
Gibt eine VOBsub-Datei an, die für die Untertitel verwendet werden soll.
Angegeben wird der volle Pfadname ohne Erweiterung, z.B.\& ohne '.idx',
\'.ifo' oder '.sub'.
.
.TP
.B \-vobsubid <0\-31>
Gibt die ID für die VOBsub-Untertitel an.
.
.
.
.SH "OPTIONEN FÜR DIE AUDIOAUSGABE (NUR BEI MPLAYER)"
.
.TP
.B \-abs <Wert> (nur bei \-ao oss) (VERALTET)
Überschreibt die automatisch erkannte Puffergröße der Audiotreiber/\:-karte.
.
.TP
.B \-format <Format> (siehe auch format Audiofilter)
Wählt das Sampleformat, das für die Ausgabe der Audiofilterschicht zur
Soundkarte verwendet wird.
Die Werte, die <Format> annehmen kann, stehen unten in der Beschreibung
des format Audiofilters.
.
.TP
.B \-mixer <Gerät>
Benutze einen anderen Mixer als den Standardmixer /dev/\:mixer.
Bei ALSA ist dies der Mixer-Name.
.
.TP
.B \-mixer\-channel <Mixer-Anschluß>[,Mixer-Index] <nur bei \-ao oss und \-ao
alsa)
Bei dieser Option benutzt MPlayer zur Lautstärkeregulierung einen anderen
Anschluß als die Standardeinstellung PCM.
Optionen für OSS beinhalten
.B vol, pcm, line.
Für eine komplette Liste der Optionen suche nach SOUND_DEVICE_NAMES in der
Datei /usr/\:include/\:linux/\:soundcard.h.
Bei ALSA kannst du die Namen benutzen, die beispielsweise alsamixer anzeigt,
wie
.B Master, Line, PCM.
.br
.I ANMERKUNG:
Die Namen von ALSA-Mixerkanälen gefolgt von einer Nummer müssen im Format
<Name,Nummer> angegeben werden, z.B.\& muss ein Kanal, der im alsamixer 'PCM 1'
heißt, umbenannt werden in
.BR PCM,1 .
.
.TP
.B \-softvol
Erzwingt den Gebrauch des Softwaremixers anstelle des Mixers der Soundkarte.
.
.TP
.B \-softvol\-max <10.0\-10000.0>
Setzt die maximale Verstärkung in Prozent (Standard: 110).
Ein Wert von 200 erlaubt dir, die Lautstärke bis zum doppelten des aktuellen
Lautstärkelevels einzustellen.
Bei Werten unter 100 wird die anfängliche Lautstärke (die 100% ist) über dem
Maximum sein, was z.B.\& das OSD nicht korrekt darstellen kann.
.
.TP
.B \-volstep <0\-100>
Setzt die Schrittweite der Mixer-Lautstärkeänderungen in Prozent der
Gesamtweite (Standard: 3).
.
.TP
.B \-volume <-1\-100> (siehe auch \-af volume)
Setze die Lautstärke im Mixer zum Programmstart, entweder in Hardware oder
Software (in Verbindung mit \-softvol).
Ein Wert von \-1 (Standard) ändert die Lautstärke nicht.
.
.
.
.SH "AUDIOAUSGABETREIBER (NUR BEI MPLAYER)"
Audioausgabetreiber sind Schnittstellen zu verschiedenen Ausgabeeinrichtungen.
Die Syntax ist folgende:
.
.TP
.B \-ao <Treiber1[:Suboption[=Wert]:...],Treiber2,...[,]>
Gibt eine Prioritätenliste der zu benutzenden Audiotreiber an.
.PP
Wenn die Liste mit ',' endet, so werden notfalls auch nicht in der
Kommandozeile aufgeführte Treiber benutzt.
Suboptionen sind optional und können größtenteils weggelassen werden.
.br
.I ANMERKUNG:
Eine Liste der eincompilierten Audiotreiber erhältst du mit \-ao help.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-ao alsa,oss,"
Probiere den ALSA-Treiber, dann den OSS-Treiber, dann andere.
.IPs "\-ao alsa:noblock:device=hw=0.3"
Setzt den noblock-Modus und den Gerätenamen auf erste Karte,
viertes Gerät.
.RE
.PD 1
.sp 1
Verfügbare Audioausgabetreiber sind folgende:
.
.TP
.B "alsa\ \ \ "
ALSA 0.9/1.x Audioausgabetreiber.
.PD 0
.RSs
.IPs noblock
Setzt den noblock-Modus.
.IPs device=<Gerät>
Setzt den Gerätenamen.
Ersetze jedes ',' mit '.' und jeden ':' mit '=' im ALSA-Gerätenamen.
Benutze für hwac3-Ausgabe via S/PDIF ein "iec958"- oder "spdif"-Gerät, es sei
denn, du weißt wirklich, wie sie gesetzt werden muss.
.RE
.PD 1
.
.TP
.B "oss\ \ \ \ "
OSS Audioausgabetreiber.
.PD 0
.RSs
.IPs <dsp-device>
Setzt das Audioausgabegerät (Standard: /dev/\:dsp).
.IPs <mixer-device>
Setzt das Audiomixergerät (Standard: /dev/\:mixer).
.IPs <mixer-channel>
Setzt den Audiomixerkanal (Standard: pcm).
.RE
.PD 1
.
.TP
.B sdl (nur bei SDL) (nur bei SDL) (nur bei SDL) (nur bei SDL) (nur bei SDL) (nur bei SDL) (nur bei SDL) (nur bei SDL) (Simple
Directmedia Layer) Bibliothek.
.PD 0
.RSs
.IPs <Treiber>
Wähle den SDL-Audioausgabetreiber explizit (Standard: lasse SDL wählen).
.RE
.PD 1
.
.TP
.B "arts\ \ \ "
Audioausgabe über den aRts-Daemon.
.
.TP
.B "esd\ \ \ \ "
Audioausgabe über den ESD-Daemon.
.PD 0
.RSs
.IPs <Server>
Wähle den zu benutzenden ESD-Server explizit (Standard: localhost).
.RE
.PD 1
.
.TP
.B "jack\ \ \ \ "
Audioausgabe über JACK (Jack Audio Connection Kit)
.PD 0
.RSs
.IPs (no)connect
Erzeugt automatisch Verbindungen zu den Ausgabeports
(Standard: eingeschaltet).
Falls eingeschaltet wird die Anzahl der Audiokanäle durch die Anzahl der
gefundenen Ausgabeports nach oben begrenzt.
.IPs port=<Name>
Verbindet zu den Ports mit dem angegebenen Namen (Standard: physikalische
Ports).
.IPs name=<Client-Name>
Client-Name, der an JACK weitergegeben wird (Standard: MPlayer [<PID>]).
Nützlich, falls du bestimmte Verbindungen automatisch eingerichtet haben
möchtet.
.IPs (no)estimate
Schätze die Audioverzögerung, sollte die Wiedergabe flüssiger machen
(Standard: eingeschaltet).
.RE
.PD 1
.
.TP
.B "nas\ \ \ \ "
Audioausgabe über NAS
.
.TP
.B coreaudio (nur bei Mac OS X)
Nativer Mac OS X-Audioausgabetreiber.
.
.TP
.B "openal\ "
Experimenteller OpenAL-Audioausgabetreiber
.
.TP
.B "pulse\ \ "
PulseAudio-Audioausgabetreiber
.PD 0
.RSs
.IPs "[<Host>[:<Ausgabesenke>[:Pausenproblem]]]"
Gib den Host und optional die zu verwendende Ausgabesenke an.
Leere Angabe von <Host> verwendet eine lokale Verbindung, "localhost" verwendet
Netzwerkverbindungen (höchstwahrscheinlich nicht, was du willst).
Der Behelf zur Umgehung des Pausenproblems lässt sich explizit erzwingen
(Standard: automatische Erkennung). Um nur diesen ohne Host und Ausgabesenke
anzugeben, lautet die Syntax: \-ao pulse:::Pausenproblem
.RE
.PD 1
.
.TP
.B sgi (nur bei SGI)
Nativer SGI-Audioausgabetreiber.
.PD 0
.RSs
.IPs "<Name des Ausgabegeräts>"
Wähle das zu nutzende Ausgabegerät/\:Interface explizit
(Standard: systemweite Voreinstellung).
Beispiele: 'Analog Out' oder 'Digital Out'.
.RE
.PD 1
.
.TP
.B sun (nur bei Sun)
Nativer Sun-Audioausgabetreiber.
.PD 0
.RSs
.IPs <Gerät>
Wähle das zu benutzende Audiogerät explizit (Standard: /dev/\:audio).
.RE
.PD 1
.
.TP
.B win32 (nur bei Windows)
Nativer Windows-Waveout-Audioausgabetreiber.
.
.TP
.B dsound (nur bei Windows)
DirectX-Audioausgabetreiber DirectSound
.PD 0
.RSs
.IPs device=<Gerätenummer>
Setzt das zu benutzende Gerät.
Wenn du eine Datei mit \-v abspielst, wird dir eine Liste aller verfügbaren
Geräte angezeigt.
.RE
.PD 1
.
.TP
.B dxr2 (siehe auch \-dxr2) (nur bei DXR2)
DXR2-spezifischer Ausgabetreiber von Creative.
.
.TP
.B v4l2 (benötigt Linux-Kernel 2.6.22+)
Audioausgabetreiber für V4L2-Karten mit Hardware-MPEG-Decoder.
.
.TP
.B mpegpes (nur bei DVB)
Audioausgabetreiber für DVB-Karten, der die Ausgabe in eine MPEG-PES-Datei
schreibt, wenn keine DVB-Karte installiert ist.
.PD 0
.RSs
.IPs card=<1\-4>
DVB-Karte, die benutzt werden soll, wenn mehr als eine Karte verfügbar ist.
Wird keine Karte angegeben, sucht MPlayer die erste verfügbare Karte.
.IPs file=<Dateiname>
Ausgabedateiname
.RE
.PD 1
.
.TP
.B "null\ \ \ "
Produziert keine Audioausgabe, behält aber die Videoabspielgeschwindigkeit bei.
Benutze \-nosound für Benchmarking-Zwecke.
.
.TP
.B "pcm\ \ \ \ "
Filewriter-Audioausgabe im raw-PCM/Wave-Format.
.PD 0
.RSs
.IPs (no)waveheader
Fügt den Wave-Header (nicht) hinzu (Standard: hinzugefügt).
Wird er nicht hinzugefügt, erfolgt die Ausgabe als raw-PCM.
.IPs file=<Dateiname>
Schreibe den Sound nach <Dateiname> und nicht in die Standarddatei
audiodump.wav.
Wurde nowaveheader angegeben, ist der Standard audiodump.pcm.
.IPs "fast\ "
Versuche, schneller als mit der eigentlichen Abspielgeschwindigkeit auszugeben.
Stelle sicher, dass die Ausgabe nicht abgeschnitten wird (normalerweise mit
der Nachricht "Zu viele Videopakete im Puffer").
Es ist normal, dass du die Nachricht "Your system is too SLOW to play this!"
bekommst.
.RE
.PD 1
.
.TP
.B "plugin\ \ "
Plugin-Audioausgabetreiber.
.
.
.
.SH "OPTIONEN FÜR DIE VIDEOAUSGABE (NUR BEI MPLAYER)"
.
.TP
.B \-adapter <Wert>
Bestimmt die Grafikkarte, die das Bild erhalten wird.
Du bekommst eine Liste aller verfügbaren Karten, wenn du diese Option mit \-v
aufrufst.
Funktioniert momentan nur mit dem directx-Videoausgabetreiber.
.
.TP
.B \-bpp <Farbtiefe>
Überschreibt die automatisch erkannte Farbtiefe.
Wird nur von fbdev-, dga2-, svga- und vesa-Videoausgabetreibern unterstützt.
.
.TP
.B \-border
Spiele den Film mit Fensterrand und Dekoration.
Da dies standardmäßig an ist, benutze \-noborder um die normale
Fensterdekoration abzuschalten.
.
.TP
.B \-brightness <\-100\-100>
Passt die Helligkeit der Videoausgabe an (Standard: 0).
Wird nicht von allen Videoausgabetreibern unterstützt.
.
.TP
.B \-contrast <\-100\-100>
Passt den Kontrast der Videoausgabe an (Standard: 0).
Wird nicht von allen Videoausgabetreibern unterstützt.
.
.TP
.B \-display <Name> (nur bei X11)
Gibt den Rechnernamen und die Display-Nummer des X-Servers an, auf dem
die Anzeige erscheinen soll.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-display xtest.localdomain:0
.RE
.PD 1
.
.TP
.B "\-dr \ \ \ "
Schaltet direktes Rendern an (wird nicht von allen Codecs und
Videoausgabetreibern unterstützt)
.br
.I WARNUNG:
Kann zu Störungen beim OSD und bei Untertiteln führen!
.
.TP
.B \-dxr2 <Option1:Option2:...>
Mit dieser Option wird der dxr2-Videoausgabetreiber gesteuert.
.RSs
.IPs ar-mode=<Wert>
Modus für die Anpassung des Höhen-/Breitenverhältnisses (0 = normal,
1 = Panscan, 2 = letterbox (Standard))
.IPs iec958-encoded
Setzt den iec958-Ausgabemodus auf 'encoded'.
.IPs iec958-decoded
Setzt den iec958-Ausgabemodus auf 'decoded' (Standard).
.IPs macrovision=<Wert>
Macrovision-Modus (0 = aus (Standard), 1 = agc, 2 = agc 2 colorstripe,
3 = agc 4 colorstripe)
.IPs "mute\ "
Stummschalten der Soundausgabe
.IPs unmute
Ausschalten der Stummschaltung der Soundausgabe
.IPs ucode=<Wert>
Pfad zum Microcode
.RE
.RS
.sp 1
.I TV-Ausgabe
.RE
.RSs
.IPs 75ire
Schaltet den 7.5 IRE-Ausgabemodus an
.IPs no75ire
Schaltet den 7.5 IRE-Ausgabemodus ab (Standard)
.IPs "bw\ \ \ "
TV-Ausgabe in schwarz/weiß
.IPs color
TV-Ausgabe in Farbe (Standard)
.IPs interlaced
TV-Ausgabe ist interlaced (Standard)
.IPs nointerlaced
Deaktiviert die interlaced-TV-Ausgabe
.IPs norm=<Wert>
TV-Norm (ntsc (Standard), pal, pal60, palm, paln, palnc)
.IPs square-pixel
Setzt TV-Pixelmodus auf square
.IPs ccir601-pixel
Setzt TV-Pixelmodus auf ccir601
.RE
.RS
.sp 1
.I Overlay
.RE
.RSs
.IPs cr-left=<0\-500>
Setzt den Wert für das Abschneiden des Bildrandes links (Standard: 50).
.IPs cr-right=<0\-500>
Setzt den Wert für das Abschneiden des Bildrandes rechts (Standard: 300).
.IPs cr-top=<0\-500>
Setzt den Wert für das Abschneiden des Bildrandes oben (Standard: 0).
.IPs cr-bottom=<0\-500>
Setzt den Wert für das Abschneiden des Bildrandes unten (Standard: 0).
.IPs ck-[r|g|b]=<0\-255>
Setzt die Verstärkung des r(oten), g(rünen) oder b(lauen) Wertes des
Overlay-Farbschlüssels.
.IPs ck-[r|g|b]min=<0\-255>
Minimalwert für den entsprechenden Farbschlüssel
.IPs ck-[r|g|b]max=<0\-255>
Maximalwert für den entsprechenden Farbschlüssel
.IPs ignore-cache
Ignoriere die zwischengespeicherten Overlay-Einstellungen.
.IPs update-cache
Aktualisiere die zwischengespeicherten Overlay-Einstellungen.
.IPs ol-osd
Aktiviert Overlay-Onscreen-Anzeige.
.IPs nool-osd
Deaktiviert Overlay-Onscreen-Anzeige (Standard).
.IPs ol[h|b|x|y]-cor=<Wert>
Passt die Overlay-Größe (h,b) und Position (x,y) an, falls es nicht
ganz dem Fenster entspricht (Standard: 0).
.IPs overlay
Aktiviere das Overlay (Standard).
.IPs nooverlay
Aktiviere die TV-Ausgabe.
.IPs overlay-ratio=<1\-2500>
Verfeinert das Overlay (Standard: 1000).
.RE
.
.TP
.B \-fbmode <Modusname> (nur bei \-vo fbdev)
Wechselt in den angegebenen Videomodus, der als <Modusname> in
/etc/\:fb.modes steht.
.br
.I ANMERKUNG:
Der VESA-Framebuffer unterstützt den Moduswechsel nicht.
.
.TP
.B \-fbmodeconfig <Dateiname> (nur bei \-vo fbdev)
Überschreibt die Einstellung für die Konfigurationsdatei des Framebuffers
(Standard: /etc/\:fb.modes).
.
.TP
.B \-fs (siehe auch \-zoom)
Vollbildwiedergabe (zentriert den Film und erstellt schwarze Balken rund um
das Bild).
Wird nicht von allen Videoausgabetreibern unterstützt.
.
.TP
.B \-fsmode\-dontuse <0\-31> (VERALTET) (benutze die Option \-fs)
Benutze diese Option, wenn du mit dem Vollbildmodus Probleme hast.
.
.TP
.B \-fstype <Typ1,Typ2,...> (nur bei X11)
Gib eine Prioritätenliste von Vollbildmodi an, die benutzt
werden sollen.
Du kannst die Modi durch Voransetzen von '\-' negieren.
Falls du das Problem hast, dass das Vollbild von anderen Fenstern überdeckt
wird, probiere eine andere Reihenfolge.
.br
.I ANMERKUNG:
Siehe \-fstype help für eine vollständige Liste aller verfügbaren Modi.
.sp 1
Die verfügbaren Modi sind:
.sp 1
.PD 0
.RSs
.IPs above
Benutze die _NETWM_STATE_ABOVE-Anweisung, falls verfügbar.
.IPs below
Benutze die _NETWM_STATE_BELOW-Anweisung, falls verfügbar.
.IPs fullscreen
Benutze die _NETWM_STATE_FULLSCREEN-Anweisung, falls verfügbar.
.IPs layer
Benutze die _WIN_LAYER-Anweisung mit dem Standard-Layer.
.IPs layer=<0...15>
Benutze die _WIN_LAYER-Anweisung mit der angegebenen Layernummer.
.IPs netwm
Erzwinge den NETWM-Stil.
.IPs "none\ "
Richte den Vollbild-Fenster-Layer nicht ein.
.IPs stays_on_top
Benutze die _NETWM_STATE_STAYS_ON_TOP-Anweisung, falls verfügbar.
.REss
.sp 1
.RS
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs layer,stays_on_top,above,fullscreen
Standardreihenfolge; wird benutzt, wenn falsche oder nichtunterstützte Modi
angegeben werden.
.IPs \-fullscreen
Korrigiert den Vollbildwechsel bei OpenBox 1.x.
.RE
.PD 1
.
.TP
.B \-geometry x[%][:y[%]] oder [BxH][+x+y]
Gibt an, wo die Videoausgabe initial erscheint.
x und y sind Angaben in Pixeln und geben den Abstand von der linken oberen
Ecke des Bildschirms zur linken oberen Ecke des darzustellenden
Bildes an.
Wenn ein Prozentzeichen nach einem Argument verwendet wird, dann wird statt
dessen die prozentuale Bildschirmbreite/\:-höhe in diese Richtung verwendet.
Auch das bei der X-Standardoption \-geometry verwendete Format wird
unterstützt.
Falls ein externes Fenster mit der Option \-wid angegeben wird, so sind die
Koordinaten x und y relativ zur linken oberen Ecke des Fensters und nicht zu
der des Bildschirms.
.br
.I ANMERKUNG:
Diese Option wird nur von x11-, xmga-, xv-, xvmc-, xvidix-, gl, gl2,
directx-, fbdev- und tdfxfb-Videoausgabetreibern unterstützt.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs 50:40
Platziert das Fenster bei x=50, y=40.
.IPs 50%:50%
Platziert das Fenster in der Mitte des Bildschirms.
.IPs "100%\ "
Platziert das Fenster in der Mitte des rechten Randes des Bildschirmes.
.IPs 100%:100%
Platziert das Fenster in der unteren rechten Ecke des Bildschirmes.
.RE
.PD 1
.
.TP
.B \-gui-wid <Fenster-ID> (siehe auch \-wid) (nur bei GUI)
Weist die GUI an, auch ein X11-Fenster zu benutzen und sich selbst an die
Unterseite des Videos zu heften, was nützlich ist beim Einbetten einer Mini-GUI
in einen Browser (z.B.\& mit dem MPlayer-Plugin).
.
.TP
.B \-hue <\-100\-100>
Passt die Farbe des Videosignals an (Standard: 0).
Du kannst mit dieser Option Negativfarben erhalten.
Wird nicht von allen Videoausgabetreibern unterstützt.
.
.TP
.B \-monitor\-dotclock <Bereich[,Bereich,...]> (nur bei \-vo fbdev und vesa)
Gib den Bereich für dotclock oder pixelclock des Monitors an.
.
.TP
.B \-monitor\-hfreq <Bereich[,Bereich,...> (nur bei \-vo fbdev und vesa)
Gibt den Bereich für den horizontalen Frequenzbereich des Monitors an.
.
.TP
.B \-monitor\-vfreq <Bereich[,Bereich,...> (nur bei \-vo fbdev und vesa)
Gibt den Bereich für den vertikalen Frequenzbereich des Monitors an.
.
.TP
.B \-monitoraspect <Verhältnis> (siehe auch \-aspect)
Gibt das Höhen-/\:Breitenverhältnis deines Monitors oder Fernsehers an.
Der Wert 0 schaltet frühere Einstellungen (z.B.\& in der config Datei) aus.
Überschreibt bei Verwendung die Einstellung von \-monitorpixelaspect.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-monitoraspect 4:3  oder 1.3333
.br
\-monitoraspect 16:9 oder 1.7777
.RE
.PD 1
.
.TP
.B \-monitorpixelaspect <ratio> (siehe auch \-aspect)
Setze den Aspekt eines einzelnen Pixels deines Monitors oder TV-Schirms
(Standard: 1).
Ein Wert von 1 bedeutet quadratische Pixel (korrekt für (fast?) alle LCDs).
.
.TP
.B \-nodouble
Deaktiviert Double-Buffering, hauptsächlich für Debugging-Zwecke.
Double-Buffering vermeidet Flimmern dadurch, dass zwei Bilder im Speicher
gehalten werden, von denen das eine angezeigt wird, während das andere noch
decodiert wird.
Es kann das OSD negativ beeinflussen, entfernt aber oft Flimmern des OSD.
.
.TP
.B \-nograbpointer
Übernimm den Mauszeiger nach einem Wechsel des Videomodus (mit \-vm)
nicht.
Nützlich bei Multihead-Einrichtungen.
.
.TP
.B \-nokeepaspect
Behalte beim Ändern der Fenstergröße das
Höhen-/\:Breitenverhältnis nicht bei.
Funktioniert nur mit den x11-, xv-, xmga-, xvidix- und
directx-Videoausgabetreibern.
Außerdem muss dein Windowmanager unter X11 Anweisungen zum
Fenster-Seitenverhältnis verstehen.
.
.TP
.B "\-ontop\ "
Sorgt dafür, dass das Abspielfenster oberhalb von anderen Fenstern bleibt.
Wird unterstützt von Videoausgabetreibern, die X11 benutzen, außer SDL,
außerdem directx, corevideo, quartz, ggi und gl2.
.
.TP
.B \-panscan <0.0\-1.0>
Aktiviert Panscan.
Dabei werden z.B.\& bei einem 16:9-Film und einem 4:3-Monitor die Seiten
abgeschnitten, damit der komplette Bildbereich ausgefüllt wird.
Der Bereich kontrolliert, wieviel vom Bild abgeschnitten wird.
Dies funktioniert nur mit den xv-, xmga-, mga-, gl-, gl2, quartz-, corevideo- und
xvidix-Videoausgabetreibern.
.br
.I ANMERKUNG:
Werte zwischen \-1 und 0 sind auch erlaubt, jedoch höchst experimentell
und können zu Abstürzen oder schlimmerem führen.
Benutzung auf eigenes Risiko!
.
.TP
.B \-panscanrange <\-19.0\-99.0> (experimentell)
Ändert den Bereich der Panscan-Funktion (Standard: 1).
Positive Werte bedeuten ein Vielfaches des Standardbereichs.
Negative Zahlen bedeuten einen Zoom bis zum Faktor \-panscanrange+1.
Z.B.\& erlaubt \-panscanrange \-3 eine bis zu 4-fache Vergrößerung.
Diese Funktionalität ist experimentell.
Melde keine Fehler, wenn du nicht \-vo gl benutzt.
.
.TP
.B \-refreshrate <Hz>
Setze die Bildwiederholfrequenz des Monitors in Hz.
Momentan nur unterstützt von \-vo directx kombiniert mit der Option \-vm.
.
.TP
.B \-rootwin
Spielt den Film im Hauptfenster (dem Desktophintergrund) ab.
Desktophintergrundbilder können den Film allerdings verdecken.
Funktioniert nur mit den x11-, xv-, xmga-, xvidix-, quartz-, corevideo- und
directx-Videoausgabetreibern.
.
.TP
.B \-saturation <\-100\-100>
Passt die Sättigung des Videosignals an (Standard: 0).
Es ist möglich, dass du mit dieser Option ein Graustufenbild bekommst.
Wird nicht von allen Videoausgabetreibern unterstützt.
.
.TP
.B \-screenh <Pixel>
Gib die Bildschirmhöhe für Videoausgabetreiber an, die die
Bildschirmauflösung nicht kennen, wie fbdev, x11 und TV-Ausgabe.
.
.TP
.B \-screenw <Pixel>
Gib die Bildschirmbreite für Videoausgabetreiber an, die die
Bildschirmauflösung nicht kennen, wie fbdev, x11 und TV-Ausgang.
.
.TP
.B \-stop\-xscreensaver (nur bei X11)
Deaktiviert den Bildschirmschoner beim Start von MPlayer und aktiviert ihn
beim Beenden wieder.
Wenn dein Bildschirmschoner weder XSS- noch XResetScreensaver-API unterstützt,
verwende statt dessen die Option \-hearbeat\-cmd.
.
.TP
.B "\-vm \ \ \ "
Versucht, in einen anderen Videomodus zu wechseln.
Unterstützt von dga-, x11, xv-, sdl- und directx-Videoausgabetreibern.
In Verbindung mit dem directx-Videoausgabetreiber können die Optionen
\-screenw, \-screenh, \-bpp und \-refreshrate benutzt werden, um den neuen
Anzeigemodus zu setzen.
.
.TP
.B "\-vsync \ \ "
Aktiviert VBI für vesa-, dfbmga- und svga-Videoausgabetreiber.
.
.TP
.B \-wid <Fenster-ID> (siehe auch \-gui-wid) (nur bei X11, OpenGL und DirectX)
Weist MPlayer an, sich an ein bestehendes X11-Fenster zu binden, was
beispielsweise nützlich ist, um MPlayer in einen Browser einzubetten (z.B.\&
mit der plugger-Erweiterung).
.
.TP
.B \-xineramascreen <\-2\-...>
Bei Xinerama-Konfigurationen (z.B.\& bei einem einzigen Desktop, der sich
über mehrere Monitore erstreckt) gibt diese Option an, auf welchem Schirm
das Video angezeigt werden soll.
Wert \-2 steht für die Wiedergabe auf dem gesamten virtuellen Display (in
diesem Falle werden Xinerama-Informationen komplett ignoriert), \-1
steht für Vollbildwiedergabe auf dem Display, das das aktuelle Fenster anzeigt.
Die mit der Option \-geometry gesetzte Initialposition ist relativ zum
angegebenen Bildschirm.
Wird normalerweise nur mit "\-fstype \-fullscreen" oder "\-fstype none"
funktionieren.
Diese Option ist nicht geeignet, nur das Startbild zu setzen (denn es wird auf
dem angegebenen Bildschirm immer im Vollbildmodus dargestellt), \-geometry ist
für diesen Zweck momentan die beste
zur Verfügung stehende Option.
Unterstützt von den Videoausgabetreibern gl, gl2, x11 und xv.
.
.TP
.B \-zrbw (nur bei \-vo zr)
Anzeige in schwarz/weiß.
Für optimale Performance kann dies mit der Option '\-lavdopts gray'
kombiniert werden.
.
.TP
.B \-zrcrop <[Breite]x[Höhe]+[x Offset]+[y Offset]> (nur bei \-vo zr)
Wählt den anzuzeigenden Teilausschnitt des Bildes.
Wird diese Option mehrmals angegeben, so aktiviert sie den Cinerama-Modus.
Im Cinerama-Modus wird der Film auf mehr als einen Fernseher (oder Beamer)
verteilt, um insgesamt eine größere Anzeigefläche zu erhalten.
Optionen, die nach dem n-ten \-zrcrop erscheinen, gelten für die
n-te MJPEG-Karte.
Für jede Karte sollte zusätzlich zu \-zrcrop ein \-zrdev angegeben werden.
Beispiele befinden sich in der Zr-Sektion der Dokumentation oder in der
Ausgabe von \-zrhelp.
.
.TP
.B \-zrdev <Gerät> (nur bei \-vo zr)
Gibt die zu deiner MJPEG-Karte gehörende Gerätedatei an.
Standardmäßig verwendet der zr-Videoausgabetreiber das erste v4l-Gerät, das
er findet.
.
.TP
.B \-zrfd (nur bei \-vo zr)
Erzwungene Dezimierung: Dezimierung, wie mit \-zrhdec und \-zrvdec angegeben.
Wird nur angewandt, wenn der Hardwareskalierer das Bild wieder auf seine
ursprüngliche Größe ausdehnen kann.
Benutze diese Option, um Dezimierung zu erzwingen.
.
.TP
.B \-zrhdec <1|2|4> (nur bei \-vo zr)
Horizontale Dezimierung: Weist den Treiber an, nur jede zweite
oder vierte Zeile/\:Pixel des Bildes an die MJPEG-Karte zu schicken und
den Hardwareskalierer der MJPEG-Karte dazu zu benutzen, das Bild wieder
auf seine Urpsrungsgröße auszudehnen.
.
.TP
.B \-zrhelp (nur bei \-vo zr)
Zeigt eine Liste aller \-zr*\-Optionen, ihre Standardwerte und ein Beispiel
für den Cinerama-Modus an.
.
.TP
.B \-zrnorm <Norm> (nur bei \-vo zr)
Gib die Fernsehnorm PAL oder NTSC an (Standardwert: keine Änderung).
.
.TP
.B \-zrquality <1\-20> (nur bei \-vo zr)
Eine Nummer von 1 (beste) bis 20 (schlechteste), die die
JPEG-Encodierungsqualität angibt.
.
.TP
.B \-zrvdec <1|2|4> (nur bei \-vo zr)
Horizontale Dezimierung: Weist den Treiber an, nur jede zweite
oder vierte Spalte/\:Pixel des Bildes an die MJPEG-Karte zu schicken und
den Hardwareskalierer der MJPEG-Karte dazu zu benutzen, das Bild wieder
auf seine Urpsrungsgröße auszudehnen.
.
.TP
.B \-zrxdoff <x Anzeige-Offset> (nur bei \-vo zr)
Wenn das Bild kleiner als der Fernsehbildschirm ist, gibt diese
Option die Bildposition relativ zur oberen linken Ecke des Fernsehers
an (Standard: zentriert).
.
.TP
.B \-zrydoff <y Anzeige-Offset> (nur bei \-vo zr)
Wenn das Bild kleiner als der Fernsehbildschirm ist, gibt diese
Option die Bildposition relativ zur oberen linken Ecke des Fernsehers
an (Standard: zentriert).
.
.
.
.SH "VIDEOAUSGABETREIBER (NUR BEI MPLAYER)"
Videoausgabetreiber sind Schnittstellen zu verschiedenen
Videoausgabe-Einrichtungen.
Die Syntax ist folgende:
.
.TP
.B \-vo <Treiber1[:Suboption1[=Wert]:...],Treiber2,...[,]>
Gibt eine Prioritätenliste der zu verwendenden Videoausgabetreiber an.
.PP
Wenn die Liste mit ',' endet, so werden notfalls auch nicht in der
Kommandozeile aufgeführte Treiber benutzt.
Suboptionen sind optional und können hauptsächlich weggelassen werden.
.br
.I ANMERKUNG:
Eine Liste der eincompilierten Videotreiber erhältst du mit \-vo help.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-vo xmga,xv,"
Versuche zuerst den Matrox-X11-Treiber, dann den Xv-Treiber, dann andere.
.IPs "\-vo directx:noaccel"
Benutzt den DirectX-Treiber mit abgeschalteten Beschleunigungs-Features.
.RE
.PD 1
.sp 1
Folgende Videoausgabetreiber sind verfügbar:
.
.TP
.B xv (nur bei X11)
Benutzt die XVideo-Erweiterung von XFee86 4.x, um hardwarebeschleunigtes
Abspielen zu ermöglichen.
Wenn du keinen hardwarespezifischen Treiber wählen kannst, ist dies für dich
vermutlich die beste Wahl.
Für Informationen darüber, welcher Farbschlüssel benutzt wird und wie er
dargestellt wird, starte MPlayer mit der Option \-v und suche in der Ausgabe
Zeilen, die am Anfang mit [xv common] gekennzeichnet sind.
.PD 0
.RSs
.IPs adaptor=<Nummer>
Wähle einen bestimmten XVideo-Adapter (siehe xvinfo-Ergebnisse).
.IPs port=<Nummer>
Wähle einen bestimmten XVideo-Port.
.IPs ck=<cur|use|set>
Wählt die Quelle, von der der Farbschlüssel genommen wird (Standard: cur).
.RSss
.IPs cur
Benutzt den aktuell in Xv gesetzten Farbschlüssel.
.IPs use
Benutze, setze aber nicht den Farbschlüssel von MPlayer (benutze die Option
\-colorkey, um dies zu ändern).
.IPs set
Das gleiche wie bei der Option use, setzt jedoch auch den gelieferten
Farbschlüssel.
.RE
.IPs ck-method=<man|bg|auto>
Setzt die Zeichenmethode für den Farbschlüssel (Standard: man).
.RSss
.IPs man
Zeichne den Farbschlüssel manuell (reduziert in manchen Fällen Flimmern).
.IPs bg
Setze den Farbschlüssel als Fensterhintergrund.
.IPs auto
Lässt Xv den Farbschlüssel zeichnen.
.RE
.RE
.PD 1
.
.TP
.B x11 (nur bei X11)
Ein Videoausgabetreiber mit Shared Memory ohne Hardwarebeschleunigung, der
immer funktioniert, wenn X11 läuft.
.
.TP
.B xover (nur bei X11)
Ergänzt alle Overlay-basierten Treiber um X11-Unterstützung.
Momentan nur von tdfx_vid unterstützt.
.PD 0
.RSs
.IPs <vo_Treiber>
Wähle den Treiber, der als Quelle für das auf X11 aufsetzende Overlay benutzt
werden soll.
.RE
.PD 1
.
.TP
.B xvmc (nur bei X11 mit \-vc ffmpeg12mc)
Ein Videoausgabetreiber, der die XvMC- (X Video Motion Compensation)
Unterstützung von XFree86 4.x benutzt, um das Decodieren von MPEG-1/\:2 und
VCR2 zu beschleunigen.
.PD 0
.RSs
.IPs adaptor=<Nummer>
Wähle einen bestimmten XVideo-Adapter (siehe xvinfo-Ergebnisse).
.IPs port=<Nummer>
Wählt einen speziellen XVideo-Port.
.IPs (no)benchmark
Deaktiviert die Anzeige von Bildern.
Benötigt für einwandfreies Benchmarking von Treibern, die den Bildpuffer nur
bei einem Monitor-Retrace ändern (nVidia).
Voreinstellung ist, die Bildwiedergabe nicht zu deaktivieren (nobenchmark).
.IPs (no)bobdeint
Sehr einfacher Deinterlacer.
Sieht möglicherweise nicht besser als \-vf tfields=1 aus, ist aber
der einzige Deinterlacer, der mit xvmc funktioniert (Standard: nobobdeint).
.IPs (no)queue
Frames werden in einer Queue angeordnet, um der Videohardware weitergehendes
paralleles Arbeiten zu ermöglichen.
Dies kann eine geringe konstante (nicht bemerkbare) A/V-Desynchronisation mit
sich bringen (Standard: noqueue).
.IPs (no)sleep
Benutze die Sleep-Funktion, während auf Beendigung des Renderns gewartet
wird (nicht empfohlen unter Linux) (Standard: nosleep).
.IPs ck=cur|use|set
Das gleiche wie \-vo xv:ck (siehe \-vo xv).
.IPs ck-method=man|bg|auto
Das gleiche wie die \-vo xv:ck-Methode (siehe \-vo xv).
.RE
.PD 1
.
.TP
.B dga (nur bei X11)
Gib das Video über die Direct Graphics Access-Erweiterung von XFree86 aus.
Wird als veraltet betrachtet.
.
.TP
.B sdl (nur bei SDL, fehlerhaft/veraltet)
Höchst-plattformunabhängiger Videoausgabetreiber der SDL-Bibliothek (Simple
Directmedia Layer).
Da SDL einen eigenen X11-Layer benutzt, haben die X11-Optionen von MPlayer
keine Wirkung auf SDL.
Beachte, dass es mehrere kleine Bugs gibt (\-vm/\-novm wird größtenteils
ignoriert, \-fs verhält sich so wie \-novm es sollte, das Fenster ist
in der oberen linken Ecke, wenn man aus dem Vollbildmodus
zurückkehrt, Panscan wird nicht unterstützt...)
.PD 0
.RSs
.IPs driver=<Treiber>
Wähle den zu benutzenden SDL-Treiber explizit.
.IPs (no)forcexv
Erzwingt die Benutzung von XVideo über den SDL-Videoausgabetreiber (Standard:
forcexv).
.IPs (no)hwaccel
Benutze den hardwarebeschleunigten Skalierer (Standard: hwaccel).
.RE
.PD 1
.
.TP
.B "vidix\ \ "
VIDIX (VIDeo Interface für *niX) ist eine Schnittstelle zu den
Videobeschleunigungsfunktionen verschiedener Grafikkarten.
Sehr schneller Videoausgabetreiber bei Karten, die dies unterstützen.
.PD 0
.RSs
.IPs <Subdevice>
Wähle explizit einen VIDIX-Subdevice-Treiber, der benutzt werden soll.
Verfügbare Subdevice-Treiber sind cyberblade, ivtv, mach64,
mga_crtc2, mga, nvidia, pm2, pm3, radeon, rage128, s3, sh_veu,
sis_vid und unichrome.
.RE
.PD 1
.
.TP
.B xvidix (nur bei X11)
X11-Frontend für VIDIX
.PD 0
.RSs
.IPs <Subdevice>
das gleich wie bei vidix
.RE
.PD 1
.
.TP
.B "cvidix\ "
Generisches, plattformunabhängiges VIDIX-Frontend, das mit nVidia-Karten sogar
in der Konsole läuft.
.PD 0
.RSs
.IPs <Subdevice>
das gleich wie bei vidix
.RE
.PD 1
.
.TP
.B winvidix (nur bei Windows)
Windows-Frontend für VIDIX
.PD 0
.RSs
.IPs <Subdevice>
das gleich wie bei vidix
.RE
.PD 1
.
.TP
.B direct3d (nur bei Windows) (BETA-Code!)
Videoausgabetreiber, der das Direct3D-Interface verwendet (nützlich für Vista).
.
.TP
.B directx (nur bei Windows)
Videoausgabetreiber, der die DirectX-Schnittstelle benutzt.
.PD 0
.RSs
.IPs noaccel
Schaltet Hardwarebeschleunigung ab.
Probiere diese Option bei Problemen mit der Darstellung.
.RE
.PD 1
.
.TP
.B quartz (nur bei Mac OS X)
Mac OS X Quartz-Videoausgabetreiber.
Unter manchen Umständen mag es effizienter sein, ein komprimiertes
YUV-Ausgabeformat zu erzwingen, z.B.\& mit \-vf format=yuy2.
.PD 0
.RSs
.IPs device_id=<Nummer>
Wähle ein Gerät für die Darstellung im Vollbildmodus.
.IPs fs_res=<Breite>:<Höhe>
Gib die Auflösung im Vollbildmodus an (nützlich auf langsamen Systemen).
.RE
.PD 1
.
.TP
.B corevideo (Mac OS X 10.4 oder 10.3.9 mit QuickTime 7)
Mac OS X CoreVideo-Videoausgabetreiber
.PD 0
.RSs
.IPs device_id=<Nummer>
Wähle das Anzeigegerät für die Vollbildwiedergabe.
.RE
.PD 1
.
.TP
.B fbdev (nur bei Linux)
Benutze für die Videoausgabe den Kernel-Framebuffer.
.PD 0
.RSs
.IPs <Gerät>
Wähle explizit das zu benutzende fbdev-Gerät (z.B.\& /dev/\:fb0) oder das
VIDIX-Subdevice, falls der Gerätename mit 'vidix' beginnt
(z.B.\& 'vidixsis_vid' beim SIS-Treiber).
.RE
.PD 1
.
.TP
.B fbdev2 (nur bei Linux)
Benutze für die Videoausgabe den Kernel-Framebuffer, alternative
Implementation.
.PD 0
.RSs
.IPs <Gerät>
Wähle das zu benutzende fbdev-Gerät explizit. (Standard: /dev/\:fb0).
.RE
.PD 1
.
.TP
.B "vesa\ \ \ "
Sehr genereller Videoausgabetreiber, der mit jeder VESA VBE 2.0-kompatiblen
Karte funktionieren sollte.
.PD 0
.RSs
.IPs (no)dga
Schaltet den DGA-Modus ein oder aus (Standard: ein).
.IPs neotv_pal
Aktiviere die TV-Ausgabe von NeoMagic und setze die Norm auf PAL.
.IPs neotv_ntsc
Aktiviere die TV-Ausgabe von NeoMagic und setze die Norm auf NTSC.
.IPs vidix
Benutze den VIDIX-Treiber.
.IPs "lvo:\ \ \ "
Aktiviere das auf dem VESA-Modus aufsetzende Linux-Video-Overlay.
.RE
.PD 1
.
.TP
.B "svga\ \ \ "
Gib das Video über die SVGA-Bibliothek aus.
.PD 0
.RSs
.IPs "<Videomodus>"
Gib den zu benutzenden Videomodus an.
Der Modus kann angegeben werden im Format <Breite>x<Höhe>x<Farben>, z.B.\&
640x480x16M, oder per Grafikmodusnummer, z.B.\& 84.
.IPs bbosd
Zeigt das OSD in den schwarzen Rändern des Films an (langsamer).
.IPs native
Benutze nur native Darstellungsfunktionen.
Dies verhindert direktes Rendern, OSD und Hardwarebeschleunigung.
.IPs retrace
Erzwingt Frame-Wechsel bei vertikalem Retrace.
Nur benutzbar mit \-double.
Dies hat denselben Effekt wie die Option \-vsync.
.IPs "sq\ \ \ "
Versucht, einen Videomodus mit quadratischen Pixeln zu wählen.
.IPs vidix
Benutze svga mit VIDIX.
.RE
.PD 1
.
.TP
.B "gl\ \ \ \ \ "
OpenGL-Videoausgabetreiber, einfache Version.
Die Videogröße muss kleiner
sein als die maximale Texturgröße deiner OpenGL-Implementierung.
Es ist beabsichtigt, auch mit den einfachsten OpenGL-Implementierungen zu
funktionieren, benutzt aber auch neuere Erweiterungen, die mehr Farbräume
und direct rendering ermöglichen.
Probiere für optimale Geschwindigkeit etwas ähnliches wie
.br
\-vo gl:yuv=2:rectangle=2:force\-pbo:ati\-hack \-dr \-noslices
.br
Dieser Code macht nur sehr wenige Fehlerüberprüfungen, falls also ein Feature
nicht funktioniert liegt das vieleicht an fehlender Unterstützung durch deine
Grafiktreiber/OpenGL-Implementierung, auch wenn du keine Fehlermeldung
bekommst.
Benutze glxinfo oder ein ähnliches Tool um dir die unterstützten
OpenGL-Erweiterungen anzeigen zu lassen.
.PD 0
.RSs
.IPs (no)ati\-hack
ATI\-Treiber können ein korruptes Bild liefern, wenn PBOs verwendet werden
(wenn \-dr oder force\-pbo verwendet wird).
Diese Option behebt diesen Fehler auf Kosten von etwas mehr Speicher.
.IPs (no)force\-pbo
Verwende immer PBOs, um Texturen zu transferieren, selbst wenn dies eine extra
Kopie involviert.
Momentan bewirkt dies einen geringen Geschwindigkeitsvorteil mit
NVidia\-Treibern und einen großen mit ATI\-Treibern.
Benötigt möglicherweise \-noslices und die Suboption ati\-hack, um richtig zu
funktionieren.
.IPs (no)scaled-osd
Ändert das Verhalten des OSD bei Änderung der Fenstergröße (Standard:
deaktiviert).
Falls aktiviert ist das Verhalten den anderen Videoausgabetreibern ähnlicher,
was bei Schriftarten mit fester Größe besser ist.
Deaktiviert sieht es mit FreeType-Schriftarten besser aus und benutzt im
Vollbildmodus die Ränder.
Funktioniert momentan nicht mit ass-Untertiteln (siehe \-ass), du kannst sie
statt dessen jedoch ohne OpenGL-Unterstützung mit \-vf ass darstellen lassen.
.IPs osdcolor=<0xAARRGGBB>
Farbe für das OSD (Standard: 0x00ffffff, entspricht nicht-transparentem weiß).
.IPs rectangle=<0,1,2>
Wähle einen bestimmten Typ für rechtwinklige Texturen aus.
Dies spart Grafikspeicher, ist aber oft langsamer (Standard: 0).
.RSss
0: Benutze Texturen mit einer Größe, die eine Potenz von 2 ist (Standard).
.br
1: Benutze die GL_ARB_texture_rectangle-Erweiterung.
.br
2: Benutze die GL_ARB_texture_non_power_of_two-Erweiterung.
Dies wird manchmal nur durch Software emuliert und ist dann sehr langsam.
.RE
.IPs swapinterval=<n>
Minimales Intervall zwischen zwei Pufferwechseln, in angezeigten Bildern
(Standard: 1).
1 entspricht dem Einschalten von VSYNC, 0 dem Ausschalten von VSYNC.
Werte unter 0 belassen es bei der systemweiten Voreinstellung.
Dies limitiert die Framerate auf (horizontale Refresh-Rate / n).
Benötigt GLX_SGI_swap_control-Unterstützung, um zu funktionieren.
Bei manchen (den meisten/allen?) Implementierungen funktioniert dies nur im
Vollbildmodus.
.IPs yuv=<n>
Wählt den Typ der Umwandlung von YUV nach RGB aus.
.RSss
0: Benutze Softwareumwandlung (Standard).
Funktioniert mit allen OpenGL-Versionen.
Ermöglicht Helligkeits-, Kontrast- und Sättigungseinstellung.
.br
1: Benutze register combiners.
Dies benutzt eine nVidia-spezifische Erweiterung (GL_NV_register_combiners).
Es werden mindestens drei Textureinheiten benötigt.
Ermöglicht Sättigungs- und Farbwerteinstellung.
Diese Methode ist schnell aber ungenau.
.br
2: Benutze ein Fragmentprogramm.
Benötigt die GL_ARB_fragment_program-Erweiterung und mindestens drei
Textureinheiten.
Ermöglicht Helligkeits-, Kontrast-, Sättigungseinstellung und
Farbwertkorrektur.
.br
3: Benutze ein Fragmentprogramm, das die POW-Instruktion benutzt.
Benötigt die GL_ARB_fragment_program-Erweiterung und mindestens drei
Textureinheiten.
Ermöglicht Helligkeits-, Kontrast-, Sättigungs-,
Farbwert- und Gammaeinstellung.
Gamma kann für Rot, Grün und Blau unterschiedlich gesetzt werden.
Methode 4 ist meist schneller.
.br
4: Benutze ein Fragmentprogramm mit Tabelle.
Benötigt die GL_ARB_fragment_program-Erweiterung und mindestens vier
Textureinheiten.
Ermöglicht Helligkeits-, Kontrast-, Sättigungs-,
Farbwert- und Gammaeinstellung.
Gamma kann für Rot, Grün und Blau unterschiedlich gesetzt werden.
.br
5: Benutze ATI-spezifische Methode (für ältere Karten)
Benutzt eine ATI-spezifische Erweiterung (GL_ATI_fragment_shader \- nicht
GL_ARB_fragment_shader!).
Mindestens drei Textureinheiten werden benötigt.
Ermöglicht Sättigungs- und Farbwerteinstellung.
Diese Methode ist schnell aber ungenau.
.br
6: Benutze eine 3D-Textur für die Konvertierung via Nachschlagetabelle.
Benötigt die GL_ARB_fragment_program-Erweiterung und mindestens vier
Textureinheiten.
Extrem langsam (Softwareemulation) auf manchen (allen?) ATI-Karten, da es eine
Textur mit Randpixeln verwendet.
Stellt Kontrolle über Helligkeit, Kontrast, Sättigung, Farbton und Gamma
bereit.
Gamma kann außerdem unabhängig für rot, grün und blau gesetzt werden.
Die Geschwindigkeit hängt mehr von der Speicherbandbreite der GPU ab als
andere Methoden.
.RE
.IPs ycbcr
Verwende die GL_MESA_ycbcr_texture-Erweiterung, um YUV nach RGB zu konvertieren.
Dies ist in den meisten Fällen vermutlich langsamer als eine Konvertierung zu
RGB in Software.
.IPs lscale=<n>
Wählt die zu benutzende Skalierungsmethode für Luminanzskalierung.
Nur gültig für yuv-Modi 2, 3, 4 und 6.
.RSss
0: Benutze einfache lineare Filterung (Standard).
.br
1: Benutze bikubische B-Spline-Filterung (bessere Qualität).
Benötigt eine zusätzliche Textureinheit.
Ältere Karten werden dies für Chrominanz zumindest im Vollbildmodus nicht
verarbeiten können.
.br
2: Benutze kubische Filterung in horizontaler, lineare Filterung in vertikaler
Richtung.
Funktioniert auf ein paar mehr Karten als Methode 1.
.br
3: Das gleiche wie 1, verwendet aber keine Lookup-Textur.
Ist auf manchen Karten möglicherweise schneller.
.br
4: Verwende experimentelle unscharfe Maskierung mit 3x3-Unterstützung und einer
Standardstärke von 0.5.
5: Verwende experimentelle unscharfe Maskierung mit 5x5-Unterstützung und einer
Standardstärke von 0.5.
.RE
.IPs cscale=<n>
Wählt die zu benutzende Skalierungsmethode für Chrominanzskalierung.
Für Details siehe lscale.
.IPs filter-strength=<Wert>
Setze die Effektstärke für diejenigen lscale/cscale-Filter, die dies
unterstützen.
.IPs customprog=<Dateiname>
Lädt ein eigenes Fragmentprogramm aus <Dateiname>.
Siehe TOOLS/\:edgedetect.fp als Beispiel.
.IPs customtex=<Dateiname>
Lädt eine eigene "gamma ramp"-Textur aus <Dateiname>.
Kann zusammen mit yuv=4 oder mit der customprog-Option benutzt werden.
.IPs (no)customtlin
Wenn aktiviert (Standard), benutze für die customtex-Textur
GL_LINEAR-Interpolation, benutze sonst GL_NEAREST.
.IPs (no)customtrect
Wenn aktiviert, benutze für die customtex-Textur texture_rectangle.
Standardeinstellung ist deaktiviert.
.RE
.sp 1
.RS
Normalerweise gibt es keinen Grund, die folgenden Optionen zu verwenden.
Sie sind hauptsächlich für Testzwecke.
.RE
.sp 1
.RSs
.IPs (no)glfinish
Rufe glFinish() vor dem Wechsel der Puffer auf.
Langsamer, aber sorgt manchmal für korrektere Ausgabe (Standard: aus).
.IPs (no)manyfmts
Schaltet die Unterstütztung für mehr (RGB und BGR) Farbformate.
Benötigt eine OpenGL-Version >= 1.2.
.IPs slice-height=<0\-...>
Anzahl der Linien, die an einem Stück zur Textur kopiert werden (Standard: 0).
0 für ganzes Bild.
.br
.I ANMERKUNG:
Falls der YUV-Farbraum benutzt wird (siehe yuv-Unteroption), gilt folgendes:
.RSss
Wenn der Dekoder in Streifen rendert (siehe \-noslices), dann hat diese
Einstellung keinen Effekt, die Streifengröße des Dekoders wird benutzt.
.br
Wenn der Dekoder nicht in Streifen rendert, dann ist die Standardeinstellung
16.
.RE
.IPs (no)osd
(De)aktiviere die Unterstützung für das Rendern des OSD via OpenGL (Standard:
aktiviert).
Hauptsächlich für Testzwecke, Du solltest \-osdlevel 0 benutzen, um OSD zu
deaktivieren.
.IPs (no)aspect
(De)aktiviert die Skalierung des Aspekts und die Unterstützung für Panscan
(Standard: aktiviert).
Deaktivierung kann die Geschwindigkeit möglicherweise erhöhen.
.REss
.RE
.PD 1
.
.TP
.B "gl2\ \ \ \ "
Variante des OpenGL\-Videoausgabetreibers.
Unterstützt Videos, die größer als die maximale Texturgröße sind, aber es
fehlen viele der erweiterten Features und Optimierungen des gl\-Treibers, und
es ist unwahrscheinlich, dass dieser Treiber erweitert wird.
.PD 0
.RSs
.IPs (no)glfinish
das gleiche wie bei gl (Standard: aktiviert)
.IPs yuv=<n>
Wählt den Typ der Umwandlung von YUV nach RGB aus.
Bei anderen Werten als 0 wird das OSD deaktiviert und Helligkeits-, Kontrast-
und Gammaeinstellung ist nur über die globale X-Server-Einstellung möglich.
Davon abgesehen ist die Bedeutung dieselbe wie bei \-vo gl.
.REss
.
.TP
.B "null\ \ \ "
Produziert keine Videoausgabe.
Nützlich für Benchmarking-Zwecke.
.
.TP
.B "aa\ \ \ \ \ "
ASCII-Art-Videoausgabetreiber, der auf einer Textkonsole funktioniert.
Du bekommst eine Liste mit allen Optionen und ihren Erläuterungen
mit 'mplayer \-vo aa:help'.
.br
.I ANMERKUNG:
Dieser Treiber kann nicht richtig mit \-aspect umgehen.
.br
.I TIPP:
Wahrscheinlich muß \-monitorpixelaspect spezifiert werden.
Versuche 'mplayer \-vo aa \-monitorpixelaspect 0.5'.
.
.TP
.B "caca\ \ \ "
Farbiger ASCII-Art-Videoausgabetreiber, der auf einer Textkonsole funktioniert.
.
.TP
.B "bl\ \ \ \ \ "
Videowiedergabe, die das Blinkenlights-UDP-Protokoll unterstützt.
Dieser Treiber ist höchstgradig hardwarespezifisch.
.PD 0
.RSs
.IPs <Subdevice>
Wählt den zu benutzenden Subdevice-Treiber von Blinkenlights explizit.
Die Angabe ist der Art arcade:host=localhost:2323 oder
hdl:file=Name1,file=Name2.
Du musst ein Subdevice angeben.
.RE
.PD 1
.
.TP
.B "ggi\ \ \ \ "
Videoausgabetreiber des GGI-Grafiksystems.
.PD 0
.RSs
.IPs <Treiber>
Wählt den zu benutzenden GGI-Treiber explizit.
Ersetze jedes ',' das in der Treiberzeichenkette vorkommt durch ein '.'.
.RE
.PD 1
.
.TP
.B directfb
Videowiedergabe über die DirectFB-Bibliothek.
.PD 0
.RSs
.IPs (no)input
Benutze DirectFB anstelle des MPlayer-Tastaturcodes (Standard: aktiviert).
.IPs buffermode=single|double|triple
Doppeltes (double) und dreifaches (triple) Buffering liefern die besten
Resultate, wenn du Abreißprobleme vermeiden möchstest.
Triplebuffering ist effizienter als Doublebuffering, da es MPlayer
während des Wartens auf das vertikale Retrace nicht blockiert.
Einfaches Buffern sollte vermieden werden (Standard: single).
.IPs fieldparity=top|bottom
Kontrolliert die Ausgabereihenfolge für interlaced-Bilder (Standard:
deaktiviert).
Gültige Werte sind top = obere Felder zuerst, bottom = untere Felder zuerst.
Diese Option hat keinerlei Effekt auf progressives Filmmaterial, wie es die
meisten MPEG-Filme sind.
Du musst diese Option aktivieren, wenn es beim Schauen von
interlaced-Filmmaterial zu Abreißeffekten oder unscharfen Bewegungen kommt.
.IPs layer=N
Wird den Layer mit der ID N für die Wiedergabe erzwingen (Standard: \-1 \-
auto).
.IPs dfbopts=<Liste>
Gibt eine Parameterliste für DirectFB an.
.RE
.PD 1
.
.TP
.B "dfbmga\ "
Matrox G400/\:G450/\:G550-spezifische Videoausgabetreiber, die die
DirectFB-Bibliothek benutzen, um von speziellen Hardware-Feeatures Gebrauch zu
machen.
Ermöglicht CRTC2 (zweiten Bildschirm) und stellt Videos unabhängig vom ersten
Bildschirm dar.
.PD 0
.RSs
.IPs (no)input
das gleiche wie bei directfb (Standard: deaktiviert)
.IPs buffermode=single|double|triple
das gleiche wie bei  (Standard: triple)
.IPs fieldparity=top|bottom
das gleiche wie bei  directfb
.IPs (no)bes
Ermöglicht die Nutzung von Matrox BES (Backend-Skalierer) (Standard:
deaktiviert).
Gibt hinsichtlich Geschwindigkeit und Ausgabequalität sehr gute Resultate, da
interpolierte Bildverarbeitung in der Hardware geschieht.
Funktioniert nur auf dem ersten Bildschirm.
.IPs (no)spic
Nutzt den Matrox-Sub-Picture-Layer für die Anzeige des OSD (Standard:
aktiviert).
.IPs (no)crtc2
Schaltet TV-Out des zweiten Monitors an (Standard: aktiviert).
An der Wiedergabequalität ist erstaunlich, da ein komplettes Interlaced-Bild
mit exakter Synchronisation auf jedem (un)geraden Feld dargestellt wird.
.IPs tvnorm=pal|ntsc|auto
Setzt die TV-Norm der Matrox-Karte, ohne /etc/\:directfbrc ändern zu
müssen (Standard: deaktiviert).
Gültige Normen sind pal = PAL, ntsc = NTSC.
Eine spezielle Norm ist auto (automatisches Anpassen zu PAL/\:NTSC), denn
die Norm wird bestimmt, indem die Framerate des Films betrachtet wird.
.RE
.PD 1
.
.TP
.B mga (nur bei Linux)
Matrox-spezifischer Videoausgabetreiber, der den YUV-Backend-Skalierer von
Gxxx-Karten durch ein Kernelmodul benutzt.
Wenn du eine Matroxkarte hast, ist dies die schnellste Option.
.PD 0
.RSs
.IPs <Gerät>
Wählt das zu benutzende Matrox-Gerät explizit (Standard: /dev/\:mga_vid).
.RE
.PD 1
.
.TP
.B xmga (nur bei Linux, X11)
Der mga-Videoausgabetreiber, läuft in einem X11-Fenster.
.PD 0
.RSs
.IPs <Gerät>
Wählt das zu benutzende Matrox-Gerät explizit (Standard: /dev/\:mga_vid).
.RE
.PD 1
.
.TP
.B s3fb (nur bei Linux) (siehe auch \-vf yuv2 und \-dr)
S3 Virge-spezifischer Videoausgabetreiber.
Dieser Treiber unterstützt die YUV-Konvertierung und -skalierung der Karte,
doppelte Pufferung und direktes Rendern.
Benutze \-vf yuy2 für hardwarebeschleunigtes YUY2-Rendering, welches bei
dieser Karte wesentlich schneller als YV12 ist.
.PD 0
.RSs
.IPs <Gerät>
Wähle das zu verwendende fbdev-Gerät explizit (Standard: /dev/\:fb0).
.RE
.PD 1
.
.TP
.B wii (nur bei Linux)
Nintendo Wii/GameCube-spezifischer Videoausgabetreiber.
.
.TP
.B 3dfx (nur bei Linux)
3Dfx-spezifischer Videoausgabetreiber, der die 3Dfx-Hardware direkt auf X11
verwendet.
Nur 16 bpp werden unterstützt.
.
.TP
.B tdfxfb (nur bei Linux)
Dieser Treiber setzt den tdfxfb-Framebuffer-Treiber ein, um auf 3dfx-Karten
Filme mit YUV-Beschleunigung abzuspielen.
.PD 0
.RSs
.IPs <Gerät>
Wähle das zu benutzende fbdev-Gerät explizit (Standard: /dev/\:fb0).
.RE
.PD 1
.
.TP
.B tdfx_vid (nur bei Linux)
3Dfx-spezifischer Videoausgabetreiber, der in Verbindung mit dem
tdfx_vid-Kernelmodul funktioniert.
.PD 0
.RSs
.IPs <Gerät>
Wähle das zu benutzende Gerät explizit (Standard:/dev/\:tdfx_vid).
.RE
.PD 1
.
.TP
.B dxr2 (siehe auch \-dxr2) (nur bei DXR2)
DXR2-spezifischer Videoausgabetreiber von Creative.
.PD 0
.RSs
.IPs <vo_Treiber>
Der für das Overlay zu benutzende unterliegende Videoausgabetreiber (x11, xv)
.RE
.PD 1
.
.TP
.B dxr3 (nur bei DXR3)
Sigma Designs em8300 MPEG-Decoder-Chip- (Creative DXR3, Sigma Designs
Hollywood Plus) spezifischer Videoausgabetreiber.
Siehe auch den lavc-Videofilter.
.PD 0
.RSs
.IPs overlay
Aktiviert Overlay anstelle von TV-Ausgabe.
.IPs prebuf
Schaltet Prebuffering ein.
.IPs "sync\ "
Schaltet die neue Sync-Engine ein.
.IPs norm=<Norm>
Gibt die TV-Norm an.
.RSss
0: Ändert die aktuelle Norm nicht (Standard).
.br
1: Automatische Anpassung mit PAL/\:NTSC.
.br
2: Automatische Anpassung mit PAL/\:PAL-60.
.br
3: PAL
.br
4: PAL-60
.br
5: NTSC
.RE
.IPs <0\-3>
Gibt die Gerätenummer an, wenn mehr als eine em8300-Karte vorhanden ist.
.RE
.PD 1
.
.TP
.B ivtv (nur bei IVTV)
Videoausgabetreiber für TV-Out speziell für den Conexant CX23415 (iCompression
iTVC15) oder Conexant CX23416 (iCompression iTVC16) MPEG Decoder-Chip
(Hauppauge WinTV PVR-150/250/350/500).
Siehe auch den Videofilter lavc.
.PD 0
.RSs
.IPs <Gerät>
Wählt den zu verwendenden MPEG-Decoder explizit (Standard: /dev/video16).
.IPs <Ausgabe>
Wählt die für das Videosignal zu verwendende TV-Out-Ausgabe.
.RE
.PD 1
.
.TP
.B v4l2 (benötigt Linux-Kernel 2.6.22+)
Videoausgabetreiber für V4L2-kompatible Karten mit eingebautem
Hardware-MPEG-Decoder.
Siehe auch lavc-Videofilter.
.PD 0
.RSs
.IPs <Gerät>
Wähle den Gerätenamen des zu verwendenden MPEG-Decoders explizit
(Standard: /dev/video16).
.IPs <Ausgabe>
Wähle die für das Videosignal zu verwendende TV-Out-Ausgabe explizit.
.RE
.PD 1
.
.TP
.B mpegpes (nur bei DVB)
Videoausgabetreiber für DVB-Karten, der die Ausgabe in eine MPEG-PES-Datei
schreibt, falls keine DVB-Karte installiert ist.
.PD 0
.RSs
.IPs card=<1\-4>
Gibt die Gerätenummer an, wenn mehr als eine DVB-Ausgabekarte vorhanden ist
(nur bei V3 API, wie bei den Treibern der 1.x.y-Serie).
Wird keine Karte angegeben, sucht MPlayer die erste verfügbare Karte.
.IPs <Dateiname>
Ausgabedateiname (Standard: ./grab.mpg).
.RE
.PD 1
.
.TP
.B zr (siehe auch \-zr* und \-zrhelp)
Videoausgabetreiber für eine Anzahl von MJPEG-Capture/\:Wiedergabe-Karten.
.
.TP
.B zr2 (siehe auch den zrmjpeg-Videofilter)
Videoausgabetreiber für eine Anzahl von MJPEG-Capture/\:Wiedergabe-Karten,
zweite Generation.
.PD 0
.RSs
.IPs dev=<Gerät>
Gibt das zu benutzende Gerät an.
.IPs norm=<PAL|NTSC|SECAM|auto>
Gibt die zu benutzende Videonorm an (Standard: auto).
.IPs (no)prebuf
(De)aktiviert Prebuffering, wird noch nicht unterstützt.
.RE
.PD 1
.
.TP
.B "md5sum\ "
Berechnet MD5-Summen von jedem Frame und schreibt sie in eine Datei.
Unterstützt die Farbräume RGB24 und YV12.
Nützlich für Debugging-Zwecke.
.PD 0
.RSs
.IPs outfile=<Dateiname>
Gibt den Ausgabe-Dateinamen an (Standard: ./md5sums).
.RE
.PD 1
.
.TP
.B yuv4mpeg
Wandelt den Videostream in eine Abfolge von unkomprimierten YUV 4:2:0-Bildern
um und speichert diese in einer Datei im aktuellen Verzeichnis
(Standard: ./stream.yuv).
Das Format ist das gleiche, das von den mjpegtools benutzt wird, daher ist
diese Option nützlich, wenn du das Video mit den mjpegtools bearbeiten
möchtest.
Es unterstützt das YV12-, RGB- (24 bpp) und BGR-Format (24 bpp).
Du kannst dies mit der Option \-fixed\-vo kombinieren, um Dateien mit derselben
Größe (bezogen auf das Format) und gleichem fps-Wert aneinanderzuhängen.
.PD 0
.RSs
.IPs interlaced
Schreibt die Ausgabe-Frames interlaced, obere Felder zuerst.
.IPs interlaced_bf
Schreibt die Ausgabe-Frames interlaced, untere Felder zuerst.
.IPs file=<Dateiname>
Schreibe die Ausgabe nach <Dateiname> anstatt in die Standarddatei stream.yuv.
.REss
.PD 1
.RS
.sp 1
.I ANMERKUNG:
Bei Weglassen dieser Optionen ist die Ausgabe 'progressive' (d.h.\& nicht
interlaced).
.RE
.
.TP
.B "gif89a\ "
Gibt jeden Frame in eine animierte GIF-Datei im aktuellen Verzeichnis aus.
Es unterstützt nur das RGB-Format (24 bpp), und die Ausgabe wird zu 256 Farben
konvertiert.
.PD 0
.RSs
.IPs <fps>
Fließkommawert, der die Framerate angibt (Standard: 5.0).
.IPs <output>
Gibt den Ausgabedateinamen an (Standard: ./out.gif).
.REss
.PD 1
.RS
.sp 1
.I ANMERKUNG:
Du musst die Framerate vor dem Dateinamen angeben, sonst wird die Framerate
Teil des Dateinamens.
.sp 1
.I BEISPIEL:
.RE
.PD 0
.RSs
mplayer video.nut \-vo gif89a:15:output=test.gif
.RE
.PD 1
.
.TP
.B "jpeg\ \ \ "
Gibt jeden Frame in eine JPEG-Datei im aktuellen Verzeichnis aus.
Jede Datei bekommt die Framenummer mit vorangestellt ergänzenden Nullen als
Name.
.PD 0
.RSs
.IPs [no]progressive
Gibt Standard-JPEG oder progressives JPEG an (Standard: noprogressive).
.IPs [no]baseline
Benutze eine/\:keine Baseline (Standard: baseline).
.IPs optimize=<0\-100>
Optimierungswert (Standard: 100)
.IPs smooth=<0\-100>
Glättungsfaktor (Standard: 0)
.IPs quality=<0\-100>
Qualitätsfaktor (Standard: 75)
.IPs outdir=<Verzeichnisname>
Gib das Verzeichnis an, in das die JPEG-Bilder gespeichert werden
(Standard: ./).
.IPs subdirs=<Präfix>
Erstellt nummerierte Unterverzeichnisse mit dem angegebenen Präfix, in
welches die Dateien gespeichert werden anstatt in das aktuelle Verzeichnis.
.IPs "maxfiles=<Wert> (nur mit subdirs)"
Maximale Anzahl an JPEG-Dateien, die pro Unterverzeichnis gespeichert werden.
Muss größer oder gleich 1 sein (Standard: 1000).
.RE
.PD 1
.
.TP
.B "pnm\ \ \ \ "
Gibt jeden Frame in eine PNM-Datei in das aktuelle Verzeichnis aus.
Jede Datei bekommt die Frame-Nummer mit vorangestellt ergänzenden Nullen als
Name.
Unterstützt PPM-, PGM- und PGMYUV-Dateien sowohl im raw- als auch im
ASCII-Modus.
Siehe auch pnm(5), ppm(5) und pgm(5).
.PD 0
.RSs
.IPs "ppm\ \ "
Schreibe PPM-Dateien (Standard).
.IPs "pgm\ \ "
Schreibe PGM-Dateien.
.IPs pgmyuv
Schreibe PGMYUV-Dateien.
PGMYUV ist wie PGM, enthält jedoch zusätzlich eine U- und V-Ebene, die am Bild
unten angehängt werden.
.IPs "raw\ \ "
Schreibe PNM-Dateien im raw-Modus (Standard).
.IPs ascii
Schreibe PNM-Dateien im ASCII-Modus.
.IPs outdir=<Verzeichnisname>
Gib das Verzeichnis an, in das die PNM-Dateien gespeichert werden
(Standard: ./).
.IPs subdirs=<Präfix>
Erstellt nummerierte Unterverzeichnisse mit dem angegebenen Präfix, in
welches die Dateien gespeichert werden anstatt in das aktuelle Verzeichnis.
.IPs "maxfiles=<Wert> (nur mit subdirs)"
Maximale Anzahl an JPEG-Dateien, die pro Unterverzeichnis gespeichert werden.
Muss größer oder gleich 1 sein (Standard: 1000).
.RE
.PD 1
.
.TP
.B "png\ \ \ \ "
Gibt jeden Frame in eine PNG-Datei im aktuellen Verzeichnis aus.
Jede Datei bekommt die Frame-Nummer mit vorangestellt ergänzenden Nullen als
Name.
Unterstützt die RGB- und BGR-Formate mit 24 bpp.
.PD 0
.RSs
.IPs z=<0\-9>
Gibt die Kompressionsstufe an.
0 steht für keine, 9 für maximale Kompression.
.IPs outdir=<Verzeichnisname>
Gib das Verzeichnis an, in das die PNG-Dateien gespeichert werden sollen
(Standard: ./).
.IPs alpha (Standard: noalpha)
Erstelle PNG-Dateien mit Alpha-Kanal.
Beachte, dass MPlayer Alpha-Kanäle im allgemeinen nicht unterstützt, so dass
dies nur in manchen Fällen sinnvoll ist.
.RE
.PD 1
.
.TP
.B "mng\ \ \ \ "
Gibt das Video in eine animierte MNG-Datei mit 24 bpp RGB Bildern
in verlustfreier Kompression aus.
.PD 0
.RSs
.IPs output=<Dateiname>
Gibt den Ausgabedateinamen an (Standard: out.mng).
.REss
.PD 1
.RS
.sp 1
.I BEISPIEL:
.RE
.PD 0
.RSs
mplayer video.mkv \-vo mng:output=test.mng
.RE
.PD 1
.
.TP
.B "tga\ \ \ \ "
Gibt jeden Frame in eine TGA-Datei im aktuellen Verzeichnis aus.
Jede Datei bekommt die Frame-Nummer mit vorangestellt ergänzenden Nullen als
Name.
Der Zweck dieses Videoausgabetreibers ist das Schreiben von verlustfreien
Bildern, die ohne jegliche externe Bibliothek verwendet werden können.
Unterstützt werden BGR[A]-Farbformate mit 15, 24 und 32 bpp.
Ein bestimmtes Format kann erzwungen werden durch Benutzung des
format-Videofilters.
.sp 1
.I BEISPIEL:
.RE
.PD 0
.RSs
mplayer video.nut \-vf format=bgr15 \-vo tga
.RE
.PD 1
.
.
.
.SH "OPTIONEN FÜR DIE DECODIERUNG/DAS FILTERN"
.
.TP
.B \-ac <[\-|+]Codec1,[\-|+]Codec2,...[,]>
Gib eine Prioritätsliste der zu verwendenden Audiocodecs an.
Die Codecnamen entsprechen den in codecs.conf definierten Einträgen.
Ein '\-' vor dem Codecnamen deaktiviert diesen Codec.
Ein '+' vor dem Codecnamen erzwingt diesen, dies führt vermutlich zu Abstürzen!
Wenn die Liste mit ',' endet, wird MPlayer auch auf Codecs zurückgreifen, die
nicht in der Liste stehen.
.br
.I ANMERKUNG:
Mit \-ac help erhältst du eine vollständige Liste aller verfügbaren Codecs.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-ac mp3acm"
Erzwingt den l3codeca.acm-MP3-Codec.
.IPs "\-ac mad,"
Probiert zuerst libmad und dann andere Codecs.
.IPs "\-ac hwac3,a52,"
Probiere AC-3-Passthrough, dann
Software-AC-3-Decodierung, danach andere Codecs.
.IPs "\-ac hwdts,"
Probiere Hardware-DTS-Passthrough, danach anderes.
.IPs "\-ac \-ffmp3,"
Überspringe den MP3-Decoder von FFmpeg.
.RE
.PD 1
.
.TP
.B \-af\-adv <force=(0\-7):list=(Filter)> (siehe auch \-af)
Gibt erweiterte Audiofilteroptionen an:
.RSs
.IPs force=<0\-7>
Erzwingt das Einfügen von Audiofiltern nach folgenden Regeln:
.RSss
0: Benutze komplett automatisches Einfügen (Standard)
.br
1: Optimiere auf Genauigkeit.
.br
2: Optimiere auf Geschwindigkeit.
.I Warnung:
Manche Features der Audiofilter können ohne Meldung zu geben versagen, wodurch
sich die Audioqualität verringern kann.
.br
3: Benutze kein automatisches Einfügen von Filtern und keine Optimierung.
.I Warnung:
Diese Einstellung kann MPlayer zum Absturz bringen.
.br
4: Benutze automatisches Einfügen von Filtern gemäß Option 0 oben, benutze
aber Verarbeitung von Fließkommawerten, falls möglich.
.br
5: Benutze automatisches Einfügen von Filtern gemäß Option 1 oben, benutze
aber Verarbeitung von Fließkommawerten, falls möglich.
.br
6: Benutze automatisches Einfügen von Filtern gemäß Option 2 oben, benutze
aber Verarbeitung von Fließkommawerten, falls möglich.
.br
7: Benutze kein automatisches Einfügen von Filtern gemäß Option 3 oben, benutze
aber Verarbeitung von Fließkommawerten, falls möglich.
.REss
.IPs list=<Filter>
Das gleiche wie \-af.
.RE
.
.TP
.B \-afm <Treiber1,Treiber2,...>
Gibt eine Prioritätsliste der zu verwendenden Audiocodecfamilien an,
so wie sie in codecs.conf definiert wurden.
Wenn keine der angegebenen
Familien benutzt werden kann, so werden die Standardcodecs verwendet.
.br
.I ANMERKUNG:
.br
Mit \-afm help erhältst du eine Liste aller verfügbaren Codecfamilien.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-afm ffmpeg"
Probiert zuerst die Codecs von FFmpegs libavcodec.
.IPs "\-afm acm,dshow"
Probiert zuerst die Win32-Codecs.
.RE
.PD 1
.
.TP
.B \-aspect <Verhältnis> (siehe auch \-zoom)
Überschreibt das Höhen-/\:Breitenverhältnis des Films in dem Falle, dass die in
der wiedergegebenen Datei gespeicherten Informationen fehlerhaft sind oder ganz
fehlen.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-aspect 4:3  oder \-aspect 1.3333
.br
\-aspect 16:9 oder \-aspect 1.7777
.RE
.PD 1
.
.TP
.B \-noaspect
Deaktiviert die automatische Anpassung des Höhen-/\:Breitenverhältnisses.
.
.TP
.B "\-field\-dominance <\-1\-1>"
Stellt das erste Feld ein bei interlaced Inhalten.
Nützlich für Deinterlacer, die die Framerate verdoppeln: \-vf tfields=1,
\-vf yadif=1 und \-vo xvmc:bobdeint.
.PD 0
.RSs
.IPs \-1
auto (default): Fällt auf 0 (oberes Feld zuerst) zurück,
wenn der Decoder keine angemessenen Informationen ausgibt.
.IPs 0
oberes Feld zuerst
.IPs 1
unteres Feld zuerst
.RE
.PD 1
.
.TP
.B "\-flip \ "
Stellt das Bild auf den Kopf (horizontales Spiegeln).
.
.TP
.B \-lavdopts <Option1:Option2:...> (DEBUG-CODE)
Gibt Parameter für die Decodierung mit libavcodec an.
Trenne bei mehreren Optionen mit einem Doppelpunkt.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-lavdopts gray:skiploopfilter=all:skipframe=nonref
.RE
.PD 1
.sp 1
.RS
Verfügbare Optionen sind folgende:
.RE
.RSs
.IPs bitexact
Benutze in allen Decodierungsschritten nur bitgenaue Algorithmen (zum
Testen von Codecs).
.IPs bug=<Wert>
Umgehe Fehler (Bugs) des Encoders manuell.
.RSss
0: nichts
.br
1: automatische Erkennung von Fehlern (Standard)
.br
2 (msmpeg4v3): manche ältere, von lavc generierte msmpeg4v3-Dateien (keine
automatische Erkennung)
.br
4 (mpeg4): Xvid-Interlacing-Bug (automatisch erkannt bei fourcc==XVIX)
.br
8 (mpeg4): UMP4 (automatisch erkannt bei fourcc==UMP4)
.br
16 (mpeg4): Padding-Bug (automatisch erkannt)
.br
32 (mpeg4): ungültiger vlc-Bug (automatisch erkannt durch fourcc)
.br
64 (mpeg4): qpel-Bug bei Xvid und DivX (automatisch erkannt durch
fourcc/\:Version)
.br
128 (mpeg4): alter qpel-Standard-Bug (automatisch erkannt durch
fourcc/\:Version)
.br
256 (mpeg4): noch ein anderer qpel-Bug (automatisch erkannt durch
fourcc/\:Version)
.br
512 (mpeg4): Bug bei direkter qpel-Blockgröße (automatisch erkannt durch
fourcc/\:Version)
.br
1024 (mpeg4): Randfüllungs-Bug (edge padding, automatisch erkannt durch
fourcc/\:Version)
.REss
.IPs debug=<Wert>
Zeige Debugging-Informationen an.
.RSss
.br
0: deaktiviert
.br
1: Bildinformationen
.br
2: Ratenkontrolle (Rate Control)
.br
4: Bitstream
.br
8: Makroblock-Typ (MB type)
.br
16: Quantisierungsparameter (QP)
.br
32: Motion-Vector (MV)
.br
0x0040: Motion-Vector-Visualisierung (benutze \-noslices)
.br
0x0080: Überspringen des Makroblocks (MB)
.br
0x0100: Startcode
.br
0x0200: PTS
.br
0x0400: Fehler-Belastbarkeit
.br
0x0800: Speichermanagement-Kontrolloperationen (H.264)
.br
0x1000: Fehler/\:Bugs
.br
0x2000: Visualisiere Quantisierungsparameter (QP), niedrigere QP sind grüner.
.br
0x4000: Visualisiere Blocktypen.
.REss
.IPs ec=<Wert>
Setze zu verwendende Strategie zum Verbergen von Fehlern.
.RSss
1: Benutze einen starken Deblock-Filter bei beschädigten Makroblöcken (MBs).
.br
2: iterative Motion-Vector-Suche (langsam)
.br
3: alles (Standard)
.REss
.IPs er=<Wert>
Setze Strategie zur Fehlerbehandlung.
.RSss
.br
0: deaktiviert
.br
1: vorsichtig (Sollte mit den meisten fehlerhaften Encodern funktionieren.)
.br
2: normal (Standard) (Funktioniert mit konformen Encodern.)
.br
3: aggressiv (mehr Überprüfungen, die aber selbst bei konformen Daten
Fehler liefern können)
.br
4: sehr agressiv
.REss
.IPs "fast (nur bei MPEG-2, MPEG-4 und H.264)"
Aktiviere Optimierungen, die nicht den Spezifikationen entsprechen und
möglicherweise Probleme verursachen können, wie beispielsweise einfachere
Dequantisierung, einfachere Bewegungskompensierung, angenommene Benutzung
der Standardquantisierungsmatrix und
angenommen, dass YUV als 4:2:0 vorliegt, und das Überspringen von ein paar
Überprüfungen, die sonst
vorgenommen werden, um fehlerhafte Bitstreams zu erkennen.
.IPs "gray\ "
Decodierung nur mit Graustufen (was ein bischen schneller als mit Farbe ist)
.IPs "idct=<0\-99> (siehe \-lavcopts)"
Um die beste Decodierqualität zu erreichen, benutze denselben IDCT-Algorithmus
für Decodierung und Encodierung.
Dies kann allerdings auf Kosten der Genauigkeit gehen.
.IPs lowres=<Nummer>[,<b>]
Decodierung bei niedrigeren Auflösungen.
Dies wird nicht von allen Codecs unterstützt und wird oft in hässlichen
Artefakten resultieren.
Dies ist kein Bug sondern ein Nebeneffekt der Decodierung bei nicht voller
Auflösung.
.RSss
.br
0: deaktiviert
.br
1: 1/\:2 Auflösung
.br
2: 1/\:4 Auflösung
.br
3: 1/\:8 Auflösung
.REss
.RS
Falls <b> angegeben wurde, wird die Decodierung bei niedriger Auflösungen nur
dann benutzt, falls die Breite des Videos größer oder gleich dem Wert <b> ist.
.RE
.B o=<Schlüssel>=<Wert>[,<Schlüssel>=<Wert>[,...]]
Übergib AVOptions an den libavcodec-Decoder.
Beachte, ein Patch, um o= überflüssig zu machen und alle unbekannten Optionen
durch das AVOption-System zu übergeben, ist willkommen.
Eine komplette Liste der AVOptions findest du im FFmpeg-Handbuch.
Beachte, dass manche Optionen mit MEncoder-Optionen in Konflikt stehen können.
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.PD 0
.IPs o=debug=pict
.PD 1
.RE
.IPs "sb=<Nummer> (nur bei MPEG-2)"
Überspringe unten die angegebene Anzahl von Makroblockreihen.
.IPs "st=<Nummer> (nur bei MPEG-2)"
Überspringe oben die angegebene Anzahl von Makroblockreihen.
.IPs "skiploopfilter=<skipvalue> (nur bei H.264)"
Überspringt den Schleifenfilter (Deblocking) während der H.264-Decodierung.
Da das gefilterte Bild als Referenz für darauf aufbauende Bilder benutzt wird,
hat dies im Vergleich zum Weglassen des Deblocking-Filters bei z.B.\& MPEG-2
einen
stärkeren negativen Effekt auf die Qualität.
Aber zumindest bei HDTV mit hoher Bitrate bietet dies einen hohen
Geschwindigkeitsgewinn bei kaum sichtbarem Qualitätsverlust.
.sp 1
<skipvalue> kann einen der folgenden Werte annehmen:
.RSss
.br
none: Niemals überspringen.
.br
default: Unnötige Verarbeitungsschritte überspringen (z.B.\& 0 Byte große
Pakete in AVI).
.br
nonref: Überspringe unreferenzierte Bilder (z.B.\& nicht für die Decodierung
anderer Bilder benötigt, der Fehler kann nicht akkumulieren).
.br
bidir: B-Frames überspringen.
.br
nonkey: Alle Bilder außer Keyframes überspringen.
.br
all: Alle Bilder überspringen.
.REss
.IPs "skipidct=<skipvalue> (nur bei MPEG-1/2)"
Überspringt den IDCT-Schritt.
Verringert die Qualität in fast allen Fällen stark (siehe skiploopfilter
für mögliche Werte).
.IPs skipframe=<skipvalue>
Überspringt die Dekodierung von Bildern komplett.
Hoher Geschwindigkeitsgewinn, aber ruckelige Bewegungen und manchmal
schlimme Artefakte (siehe skiploopfilter für mögliche Werte).
.IPs "threads=<1\-8> (nur bei MPEG-1/2 und H.264)"
Anzahl der für die Decodierung zu benutzenden Threads (Standard: 1).
.IPs vismv=<Wert>
Visualisiere Motion-Vectors.
.RSss
.br
0: deaktiviert
.br
1: Mache von P-Frames vorwärts vorausberechnete Motion-Vectors sichtbar.
.br
2: Mache von B-Frames vorwärts vorausberechnete Motion-Vectors sichtbar.
.br
4: Mache von B-Frames rückwärts vorausberechnete Motion-Vectors sichtbar.
.REss
.IPs vstats
Gebe Statistiken aus und speichere sie in ./vstats_*.log.
.RE
.
.TP
.B \-noslices
Deaktiviert die Anzeige des Videos in 16-Pixel-hohen Streifen und stellt den
kompletten Frame statt dessen in einem einzigen Durchgang dar.
Dies kann die Darstellung schneller oder langsamer machen, abhängig von
Hardware/Cache.
Dies hat nur einen Effekt bei den Codecs libmpeg2 und libavcodec.
.
.TP
.B \-nosound
Spielt keinen Sound ab bzw.\& encodiert keinen Sound.
Nützlich für Benchmarking-Zwecke.
.
.TP
.B \-novideo
Spielt kein Video ab bzw.\& encodiert kein Video.
In vielen Fällen funktioniert dies nicht, benutze stattdessen \-vc null \-vo
null.
.
.TP
.B \-pp <Qualität> (siehe auch \-vf pp)
Setzt das Postprocessing-Level der DLL.
Diese Option kann nicht mehr in Verbindung mit \-vf pp verwendet werden,
sondern nur noch mit Win32-DirectShow-DLLs, die eigene interne
Postprocessing-Routinen mitbringen.
Der gültige Wertebereich für \-pp variiert je nach Codec, ist meistens aber
0\-6, wobei 0=deaktiviert und 6=langsamster/\:bester Modus bedeutet.
.
.TP
.B \-pphelp (siehe auch \-vf pp)
Zeigt eine Zusammenfassung der vorhandenen Postprocessing-Filter und deren
Benutzung.
.
.TP
.B \-ssf <Modus>
Gibt die Parameter für den Softwareskalierer an.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-vf scale \-ssf lgb=3.0
.RE
.PD 1
.PD 0
.RSs
.IPs lgb=<0\-100>
gaußscher Unschärfefilter (beim Helligkeitsanteil)
.IPs cgb=<0\-100>
gaußscher Unschärfefilter (beim Farbanteil)
.IPs ls=<\-100\-100>
Schärfefilter (beim Helligkeitsanteil)
.IPs cs=<\-100\-100>
Schärfefilter (beim Farbanteil)
.IPs chs=<h>
horizontale Verschiebung des Farbanteils
.IPs cvs=<v>
vertikale Verschiebung des Farbanteils
.RE
.PD 1
.
.TP
.B \-stereo <Modus>
Wählt den Typ der MP2/\:MP3-Stereoausgabe.
.PD 0
.RSs
.IPs 0
Stereo
.IPs 1
Linker Kanal
.IPs 2
Rechter Kanal
.RE
.PD 1
.
.TP
.B \-sws <Typ des Softwareskalierers> (siehe auch \-vf scale und \-zoom)
Mit dieser Option wird die Qualität (und damit auch die Geschwindigkeit)
des Softwareskalierers gewählt, der bei \-zoom zum Einsatz kommt.
Dieser wird beispielsweise bei x11 oder anderen Videotreibern benutzt,
die keine Hardwarebeschleunigung bieten.
.sp 1
Mögliche Werte sind:
.sp 1
.PD 0
.RSs
.IPs 0
fast bilinear
.IPs 1
bilinear
.IPs 2
bicubic (gute Qualität) (Standard)
.IPs 3
experimentell
.IPs 4
nearest neighbour (schlechte Qualität)
.IPs 5
area
.IPs 6
luma bicubic / chroma bilinear
.IPs 7
gauss
.IPs 8
sincR
.IPs 9
lanczos
.IPs 10
natural bicubic spline
.RE
.PD 1
.sp 1
.RS
.I ANMERKUNG:
Manche \-sws\-Optionen sind einstellbar.
Die Beschreibung des Videofilters scale enthält weitere Informationen.
.RE
.
.TP
.B \-vc <[\-|+]Codec1,[\-|+]Codec2,...[,]>
Gibt eine Prioritätsliste der zu verwendenden Videocodecs an, entsprechend dem
Codecnamen in codecs.conf.
Ein '\-' vor dem Codecnamen deaktiviert diesen Codec.
Ein '+' vor dem Codecnamen erzwingt diesen, das führt vermutlich zu einem Absturz!
Wenn die Liste mit ',' endet, dann greift MPlayer auch auf auch nicht
aufgeführte Codecs zurück.
.br
.I ANMERKUNG:
Mit \-vc help wird eine vollständige Liste der verfügbaren Codecs ausgegben.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-vc divx"
Erzwingt den Win32/\:VFW DivX-Codec; andere werden nicht ausprobiert.
.IPs "\-vc \-divxds,\-divx,"
Überspringt die Win32-DivX-Codecs.
.IPs "\-vc ffmpeg12,mpeg12,"
Probiert zuerst dem MPEG-1/\:2-Codec von libavcodec, gefolgt von libmpeg2, dann
andere.
.RE
.PD 1
.
.TP
.B \-vfm <Treiber1,Treiber2,...>
Gibt eine Prioritätsliste der zu verwendenden Videocodecfamilien an,
entsprechend den Namen in codecs.conf.
Wenn keine davon funktioniert, werden die Standardfamilien ausprobiert.
.br
.I ANMERKUNG:
Mit \-vfm help wird eine vollständige Liste der verfügbaren
Videocodecfamilien ausgegeben.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-vfm ffmpeg,dshow,vfw"
Probiert zuerst libavcodec, dann DirectShow, dann die VfW-Codecs und
schließlich
andere, falls diese nicht funktioniert haben.
.IPs "\-vfm xanim"
Probiert zuerst die XAnim-Codecs.
.RE
.PD 1
.
.TP
.B \-x <x> (siehe auch \-zoom) (nur bei MPlayer)
Skaliert das Bild auf eine Breite von <x> (falls
Software-/\:Hardwareskalierung verfügbar ist).
Deaktiviert die Berechnung des Höhen-/\:Breitenverhältnisses.
.
.TP
.B \-xvidopts <Option1:Option2:...>
Gibt zusätzliche Parameter für die Decodierung mit Xvid an.
.br
.I ANMERKUNG:
Da libavcodec schneller als Xvid ist, könntest du in Betracht ziehen, den
Nachbearbeitungsfilter (\-vf pp) und Decoder (\-vfm ffmpeg) von libavcodec zu
benutzen.
.sp 1
Xvid's interne Nachbearbeitungsfilter:
.PD 0
.RSs
.IPs "deblock-chroma (siehe auch \-vf pp)"
Chrominanz-Deblock-Filter
.IPs "deblock-luma (siehe auch \-vf pp)"
Luminanz-Deblock-Filter
.IPs "dering-luma (siehe auch \-vf pp)"
Luminanz-Deringing-Filter
.IPs "dering-chroma (siehe auch \-vf pp)"
Chrominanz-Deringing-Filter
.IPs "filmeffect (siehe auch \-vf noise)"
Fügt dem Video künstlich Körnung hinzu.
Kann die wahrgenommene Qualität erhöhen, während die eigentliche Qualität
geringer ist.
.RE
.sp 1
.RS
Methoden für das Rendern:
.RE
.PD 0
.RSs
.IPs "dr2\ \ "
Aktiviert direktes Rendern mit Methode 2.
.IPs nodr2
Deaktiviert direktes Rendern mit Methode 2.
.RE
.PD 1
.
.TP
.B \-xy <Wert> (siehe auch \-zoom)
.PD 0
.RSs
.IPs Wert<=8
Skaliert das Bild um den Faktor <Wert>.
.IPs Wert>8
Setze die Bildbreite auf <Wert> und berechne die Höhe so, dass das
ursprüngliche Höhen-/\:Breitenverhältnis beibehalten wird.
.RE
.PD 1
.
.TP
.B \-y <y> (siehe auch \-zoom) (nur bei MPlayer)
Skaliert das Bild auf eine Höhe von <y> (falls Software-/\:Hardwareskalierung
verfügbar ist).
Deaktiviert die Berechnung des Höhen-/\:Breitenverhältnisses.
.
.TP
.B "\-zoom\ \ "
Lässt Softwareskalierung zu, wo sie verfügbar ist.
Dies erlaubt Skalierung mit Videoausgabetreibern (wie x11, fbdev), die
Hardwareskalierung nicht unterstützen und bei denen MPlayer skalieren aus
Performancegründen standardmäßig deaktiviert.
.
.
.
.SH "AUDIOFILTER"
Audiofilter erlauben dir, den Audiostream und seine Eigenschaften zu verändern.
Die Syntax ist folgende:
.
.TP
.B \-af <Filter1[=Parameter1:Parameter2:...],Filter2,...>
Aktiviert eine Kette von Audiofiltern.
.PP
.I ANMERKUNG:
Für eine vollständige Liste der verfügbaren Audiofilter siehe \-af help.
.PP
Die verfügbaren Filter lauten:
.
.TP
.B resample[=srate[:salopp][:Typ]]
Ändert die Samplerate des Audiostreams.
Kann benutzt werden, wenn du eine Soundkarte mit fester Frequenz hast oder
eine, die maximal 44.1kHz unterstützt.
Dieser Filter wird automatisch eingefügt, wenn nötig.
Unterstützt nur 16-Bit-Integer und -Float im Native-Endian-Format als Input.
.br
.I ANMERKUNG:
In Verbindung mit MEncoder musst du zusätzlich \-srate <srate> angeben.
.PD 0
.RSs
.IPs <srate>
Ausgabe-Samplerate in Hz.
Der gültige Bereich dieses Parameters ist 8000 bis 192000.
Falls die Samplefrequenz von Eingabe und Ausgabe gleich ist oder dieser
Parameter ausgelassen wird, wird der Filter automatisch entfernt.
Eine hohe Samplefrequenz erhöht normalerweise die Audioqualität, vor allem in
Kombination mit anderen Filtern.
.IPs <salopp>
Erlaube (1) oder erlaube nicht (0), dass sich die Ausgabefrequenz leicht von
der von <srate> vorgegebenen Frequenz unterscheidet (Standard: 1).
Kann benutzt werden, wenn der Start der Wiedergabe extrem langsam ist.
.IPs <Typ>
Wählt die zu verwendende Methode für das Resampling.
.RSss
0: lineare Interpolation (schnell, schlechte Qualität, vor allem bei
Erhöhung der Frequenz)
.br
1: mehrphasige Filterbank und Integer-Verarbeitung
.br
2: mehrphasige Filterbank und Fließkommazahl-Verarbeitung (langsam,
beste Qualität)
.REss
.PD 1
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs "mplayer \-af resample=44100:0:0"
würde die Ausgabefrequenz des resample-Filters auf 44100Hz setzen und dabei
exakte Skalierung der Ausgabefrequenz und lineare Interpolation verwenden.
.RE
.PD 1
.
.TP
.B lavcresample[=srate[:Länge[:linear[:Zähler[:Abschluss]]]]]
Ändert die Samplerate des Audiostreams zu einem Integerwert in Hz.
Unterstützt nur das 16-Bit Native-Endian-Format.
.br
.I ANMERKUNG:
In Verbindung mit MEncoder musst du zusätzlich \-srate <srate> angeben.
.PD 0
.RSs
.IPs <srate>
die Samplerate der Ausgabe
.IPs <Länge>
Länge des Filters hinsichtlich der niedrigeren Samplerate (Standard: 16)
.IPs <linear>
Falls 1 werden die Filter zwischen mehrphasigen Einträgen linear interpoliert.
.IPs <Zähler>
log2 der Anzahl der Polyphase-Einträge
(..., 10->1024, 11->2048, 12->4096, ...)
(Standard: 10->1024)
.IPs <Abschluss>
Abschlussfrequenz (0.0\-1.0), Standardwert wird abhängig von der Filterlänge
gesetzt.
.RE
.PD 1
.
.TP
.B lavcac3enc[=tospdif[:Bitrate[:minchn]]]
Encodiere Multichannel-Audio mit libavcodec während der Wiedergabe zu AC-3.
Unterstützt 16-Bit native-endian Eingabeformat, maximal 6 Kanäle.
Die Ausgabe ist big-endian, wenn ein raw-AC-3-Stream ausgegeben wird, und
native-endian, wenn nach S/PDIF ausgegeben wird.
Die Samplerate der Ausgabe dieses Filters ist die der Eingabe.
Wenn die Eingabesamplerate 48kHz, 44.1kHz, oder 32kHz beträgt, verwendet
sie dieser Filter direkt.
Ansonsten wird vorher automatisch ein Resampling-Filter eingefügt, der die
Samplerate der Ein- und Ausgabe auf 48kHz bringt.
Du musst '\-channels N' angeben, damit der Decoder den Ton in n Kanäle
decodiert.
Dann kann der Filter die n-kanalige Eingabe zu AC-3 encodieren.
.br
.PD 0
.RSs
.IPs <tospdif>
Gib raw-AC-3-Stream aus wenn null oder nicht gesetzt, gib sonst für Passthrough
auf S/PDIF aus, wenn <tospdif> auf ungleich null gesetzt ist.
.IPs <Bitrate>
Die Bitrate, mit der der AC-3-Stream encodiert werden soll.
Setze dies auf 384 oder 384000, um 384kbits zu erhalten.
Gültige Werte: 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256,
               320, 384, 448, 512, 576, 640
Die Standardbitrate hängt von der Anzahl der Eingabekanäle ab:
1ch: 96,  2ch: 192,  3ch: 224,  4ch: 384,  5ch: 448,  6ch: 448
.IPs <minchn>
Wenn die Zahl für die Eingabekanäle kleiner als <minchn> ist, wird der Filter
sich selbst entfernen (Standard: 5).
.RE
.PD 1
.
.TP
.B sweep[=Geschwindigkeit]
Erzeugt eine Sinusschwingung.
.PD 0
.RSs
.IPs <0.0\-1.0>
Sinusfunktions-Delta, benutze sehr geringe Werte, um die Schwingung zu hören.
.RE
.PD 1
.
.TP
.B sinesuppress[=Frequenz:Abfall]
Entfernt einen Sinus an der angegebenen Frequenz.
Nützlich, um bei Audiogeräten niedriger Qualität das 50/60Hz-Rauschen
loszuwerden.
Funktioniert wahrscheinlich nur bei Mono-Input.
.PD 0
.RSs
.IPs <Frequenz>
Die Frequenz des Sinus, der entfernt werden soll (in Hz) (Standard: 50)
.IPs <Abfall>
Kontrolliert die Anpassung (ein größerer Wert bewirkt, dass der Filter
Änderungen von Amplitude und Phase schneller adaptiert, ein kleinerer Wert
wird die Adaption langsamer machen (Standard: 0.0001).
Sinnvolle Werte bewegen sich um 0.001.
.RE
.PD 1
.
.TP
.B hrtf[=flag]
Die "head-related transfer function": Konvertiert mehrkanäliges
Audiosignal auf zwei Kanäle für Kopfhörer, behält dabei die Räumlichkeit des
Klangs.
.sp 1
.PD 0
.RS
.IPs "Flag  Bedeutung"
.IPs "m     Matrixdecodierung des hinteren Kanals"
.IPs "s     2-Kanal-Matrixdecodierung"
.IPs "0     keine Matrixdecodierung (Standard)"
.RE
.PD 1
.
.TP
.B equalizer=[g1:g2:g3:...:g10]
Graphischer Equalizier, der im 10-Octaven-Frequenzbereich arbeitet;
implementiert durch einen 10-IIR-Bandfilter.
Das bedeutet, dass er unabhängig davon funktioniert, welcher Art der
wiedergegebene Audiotyp ist.
Die mittleren Frequenzen für die 10 Frequenzbereiche sind:
.sp 1
.PD 0
.RS
.IPs "Nr.  Frequenz"
.IPs "0    31.25 Hz"
.IPs "1    62.50 Hz"
.IPs "2   125.00 Hz"
.IPs "3   250.00 Hz"
.IPs "4   500.00 Hz"
.IPs "5    1.00 kHz"
.IPs "6    2.00 kHz"
.IPs "7    4.00 kHz"
.IPs "8    8.00 kHz"
.IPs "9   16.00 kHz"
.RE
.PD 1
.sp 1
.RS
Falls die Samplerate des wiedergegebenen Klangs niedriger ist als die mittlere
Frequenz für einen Frequenzbereich, wird dieser Bereich deaktiviert.
Ein bekannter Fehler dieses Filters ist, dass die Charakteristiken für den
höchsten Bereich nicht komplett symmetrisch sind, wenn die Samplerate nah an
der mittleren Frequenz dieses Bereichs liegt.
Dieses Problem kann dadurch umgangen werden, dass man mit Hilfe des
Filters resample die Samplerate des Klangs erhöht, bevor er diesen Filter
erreicht.
.RE
.PD 0
.RSs
.IPs <g1>:<g2>:<g3>:...:<g10>
Fließkommawerte, die die Verstärkung in dB für jeden Frequenzbereich
repräsentieren (\-12\-12)
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af equalizer=11:11:10:5:0:\-12:0:5:12:12 media.avi"
Würde den Klang im Bereich der oberen und unteren Frequenzen verstärken und
ihn gleichzeitig im Bereich um 1kHz fast verschwinden lassen.
.RE
.PD 1
.
.TP
.B channels=nch[:nr:from1:to1:from2:to2:from3:to3:...]
Kann benutzt werden, um Audiokanäle hinzuzufügen, zu entfernen, zu kopieren
oder deren Routing zu verändern.
Wenn nur <nch> gegeben ist, wird das Standardrouting benutzt, es funktioniert
folgendermaßen: Falls die Anzahl der Ausgabekanäle größer ist als die Anzahl
der Eingangskanäle, so werden leere Kanäle erzeugt (Ausnahme: Upmix von Mono
auf Stereo, dann wird der Monokanal auf beiden Ausgabekanälen wiederholt).
Ist die Anzahl der Ausgabekanäle kleiner als die Anzahl der Eingangskanäle,
so werden die überschüssigen Kanäle verworfen.
.PD 0
.RSs
.IPs <nch>
Anzahl der Ausgabekanäle (1\-6)
.IPs "<nr>\ "
Anzahl der Leitungen für das Routing (1\-6)
.IPs <von1:bis1:von2:bis2:von3:bis3:...>
Paare von Nummers zwischen 0 und 5, die festlegen, wo das Routing für jeden
Kanal stattfinden soll.
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af channels=4:4:0:1:1:0:2:2:3:3 media.avi"
Würde die Anzahl der Kanäle auf 4 setzen und 4 Routen aufsetzen, die die
Kanäle 0 und 1 vertauschen und die Kanäle 2 und 3 unberührt lassen.
Beachte, dass bei der Wiedergabe eines Mediums mit nur zwei Känalen die Kanäle
2 und 3 still wären, 0 und 1 aber trotzdem vertauscht würden.
.IPs "mplayer \-af channels=6:4:0:0:0:1:0:2:0:3 media.avi"
Würde die Anzahl der Kanäle auf 6 setzen und 4 Routen aufsetzen, die den Kanal
0 nach Kanal 0 und 3 kopieren.
Kanäle 4 und 5 werden keinen Ton enthalten.
.RE
.PD 1
.
.TP
.B format[=Format] (siehe auch \-format)
Konvertiert zwischen verschiedenen Sampleformaten.
Wird automatisch aktiviert, falls die Soundkarte oder ein anderer Filter dies
benötigt.
.PD 0
.RSs
.IPs <Format>
Setzt das gewünschte Format.
Die allgemeine Form is 'sbe', wobei 's' für 'signed' steht (alternativ 'u'
für 'unsigned'), 'b' die Anzahl der Bits pro Sample ist (16, 24 oder 32)
und 'e' die Endianness angibt ('le' heißt little-endian, 'be' big-endian; 'ne'
ist die Endianness des Computers, auf dem MPlayer läuft).
Gültige Werte (unter anderem) sind: 's16le', 'u32be' und 'u24ne'.
Ausnahmen dieser Regel, die auch gültige Formatangaben sind: u8, s8,
floatle, floatbe, floatne, mulaw, alaw, mpeg2, ac3 und imaadpcm.
.RE
.PD 1
.
.TP
.B volume[=v:sc]
Implementiert die Lautstärkeregulierung in Software.
Benutze diesen Filter mit Vorsicht, da er das Verhältnis von Signalstärke zum
Rauschen (signal to noise ratio) reduzieren kann.
In den meisten Fällen ist es am besten, das Level für den PCM-Sound auf
maximal zu stellen, diesen Filter wegzulassen und die Ausgabestärke zu den
Lautsprechern mit der Mixereinstellung Master zu regulieren.
In dem Falle, dass deine Soundkarte einen digitalen anstelle eines analogen
PCM-Mixers hat, benutze stattdessen die MASTER-Mixereinstellung.
Wenn ein externer Verstärker mit dem Computer verbunden ist (das ist fast
immer der Fall), kann das Rauschlevel minimiert werden, indem Master-Level und
der Lautstärkeregler am Verstärker angepasst werden, bis das Rauschen im
Hintergrund verschwunden ist.
.br
Dieser Filter hat ein zweites Feature: Er misst die insgesamt maximale
Lautstärke und gibt diese aus, wenn MPlayer beendet wird.
Diese Lautstärkeabschätzung kann benutzt werden, um die Lautstärke in MEncoder
so zu setzen, dass ein maximaler dynamischer Bereich benutzt wird.
.br
.I ANMERKUNG:
Dieser Filter ist nicht reentrant (ablaufinvariant) und kann dementsprechend
nur einmal pro Audiostream aufgerufen werden.
.PD 0
.RSs
.IPs "<v>\ \ "
Setzt die gewünschte Verstärkung in dB für alle Kanäle in diesem Stream.
Die Verstärkung kann zwischen \-200dB und +60dB liegen, wobei \-200dB den
Sound komplett verstummen lässt und +60dB einer 1000-fachen Verstärkung
entspricht (Standard: 0).
.IPs "<sc>\ "
Schaltet "Soft-Clipping" an (1) oder aus (0).
Soft-Clipping kann den Klang weicher machen, wenn sehr hohe Lautstärken
benutzt werden.
Benutze diese Option, wenn der dynamische Bereich der Lautsprecher sehr
niedrig ist.
.br
.I WARNUNG:
Dieses Feature bewirkt Störgeräusche und sollte als letzte Möglichkeit
angesehen werden.
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af volume=10.1:0 media.avi"
Würde den Klang um 10.1dB verstärken und abschneiden, wenn die Lautstärke zu
hoch ist.
.RE
.PD 1
.
.TP
.B pan=n[:L00:L01:L02:...L10:L11:L12:...Ln0:Ln1:Ln2:...]
Mischt Kanäle beliebig.
Im Prinzip eine Kombination der Filter volume und channels, der benutzt werden
kann, viele Kanäle auf nur wenige herunterzumischen, z.B.\& Stereo nach Mono
oder das Verändern der "Breite" vom mittleren Lautsprecher in einem
Surroundsound-System.
Dieser Filter ist schwierig zu benutzen und wird etwas Herumprobieren
benötigen, bevor die gewünschten Ergebnisse eintreten.
Die Anzahl der Optionen für diesen Filter hängt von der Anzahl der
Ausgabekanäle ab.
Ein Beispiel dazu, wie mit diesem Filter eine 6-Kanal-Datei auf 2 Kanäle
heruntergemischt werden kann, findest du im Abschnitt Beispiele nahe dem Ende
der Manpage.
.PD 0
.RSs
.IPs "<n>\ \ "
Anzahl der Ausgabekanäle (1\-6).
.IPs <Lij>
Gibt an, wieviel vom Eingabekanal i in den Ausgabekanal j gemischt wird (0\-1).
Prinzipiell geben die ersten n Zahlen an, was mit dem ersten Eingabekanal
gemacht wird, dann n Zahlen, die den zweiten Eingabekanal betreffen, usw.
Falls für einige Eingabekanäle nichts angegeben ist, wird 0 angenommen.
.RE
.sp 1
.RS
.I BEISPIELE:
.RE
.RSs
.IPs "mplayer \-af pan=1:0.5:0.5 media.avi"
Würde von stereo nach mono heruntermischen.
.IPs "mplayer \-af pan=3:1:0:0.5:0:1:0.5 media.avi"
Würde 3 Ausgabekanäle liefern, Kanäle 0 und 1 bleiben intakt und der
Ausgabekanal 2 wäre die Mischung aus den Kanälen 0 und 1 (und könnte zum
Beispiel an eine Subwoofer geschickt werden).
.RE
.PD 1
.
.TP
.B sub[=fc:ch]
Fügt dem Audiostream einen Subwoofer-Kanal hinzu.
Die Audiodaten, die für die Erzeugung des Subwoofer-Kanals benutzt werden,
ist ein Durchschnitt des Klanges in Kanal 0 und Kanal 1.
Der resultierende Klang ist dann tiefpassgefiltert von einem
Butterworth-Filter vierten Ranges mit einem voreingestellten Abschnitt der
Frequenzen bei 60Hz und wird in einem separaten Kanal dem Audiostream
hinzugefügt.
.br
.I WARNUNG:
Deaktiviere diesen Filter, wenn du DVDs mit Dolby Digital 5.1-Klang abspielst,
sonst wird dieser Filter den Klang des Subwoofers stören.
.PD 0
.RSs
.IPs "<fc>\ "
Ab dieser Frequenz schneidet der Tiefpassfilter ab (20Hz bis 300Hz)
(Standard: 60Hz).
Versuche für beste Resultate die Frequenz, ab der abgeschnitten
wird, so niedrig wie möglich zu setzten.
Das wird den Stereo- oder Surroundsound-Genuß erhöhen.
.IPs "<ch>\ "
Bestimmt die Kanalnummer, in die der Sub-Kanal eingefügt werden soll.
Die Kanalnummer kann zwischen 0 und 5 liegen (Standard: 5).
Beachte, dass die Anzahl der Kanäle automatisch auf <ch> erhöht wird, sollte
es nötig sein.
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af sub=100:4 \-channels 5 media.avi"
Würde einen Subwoofer-Kanal mit einer Abschlussfrequenz von 100Hz zum
Ausgabekanal 4 hinzufügen.
.RE
.PD 1
.
.TP
.B "center\ "
Erzeugt aus den vorderen Kanälen einen mittleren Kanal.
Kann zur Zeit möglicherweise geringe Qualität liefern, da er keine
Hochpassfilter für eine entsprechende Extraktion besitzt, sondern nur über die
Kanäle mittelt und halbiert.
.PD 0
.RSs
.IPs "<ch>\ "
Legt die Kanalnummer fest, in die der mittlere Kanal eingefügt werden soll.
Die Kanalnummer kann zwischen 0 und 5 liegen (Standard: 5).
Beachte dass die Anzahl der Kanäle automatisch auf <ch> erhöht wird, wenn es
nötig sein sollte.
.RE
.PD 1
.
.TP
.B surround[=Verzögerung]
Decoder für Matrix-encodierten Surroundsound, wie z.B.\& Dolby Surround.
Viele Dateien mit zwei Audiokanälen enthalten tatsächlich matrixencodierten
Surroundsound.
Benötigt eine Soundkarte, die mindestens 4 Kanäle unterstützt.
.PD 0
.RSs
.IPs <Verzögerung>
Verzögerung in ms für die hinteren Lautsprecher (0 bis 1000) (Standard: 20)
Diese Verzögerung sollte wie folgt gesetzt werden: Wenn d1 der Abstand ist,
von dem aus die vorderen Lautsprecher gehört werden, und d2 der Abstand ist,
von dem aus die hinteren Lautsprecher gehört werden, dann sollte die
Verzögerung auf 15ms gesetzt werden, falls d1 <= d2 und auf 15 + 5*(d1-d2),
falls d1 > d2.
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af surround=15 \-channels 4 media.avi"
Würde Decodierung von Surroundsound hinzufügen mit einer Verzögerung von 15ms
für die hinteren Lautsprecher.
.RE
.PD 1
.
.TP
.B delay[=ch1:ch2:...]
Verzögert die Soundausgabe zu den Lautsprechern so, dass der Klang der
verschiedenen Kanäle die Position, an dem sie gehört werden, gleichzeitig
erreicht.
Das macht nur Sinn, wenn du mehr als 2 Lautsprecher hast.
.PD 0
.RSs
.IPs ch1,ch2,...
Die Verzögerung in ms, die jedem Kanal auferlegt wird (Fließkommazahl zwischen
0 und 1000).
.RE
.PD 1
.sp 1
.RS
Um die benötigte Verzögerung für die verschiedenen Kanäle zu berechnen, gehe
wie folgt vor:
.IP 1. 3
Messe die Entfernung zu den Lautsprechern in Metern in Relation zu der
Position,
an der gehört wird, was dir die Entfernungen s1 bis s5 liefert (bei einem
5.1-System).
Für den Subwoofer macht Anpassung keinen Sinn (du wirst den Unterschied eh
nicht hören).
.IP 2. 3
Subtrahiere die Abstände s1 bis s5 von der maximalen Entfernung, z.B.\&
s[i] = max(s) \- s[i]; i = 1...5.
.IP 3.
Berechne die benötigten Verzögerungen in ms als d[i] = 1000*s[i]/342; i =
1...5.
.RE
.PD 0
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af delay=10.5:10.5:0:0:7:0 media.avi"
Würde die vordere Linke und Rechte um 10.5ms verzögern, die beiden hinteren
Kanäle und den Subwoofer um 0ms und Center um 7ms.
.RE
.PD 1
.
.TP
.B export[=mmapped_Datei[:nsamples]]
Exportiert das Eingangssignal an andere Prozesse mittels Memory Mapping
(mmap()).
Memory-mapped-Bereiche enthalten einen Header:
.sp 1
.nf
int nch                     /*Anzahl der Kanäle*/
int size                    /*Größe des Buffers*/
unsigned long long counter  /*Wird benutzt, um Synchronisation zu
                              wahren und aktualisiert, wenn neue
                              Daten exportiert werden.*/
.fi
.sp 1
Der Rest sind (nicht-interleaved) 16-bit-Daten über die Auslastung.
.PD 0
.RSs
.IPs <mmapped_Datei>
Datei, zur der die Daten exportiert werden sollen
(Standard: ~/\:.mplayer/\:mplayer-af_export).
.IPs <nsamples>
Anzahl der Samples pro Kanal (Standard: 512)
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af export=/tmp/mplayer-af_export:1024 media.avi"
Würde 1024 Samples pro Kanal nach '/tmp/mplayer-af_export' exportieren.
.RE
.PD 1
.
.TP
.B extrastereo[=mul]
Erhöht den Unterschied zwischen linken und rechten Kanälen (linear), was der
Wiedergabe eine Art "Live"-Effekt hinzuzufügt.
.PD 0
.RSs
.IPs <mul>
Setzt den Differenz-Koeffizient (Standard: 2.5).
0.0 bedeutet Klang in Mono (Durchschnitt beider Kanäle), bei 1.0 bleibt der
Klang unverändert, mit \-1.0 werden linker und rechter Kanal vertauscht.
.RE
.PD 1
.
.TP
.B volnorm[=Methode:Ziel]
Maximiert die Lautstärke, ohne den Klang zu verzerren.
.PD 0
.RSs
.IPs <Methode>
Setzt die zu benutzende Methode.
.RSss
1: Benutze ein einziges Sample, um die Abweichungen mit Hilfe eines
standardgewichteten Durchschnitts der vorigen Samples zu glätten (Standard).
.br
2: Benutze mehrere Samples, um die Abweichungen mit Hilfe eines
standardgewichteten Durchschnitts der vorigen Samples zu glätten.
.REss
.IPs <Ziel>
Setzt die Zielamplitude als Bruchteil des Maximalwertes der Samplingauflösung
(Standard: 0.25).
.RE
.PD 1
.
.TP
.B ladspa=Datei:Label[:Kontrollen...]
Lade ein LADSPA (Linux Audio Developer's Simple Plugin API) Plugin.
Es können mehrere Filter gleichzeitig verwendet werden.
.PD 0
.RSs
.IPs <Datei>
Gibt eine Bibliotheksdatei des LADSPA-Plugins an.
Falls LADSPA_PATH gesetzt ist, wird nach der angegeben Datei gesucht.
Ist es nicht gesetzt, muss der volle Pfadname angegeben werden.
.IPs <Label>
Gibt den Filter innerhalb der Bibliothek an.
Manche Bibliotheken beinhalten nur einen Filter, andere aber enthalten mehrere.
Angabe von 'help' hier zeigt alle verfügbaren Filter innerhalb der angegebenen
Bibliothek, was die Benutzung von 'listplugins' des LADSPA SDK überflüssig
macht.
.IPs <Kontrollen>
Kontrollen sind null oder mehr Fließkommawerte, die das Verhalten des
geladenen Plugins bestimmen (zum Beispiel Verzögerung, Schwellenwert oder
Verstärkung).
Im ausführlichen Modus (füge \-v zur MPlayer-Kommandozeile hinzu) werden alle
Kontrollen und ihre dazugehörigen Wertebereiche ausgegeben.
Dies macht die Benutzung von 'analyseplugin' des LADSPA SDK überflüssig.
.RE
.PD 1
.
.TP
.B "comp\ \ \ "
Kompressor/Expandier-Filter, der bei Input von einem Mikrophon benutzt werden
kann.
Verhindert Artefakte bei sehr lautem Klang und erhöht die Lautstärke bei sehr
leisem Klang.
Dieser Filter ist nicht getestet und möglicherweise unbrauchbar.
.
.TP
.B "gate\ \ \ "
Ein das Rauschen beschränkender Filter, ähnlich dem Audiofilter comp.
Dieser Filter ist nicht getestet und möglicherweise unbrauchbar.
.
.TP
.B karaoke
Einfacher Filter zur Entfernung von Stimmen, der die Tatsache ausnutzt, dass
diese normalerweise mit einem Monogerät aufgenommen werden und später 'mittig'
in den endgültigen Audiostream gemixt werden.
Sei dir im klaren darüber, dass dieser Filter dein Signal in Mono umwandelt.
Funktioniert gut für Tracks mit zwei Kanälen; mach dir nicht die Mühe, es auf
etwas anderes als 2-Kanal-Stereo anzuwenden.
.TP
.B scaletempo[=Option1:Option2:...]
Skaliert die Audiogeschwindigkeit, ohne die Tonhöhe zu verändern.
Optional wird auf die Wiedergabegeschwindigkeit synchronisiert (Standard).
.br
Dies funktioniert, indem \'stride\' ms Audio bei normaler
Geschwindigkeit dann \'stride*scale\' ms des eingehenden Audios
verbraucht.
Es puzzelt die Stücke wieder zusammen, indem \'overlap\'% der Schrittweite mit
dem Audio des vorigen Schrittes überblendet werden.
Optional wird eine kurze statistische Analyse der nächsten \'search\' ms Audio
durchgeführt, um die beste Überlappungsposition zu bestimmen.
.PD 0
.RSs
.IPs scale=<Wert>
Nomineller Wert, um die die Geschwindigkeit skaliert werden soll.
Skaliert um diese Menge zusätzlich zur Geschwindigkeit.
(Standard: 1.0)
.IPs stride=<Wert>
Länge eines Schrittes in Millisekunden.
Zu hohe Werte verursachen merkliche Sprünge bei hohen Skalierungswerten und
ein Echo bei niedrigen.
Sehr niedrige Werte werden die Tonhöhe verändern.
Erhöhen des Wertes verbessert die Performance.
(Standard: 60)
.IPs overlap=<Prozent>
Prozentsatz, um den sich die Schritte überlappen.
Verringerung erhöht Performance.
(Standard: .20)
.IPs search=<Wert>
Länge in Millisekunden, um die für die beste Überlappungsposition gesucht wird.
Verringerung erhöht Performance sehr.
Auf langsamen Systemen wirst du diesen Wert sehr niedrig setzen wollen.
(Standard: 14)
.IPs speed=<tempo|pitch|both|none>
Bestimme die Antwort auf Geschwindigkeitsveränderungen.
.RSss
.IPs tempo
Skaliert das Tempo synchron zur Geschwindigkeit (Standard).
.IPs pitch
Kehrt die Wirkung des Filters um.
Skaliert Tonhöhe, ohne das Tempo zu verändern.
Füge \'[ speed_mult 0.9438743126816935\' und \'] speed_mult 1.059463094352953\'
deiner input.conf hinzu, um Schrittweite auf Halbtöne zu setzen.
.I WARNUNG:
Verliert Synchronisation mit Video.
.IPs both
Skaliert sowohl Tempo als auch Tonhöhe.
.IPs none
Ignoriere Tempoveränderungen.
.RE
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af scaletempo \-speed 1.2 media.ogg"
Würde die Datei bei 1.2-fachem der normalen Geschwindigkeit wiedergeben, Audio
auf normaler Tonhöhe.
Änderung der Wiedergabegeschwindigkeit würde Anpassung der
Audiogeschwindigkeit veranlassen, so dass diese passt.
.IPs "mplayer \-af scaletempo=scale=1.2:speed=none \-speed 1.2 media.ogg"
Würde die Datei bei 1.2-fachem der normalen Geschwindigkeit wiedergeben, Audio
auf normaler Tonhöhe, aber Änderung der Wiedergabegeschwindigkeit hätte keinen
Effekt auf das Audiotempo.
.IPs "mplayer \-af scaletempo=stride=30:overlap=.50:search=10 media.ogg"
Würde die Qualitäts- und Performanceparameter anpassen.
.IPs "mplayer \-af format=floatne,scaletempo media.ogg"
Würde dafür sorgen, dass scaletempo Code mit Fließkommazahlen verwendet.
Möglicherweise schneller auf manchen Plattformen.
.IPs "mplayer \-af scaletempo=scale=1.2:speed=pitch audio.ogg"
Würde die Datei bei 1.2-fachem der normalen Geschwindigkeit wiedergeben, Audio
auf normaler Tonhöhe.
Änderung der Wiedergabegeschwindigkeit würde die Tonhöhe ändern und Audiotempo
bei 1.2-fachem lassen.
.RE
.PD 1
.
.
.
.
.SH "VIDEOFILTER"
Videofilter erlauben dir, den Videostream und seine Eigenschaften zu ändern.
Die Syntax ist folgende:
.
.TP
.B \-vf <Filter1[=Parameter1:Parameter2:...],Filter2,...>
Aktiviert eine Videofilterkette zusammen mit ihren Optionen.
.PP
Viele Parameter sind optional und werden teilweise mit Standardwerten belegt,
wenn sie weggelassen werden.
Mit '\-1' werden die Standardwerte explizit beibehalten.
Die Parameter w:h bedeuten Breite (width) x Höhe (height); x:y bedeutet
die x:y-Position relativ zur linken oberen Ecke des größeren Bildes.
.br
.I ANMERKUNG:
Eine vollständige Liste aller verfügbaren Plugins liefert \-vf help.
.sp 1
Videofilter werden in Listen verwaltet.
Es gibt ein paar Kommandos, um die Filterliste zu regeln.
.
.TP
.B \-vf\-add <Filter1[,Filter2,...]>
Fügt die angegebenen Filter ans Ende der Filterliste hinzu.
.
.TP
.B \-vf\-pre <Filter1[,Filter2,...]>
Fügt die angegebenen Filter an den Anfang der Filterliste hinzu.
.
.TP
.B \-vf\-del <Index1[,Index2,...]>
Löscht die Filter an der angegebenen Indexposition.
Indexnummern beginnen bei 0, negative Nummern adressieren das Ende der Liste
(\-1 ist der letzte).
.
.TP
.B \-vf\-clr
Leert die Filterliste komplett.
.PP
Bei Filtern, die dies unterstützen, kannst Du auf Parameter über den Namen
zugreifen.
.
.TP
.B \-vf <filter>=help
Gibt die Parameternamen und die gültigen Wertebereiche der Parameter für einen
bestimmen Filter aus.
.
.TP
.B \-vf <Filter=benannter_Parameter1=Wert1[:benannter_Parameter2=Wert2:...]>
Setzt einen benannten Parameter auf den angegebenen Wert.
Benutze 'on' und 'off' oder 'yes' und 'no', um Flag-Parameter zu setzen.
.PP
Die verfügbaren Filter sind folgende:
.
.TP
.B crop[=b:h:x:y]
Schneidet den angegeben Teil des Bildes aus und verwirft den Rest.
Nützlich, um schwarze Balken bei Widescreen-Filmen zu entfernen.
.PD 0
.RSs
.IPs <b>,<h>
Abgeschnittene Breite und Höhe, ist voreingestellt auf die originale Breite
und Höhe.
.IPs <x>,<y>
Position des abgeschnittenen Bildes, ist voreingestellt auf die Mitte.
.RE
.PD 1
.
.TP
.B cropdetect[=Limit:Rundung]
Berechnet die Schneideparameter für den crop-Filter und gibt die empfohlenen
Parameter auf die Standardausgabe aus.
.PD 0
.RSs
.IPs <Limit>
Schwellenwert, der optional angegeben werden kann als nichts (0) bis hin zu
allem
(255) (Standard: 24).
.br
.IPs <Rundung>
Wert, durch den die Breite/\:Höhe teilbar sein sollte (Standard: 16).
Der Offset wird automatisch angepasst, um das Video zu zentrieren.
Benutze 2, um gerade Dimensionen zu bekommen (wird für 4:2:2-Video gebraucht).
16 ist beim Encodieren für die meisten Videocodecs die beste Wahl.
.RE
.PD 1
.
.TP
.B rectangle[=b:h:x:y]
Zeichnet ein Rechteck der geforderten Breite und Höhe an den angegebenen
Koordinaten über das Bild und gibt die aktuellen Rechteckparameter auf die
Konsole aus.
Dies kann verwendet werden, um optimale Parameter für das Beschneiden der
Ränder (cropping) zu finden.
Wenn du die Direktive 'change_rectangle' an einen Tastenanschlag bindest,
kannst du so das Rechteck während der Wiedergabe bewegen und dessen Größe
ändern.
.PD 0
.RSs
.IPs <b>,<h>
Breite und Höhe (Standard: \-1, maximal mögliche Breite, wobei die Begrenzungen
sichtbar bleiben)
.IPs <x>,<y>
Position der linken oberen Ecke (Standard: \-1, ganz oben, ganz links)
.RE
.PD 1
.
.TP
.B expand[=b:h:x:y:o:a:r]
Vergrößert das Bild ohne Skalierung auf die angegebene Größe und
platziert das unskalierte Originalbild an die Koordinaten x/\:y.
Kann benutzt werden, um die Platzierung des OSD/der Untertitel auf
schwarzen Balken zu erreichen.
.RSs
.IPs <b>,<h>
Expandierte Breite,Höhe (Standard: originale Breite,Höhe).
Negative Werte für b und h werden als Offsets zur Originalgröße behandelt.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IP expand=0:\-50:0:0
Fügt unterhalb des Bildes einen Rand von 50 Pixel ein.
.RE
.PD 1
.IPs <x>,<y>
Position des ursprünglichen Bildes im expandierten Bild (Standard: Mitte)
.IPs "<o>\ \ "
Anzeige von OSD/\:Untertiteln
.RSss
0: deaktiviert (Standard)
.br
1: aktiviert
.REss
.IPs "<a>\ \ "
Expandiert angepasst an das Seitenverhältnis anstatt an die Auflösung
(Standard: 0).
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IP expand=800:::::4/3
Erweitert auf 800x600, es sei denn, die Quelle hat einen höhere Auflösung, dann
wird auf das Seitenverhältnis 4/3 erweitert.
.RE
.PD 1
.IPs "<r>\ \ "
Rundet Breite und Höhe auf Vielfache von <r> auf. (Standard: 1).
.RE
.
.TP
.B flip (siehe auch \-flip)
Stellt das Bild auf den Kopf.
.
.TP
.B "mirror\ "
Spiegelt das Bild an der Y-Achse.
.
.TP
.B rotate[=<0\-7>]
Dreht das Bild um +/\:- 90 Grad (und stellt es optional auf den Kopf).
Bei Werten zwischen 4\-7 wird das Bild nur dann gedreht, wenn es vorher
hochkant war  (es also höher als breit ist).
.RSs
.IPs 0
Drehe um 90 Grad im Uhrzeigersinn und stelle es auf den Kopf (Standard).
.IPs 1
Drehe um 90 Grad im Uhrzeigersinn.
.IPs 2
Drehe um 90 Grad gegen den Uhrzeigersinn.
.IPs 3
Drehe um 90 Grad gegen den Uhrzeigersinn und stelle es auf den Kopf.
.RE
.
.TP
.B scale[=b:h[:interlaced[:chr_drop[:par[:par2[:presize[:noup[:arnd]]]]]]]]
Skaliert das Bild mit dem Softwareskalierer (langsam) und führt eine
Farbraumkonvertierung zwischen YUV und RGB durch (siehe auch \-sws).
.RSs
.IPs <b>,<h>
skalierte Breite/\:Höhe (Standard: originale Breite/\:Höhe)
.br
.I ANMERKUNG:
Wenn \-zoom benutzt wird und die unterliegenden Filter (inklusive libvo)
Skalierung nicht unterstützen, werden die Werte d_width/\:d_height benutzt.
.\" FIXME: Klärung von d_width/\:d_height!
.RSss
 0:   skalierte d_width/\:d_height
.br
\-1:   originale Breite/\:Höhe
.br
\-2:   Berechne Breite/Höhe anhand der jeweils anderen Größe und dem
vorskalierten Breiten-/Höhenverhältnis.
.br
\-3:   Berechne Breite/Höhe anhand der jeweils anderen Größe und dem
originalen Breiten-/Höhenverhältnis.
.br
\-(n+8): wie \-n oben, rundet aber die Abmessung auf das nächste Vielfache von
16.
.REss
.IPs <interlaced>
Schalte Interlaced-Skalierung an/\:aus.
.RSss
0: aus (Standard)
.br
1: ein
.REss
.IPs <chr_drop>
Chroma-Skipping, Auslassen von Chrominanz-Berechnungen
.RSss
0: Benutze alle verfügbaren Eingabezeilen für Chrominanz-Berechnungen.
.br
1: Benutze nur jede zweite Eingabezeile für Chrominanz-Berechnungen.
.br
2: Benutze nur jede vierte Eingabezeile für Chrominanz-Berechnungen.
.br
3: Benutze nur jede achte Eingabezeile für Chrominanz-Berechnungen.
.REss
.IPs "<par>:[:<par2>] (siehe auch \-sws)"
Setzt einige Skalierungsparameter abhängig vom Skalierer, der mit \-sws
gewählt wurde.
.RSss
\-sws 2 (bicubisch):  B (weichzeichnend) und C (verstärkend)
.br
0.00:0.60 Standard
.br
0.00:0.75 "precise bicubic" von VirtualDub
.br
0.00:0.50 Catmull-Rom spline
.br
0.33:0.33 Mitchell-Netravali spline
.br
1.00:0.00 cubic B-spline
.br
\-sws 7 (gaussian): Schärfe (0 (weich) \- 100 (scharf))
.br
\-sws 9 (lanczos):  Filterlänge (1\-10)
.REss
.IPs <presize>
Skaliere auf eine Standardgröße.
.RSss
qntsc:   352x240 (NTSC Quarter-Screen)
.br
qpal:    352x288 (PAL Quarter-Screen)
.br
ntsc:    720x480 (Standard-NTSC)
.br
pal:     720x576 (Standard-PAL)
.br
sntsc:   640x480 (NTSC mit quadratischen Pixeln)
.br
spal:    768x576 (PAL mit quadratischen Pixeln)
.REss
.IPs <noup>
Verbietet Hochskalierung über die ursprünglichen Abmessungen hinaus.
.RSss
0: Erlaubt Hochskalierung (Standard).
.br
1: Verbietet Hochskalierung, falls eine Abmessung ihren ursprünglichen Wert
überschreitet.
.br
2: Verbietet Hochskalierung, falls beide Abmessungen ihre ursprünglichen Werte
überschreiten.
.REss
.IPs <arnd>
Genaues Runden für den vertikalen Skalierer, der schneller oder langsamer als
das Standardrunden ist.
.RSss
0: Deaktiviert genaues Runden (Standard).
.br
1: Aktiviert genaues Runden.
.REss
.RE
.
.TP
.B dsize=[Aspekt|b:h:Aspektmethode:r]
Ändert die beabsichtigte Displaygröße/\:den Aspekt an einer frei wählbaren
Position der Filterkette.
Der Aspekt kann als Bruch (4/3) oder Fließkommazahl (1.33) angegeben werden.
Alternativ können exakte Wiedergabebreite und -höhe wie gewünscht angegeben
werden.
Beachte, dass dieser Filter selbst
.B keine
Skalierung vornimmt; er beeinflusst nur, was spätere Skalierer (Software oder
Hardware) beim automatischen Skalieren tun werden, um den Aspekt zu
korrigieren.
.RSs
.IPs <b>,<h>
Neue Wiedergabebreite und -höhe.
Kann auch die folgenden Spezialwerte haben:
.RSss
 0:    ursprüngliche Anzeigebreite und -höhe.
.br
\-1:    ursprüngliche Videobreite/-höhe (Standard).
.br
\-2:    Berechne Breite/Höhe anhand der anderen Abmessung und des ursprünglichen
Anzeigeaspekts.
.br
\-3:    Berechne Breite/Höhe anhand der anderen Abmessung und des ursprünglichen
Videoaspekts.
.REss
.sp 1
.I BEISPIEL:
.PD 0
.IP dsize=800:\-2
Gibt eine Anzeigeauflösung von 800x600 für ein Video mit Aspekt 4/3, oder
800x450 für ein 16/9-Video an.
.RE
.IPs <Aspektmethode>
Verändert Breite und Höhe anhand des ursprünglichen Aspekts.
.RSss
\-1: Ignoriere ursprünglichen Aspekt (Standard).
.br
 0: Behalte Anzeigeaspekt durch Benutzung von <b> und <h> als Maximalauflösung.
.br
 1: Behalte Anzeigeaspekt durch Benutzung von <b> und <h> als Minimalauflösung.
.br
 2: Behalte Videoaspekt durch Benutzung von <b> und <h> als Maxmimalauflösung.
.br
 3: Behalte Videoaspekt durch Benutzung von <b> und <h> als Minimalauflösung.
.REss
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IP dsize=800:600:0
Gibt eine Anzeigeauflösung von maximal 800x600 oder kleiner an, um den Aspekt
beizubehalten.
.RE
.PD 1
.IPs "<r>\ \ "
Rundet Breite und Höhe auf ein Vielfaches von <r> auf (Standard: 1).
.RE
.
.TP
.B "yuy2\ \ \ "
Erzwingt Konvertierung von YV12/\:I420/\:422P nach YUY2 in Software.
Nützlich bei Videokarten/\:Treibern mit langsamer YV12- aber
schneller YUY2-Unterstützung.
.
.TP
B "yvu9\ \ \ "
Erzwingt eine Software-Farbraumkonvertierung von YVU9 nach YV12.
Zu Gunsten des Softwareskalierers abgelehnt.
.
.TP
.B "yuvcsp\ "
Zieht die YUV-Farbwerte auf den CCIR 601-Bereich zusammen, ohne eine
wirkliche Konvertierung vorzunehmen.
.
.TP
.B rgb2bgr[=swap]
Farbraumkonvertierung RGB 24/32 <\-> BGR 24/32
.PD 0
.RSs
.IPs "swap\ "
Führe auch eine R <-> B-Vertauschung durch.
.RE
.PD 1
.
.TP
.B palette
Farbraumkonvertierung RGB/BGR 8 \-> 15/16/24/32bpp unter Verwendung
einer Farbpalette.
.
.TP
.B format[=fourcc]
Beschränkt den Farbraum des nächsten Filters ohne jegliche Konvertierung.
Benutze ihn zusammen mit dem scale-Filter, um tatsächlich eine Konvertierung
durchzuführen.
.br
.I ANMERKUNG:
Für eine Liste der verfügbaren Formate siehe format=fmt=help.
.PD 0
.RSs
.IPs <fourcc>
Formatname wie rgb15, bgr24, yv12 usw.\& (Standard: yuy2)
.RE
.PD 1
.
.TP
.B noformat[=fourcc]
Beschränkt den Farbraum des nächsten Filters ohne jegliche Konvertierung.
Anders als der format-Filter erlaubt dieser jeden Farbraum
.B außer
dem von dir angegebenen.
.br
.I ANMERKUNG:
Für eine Liste der verfügbaren Formate siehe noformat=fmt=help.
.PD 0
.RSs
.IPs <fourcc>
Formatname wie rgb15, bgr24, yv12 usw.\& (Standard: yv12)
.RE
.PD 1
.
.TP
.B pp[=Filter1[:Option1[:Option2...]]/[\-]Filter2...] (siehe auch \-pphelp)
Aktiviert die Benutzung der angegebenen Kette von Postprocessing-Subfiltern.
Subfilter müssen durch ein '/'\-Zeichen voneinander getrennt werden und
können durch ein vorangestelltes '\-' deaktiviert werden.
Jeder Unterfilter und manche Optionen haben einen kurzen und einen langen
Namen, die unabhängig voneinander benutzt werden können, so ist z.B.\&
dr/dering das gleiche.
Alle Subfilter teilen gemeinsame Optionen, um ihren Geltungsbereich zu
bestimmen:
.PD 0
.RSs
.IPs a/autoq
Schalte den Subfilter automatisch aus, falls die CPU zu langsam ist.
.IPs c/chrom
Führe außerdem Chrominanz-Filterung durch (Standard).
.IPs y/nochrom
Führe nur Luminanz-Filterung durch (keine Chrominanz).
.IPs n/noluma
Führe nur Chrominanz-Filterung durch (keine Luminanz).
.RE
.PD 1
.sp 1
.RS
.br
.I ANMERKUNG:
\-pphelp zeigt eine Liste der verfügbaren Subfilter.
.sp 1
Verfügbare Subfilter sind folgende:
.RE
.RSs
.IPs hb/hdeblock[:Differenz[:Flachheit]]
horizontaler Deblocking-Filter
.RSss
<Differenz>: Differenzfaktor, wobei größere Werte mehr Deblocking
bedeuten (Standard: 32).
.br
<Flachheit>: Schwellenwert für die Flachheit, wobei niedrigere Werte
mehr Deblocking bedeuten (Standard: 39).
.REss
.IPs vb/vdeblock[:Differenz[:Flachheit]]
vertikaler Deblocking-Filter
.RSss
<Differenz>: Differenzfaktor, wobei größere Werte mehr Deblocking
bedeuten (Standard: 32).
.br
<Flachheit>: Schwellenwert für die Flachheit, wobei niedrigere Werte
mehr Deblocking bedeuten (Standard: 39).
.REss
.IPs ha/hadeblock[:Differenz[:Flachheit]]
genauer horizontaler Deblocking-Filter
.RSss
<Differenz>: Differenzfaktor, wobei größere Werte mehr Deblocking
bedeuten (Standard: 32).
.br
<Flachheit>: Schwellenwert für die Flachheit, wobei niedrigere Werte
mehr Deblocking bedeuten (Standard: 39).
.REss
.IPs va/vadeblock[:Differenz[:Flachheit]]
genauer vertikaler Deblocking-Filter
.RSss
<Differenz>: Differenzfaktor, wobei größere Werte mehr Deblocking
bedeuten (Standard: 32).
.br
<Flachheit>: Schwellenwert für die Flachheit, wobei niedrigere Werte
mehr Deblocking bedeuten (Standard: 39).
.REss
.sp 1
Die horizontalen und vertikalen Deblocking-Filter benutzen die Werte
für Differenz und Flachheit gemeinsam, du kannst daher keine unterschiedlichen
horizontalen und vertikalen Schwellenwerte angeben.
.sp 1
.IPs h1/x1hdeblock
experimenteller horizontaler Deblocking-Filter
.IPs v1/x1vdeblock
experimenteller vertikaler Deblocking-Filter
.IPs dr/dering
Störungsfilter
.IPs tn/tmpnoise[:Schwelle1[:Schwelle2[:Schwelle3]]]
Reduzierung zeitweisen Rauschens
.RSss
<Schwelle1>: größer \-> stärkere Filterung
.br
<Schwelle2>: größer \-> stärkere Filterung
.br
<Schwelle3>: größer \-> stärkere Filterung
.REss
.IPs al/autolevels[:f/fullyrange]
automatische Korrektur von Helligkeit und Kontrast
.RSss
f/fullyrange: Ausdehnung der Luminanz auf (0\-255).
.REss
.IPs lb/linblenddeint
Linearer Mischungs-Deinterlace-Filter, der Deinterlacing eines gegebenen
Blocks durch Filterung mit einem (1 2 1)-Filter durchführt.
.IPs li/linipoldeint
Linearer Interpolations-Deinterlace-Filter, der Deinterlacing eines gegebenen
Blocks durch lineare Interpolation jeder zweiten Zeile durchführt.
.IPs ci/cubicipoldeint
Cubischer Interpolations-Deinterlace-Filter, der Deinterlacing eines gegebenen
Blocks durch cubische Interpolation jeder zweiten Zeile durchführt.
.IPs md/mediandeint
Median-Deinterlace-Filter, der Deinterlacing eines gegebenen Blocks durch
Medianfilterung jeder zweiten Zeile durchführt.
.IPs fd/ffmpegdeint
FFmpeg-Deinterlace-Filter, der Deinterlacing eines gegebenen Blocks durch
Filterung jeder zweiten Zeite mit einem (\-1 4 2 4 \-1)-Filter durchführt.
.IPs l5/lowpass5
Vertikal angewendeter FIR-Tiefpass-Deinterlace-Filter, der Deinterlacing eines
gegebenen Blocks durch Filterung aller Zeilen mit einem (\-1 2 6 2 \-1)-Filter
durchführt.
.IPs fq/forceQuant[:Quantisierungsparameter]
Überschreibt die Tabelle der Quantisierungsparameter der Eingabe mit einem
konstanten Quantisierungsparameter, den du angibst.
.RSss
<Quantisierungsparameter>: zu benutzender Quantisierungsparameter
.REss
.IPs de/default
Standard-pp-Filterkombination (hb:a,vb:a,dr:a)
.IPs fa/fast
schnelle pp-Filterkombination (h1:a,v1:a,dr:a)
.IPs "ac\ \ \ "
hochqualitative pp-Filterkombination (ha:a:128:7,va:a,dr:a)
.RE
.RS
.sp 1
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs "\-vf pp=hb/vb/dr/al"
horizontales und vertikales Deblocking, Abschwächung und automatische
Helligkeit/\:Kontrast
.IPs "\-vf pp=de/\-al"
Standardfilter ohne Helligkeits\-/\:Kontrastkorrektur
.IPs "\-vf pp=default/tmpnoise:1:2:3"
Aktiviert Standardfilter und temporäre Rauschunterdrücker.
.IPs "\-vf pp=hb:y/vb:a"
Horizontales Deblocking nur luminanzbezogen, schaltet vertikales Deblocking
je nach verfügbarer CPU-Auslastung hinzu.
.RE
.PD 1
.
.TP
.B spp[=Qualität[:qp[:Modus]]]
Einfacher Nachbearbeitungsfilter, der das Bild
mit mehreren (bzw.\& \- im Falle von Qualitätslevel 6 \- allen) Verschiebungen
komprimiert und dekomprimiert und daraus den Mittelwert bildet.
.RSs
.IPs <Qualität>
0\-6 (Standard: 3)
.IPs "<qp>\ "
Erzwinge Quantisierungsparameter (Standard: 0, benutze QP vom Video).
.IPs <Modus>
0: harter Schwellenwert (Standard)
.br
1: weicher Schwellenwert (besseres Deringing, aber unschärfer)
.br
4: wie 0, benutze aber auch den QP von B-Frames (kann Flackern verursachen).
.br
5: wie 1, benutze aber auch QP von B-Frames (kann Flackern verursachen).
.RE
.
.TP
.B uspp[=Qualität[:qp]]
Ultra-einfacher und -langsamer Nachbearbeitungsfilter, der das Bild
mit mehreren (bzw.\& \- im Falle von Qualitätslevel 8 \- alle) Verschiebungen
rekomprimiert und daraus den Mittelwert bildet.
Dies unterscheidet sich im Verhalten zu spp insofern, dass uspp tatsächlich
jeden Fall mit libavcodec Snow encodiert und decodiert, wohingegen spp eine
vereinfachte nur-Intra 8x8 DCT ähnlich der bei MJPEG benutzten verwendet.
.RSs
.IPs <Qualität>
0\-8 (Standard: 3)
.IPs "<qp>\ "
Erzwinge Quantisierungsparameter (Standard: 0, benutze QP vom Video).
.RE
.
.TP
.B fspp[=Qualität[:qp[:Stärke[:bframes]]]]
schnellere Variante des einfachen Nachbearbeitungsfilters.
.RSs
.IPs <Qualität>
4\-5 (äquivalent zu spp; Standard: 4)
.IPs "<qp>\ "
Erzwinge Quantisierungsparameter (Standard: 0, benutze QP vom Video).
.IPs <Stärke> (\-15\-32)
Stärke des Filters, niedrigere Werte behalten mehr Details, aber auch mehr
Artefakte, während höhere Werte das Bild glatter und unschärfer machen
(Standard: 0 \- PSNR optimal).
.IPs <bframes>
0: Benutze QP von B-Frames nicht (Standard).
.br
1: Benutze auch QP von B-Frames (Kann Flackern verursachen).
.RE
.
.TP
.B pp7[=qp[:Modus]]
Variante des spp-Filters, vergleichbar mit spp=6 mit 7-Punkt DCT, wobei
nur der Wert aus der Mitte nach der IDCT weiterbenutzt wird.
.RSs
.IPs "<qp>\ "
Erzwinge Quantisierungsparameter (Standard: 0, benutze QP vom Video).
.IPs <Modus>
0: harte Schwellwerte
.br
1: weiche Schwellwerte (besseres Deringing, aber unschärfer)
.br
2: mittlere Schwellwerte (Standard, gute Ergebnisse)
.RE
.
.TP
.B qp=Gleichung
Filter zur Änderung der Quantisierungsparameter (QP).
.RSs
.IPs <Gleichung>
eine Gleichung wie "2+2*sin(PI*qp)"
.RE
.
.TP
.B geq=Gleichung
generischer Gleichungsänderungsfilter
.RSs
.IPs <Gleichung>
Irgendeine Gleichung, z.B.\& 'p(W-X\\,Y)' zum horizontalen Spiegeln des Bildes.
Du kannst Leerzeichen verwenden, um die Gleichung besser lesbar zu machen.
Es gibt ein paar Konstanten, die in der Gleichung verwendet werden können:
.RSss
PI: die Zahl Pi
.br
E: die Zahl e
.br
X / Y: die Koordinaten des aktuellen Samples
.br
W / H: Breite und Höhe des Bildes
.br
SW / SH: Skalierung der Breite/Höhe abhängig von der momentan gefilterten
Ebene, z.B.\& 1,1 und 0.5,0.5 für YUV 4:2:0.
.br
p(x,y): Gibt den Wert des Pixels an Position x/y der aktuellen Ebene zurück.
.REss
.RE
.
.TP
.B "test\ \ \ "
Generiere verschiedene Testmuster.
.
.TP
.B rgbtest[=Breite:Höhe]
Generiere ein RGB-Testmuster, nützlich, um RGB/\:BGR-Probleme zu erkennen.
Du solltest einen roten, grünen und blauen Streifen von oben nach unten sehen.
.RSs
.IPs <Breite>
Gewünschte Breite des generierten Bildes (Standard: 0).
0 bedeutet Breite des Eingabebildes.
.br
.IPs <Höhe>
Gewünschte Höhe des generierten Bildes (Standard: 0).
0 bedeutet Höhe des Eingabebildes.
.RE
.
.TP
.B lavc[=Qualität:fps]
Schnelle Softwarekonvertierung von YV12 nach MPEG-1 mit libavcodec
für die Benutzung mit DVB/\:DXR3/\:IVTV/\:V4L2.
.RSs
.IPs <Qualität>
1\-31: fester Quantisierungsfaktor
.br
32\-:  feste Bitrate in kBit
.IPs <fps>
Erzwinge Ausgabe-fps (Fließkommawert) (Standard: 0, automatische
Erkennung basierend auf Höhe)
.RE
.
.TP
.B dvbscale[=Aspekt]
Wählt die optimale Skalierung für DVB-Karten, skaliert hardwareseitig
die X-Achse und berecht die Y-Achse softwareseitig, um den Aspekt
beizubehalten.
Nützlich nur in Verbindung mit expand und scale.
.RSs
.IPs <Aspekt>
Kontrolliere das Seitenverhältnis, berechnet durch DVB_HÖHE*ASPEKT
(Standard:
576*4/3=768), setze auf 576*(16/9)=1024 für einen 16:9-Fernseher.
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs "\-vf dvbscale,scale=\-1:0,expand=\-1:576:\-1:\-1:1,lavc"
.\" FIXME: Erkläre, was dieser Befehl bewirkt.
.RE
.PD 1
.
.TP
.B "noise[=Helligkeit[u][t|a][h][p]:Farbwert[u][t|a][h][p]]"
Fügt Rauschen hinzu.
.PD 0
.RSs
.IPs <0\-100>
Helligkeitsrauschen
.IPs <0\-100>
Farbrauschen
.IPs u
gleichförmiges Rauschen (sonst gaußsch)
.IPs t
temporäres Rauschen (Rauschmuster wechselt zwischen Bildern)
.IPs a
gemitteltes temporäres Rauschen (weicher, aber viel langsamener)
.IPs h
hohe Qualität (sieht etwas besser aus, dafür etwas langsamer)
.IPs p
Mische Rauschen mit einem (halbwegs) gleichmäßigen Muster
.RE
.PD 1
.
.TP
.B "denoise3d[=Helligkeit_r:Farbwert_r:Helligkeit_z:Farbwert_z]"
Dieser Filter versucht, Bildrauschen zu unterdrücken und so bewegungslose
Bilder wirklich statisch zu machen (was das Bild besser komprimierbar machen
sollte).
.PD 0
.RSs
.IPs <Helligkeit_r>
räumliche Helligkeitsstärke (Standard: 4)
.IPs <Farbwert_r>
räumliche Farbstärke (Standard: 3)
.IPs <Helligkeit_z>
zeitliche Helligkeitsstärke (Standard: 6)
.IPs <Farbwert_z>
zeitliche Farbstärke (Standard: Helligkeit_r*Farbwert_r/Helligkeit_z)
.RE
.PD 1
.
.TP
.B hqdn3d[=Helligkeit_r:Farbwert_r:Helligkeit_z:Farbwert_z]"
Hochpräzise und -qualitative Version des Denoise3d-Filters.
Parameter und Gebrauch sind dieselben.
.
.TP
.B ow[=Tiefe[:Helligkeitsstärke[:Farbtonstärke]]]
Overcomplete Wavelet Denoiser.
.PD 0
.RSs
.IPs <Tiefe>
Größere Tiefenwerte werden Komponenten mit niedrigerer Frequenz stärker
entstören, das Filtern jedoch verlangsamen (Standard: 8).
.IPs <Helligkeitsstärke>
Helligkeitsstärke (Standard: 1.0)
.IPs <Farbtonstärke>
Farbtonstärke (Standard: 1.0)
.RE
.PD 1
.
.TP
.B eq[=Helligkeit:Kontrast] (VERALTET)
Softwareequalizer mit interaktiver Kontrolle wie beim Hardwareequalizer, für
Karten/\:Treiber, die die Kontrolle über Helligkeit und Kontrast via Hardware
nicht unterstützen.
Kann in Verbindung mit MEncoder nützlich sein; einerseits, um schlecht
aufgenommene Filme zu reparieren, und zum anderen, um Artifakte zu maskieren
und niedrigere Bitraten benutzen zu können.
.PD 0
.RSs
.IPs <\-100\-100>
initiale Helligkeit
.IPs <\-100\-100>
initialer Kontrast
.RE
.PD 1
.
.TP
.B eq2[=gamma:Kontrast:Helligkeit:Sättigung:rg:gg:bg:weight]
Alternativer Softwareequalizer, der Lookup-Tabellen benutzt (sehr langsam).
Er erlaubt neben simpler Anpassung der Helligkeit und des Kontrastes
auch eine Gammakorrektur.
Beachte, dass er den gleichen MMX-optimierten Code benutzt wie \-vf eq, wenn
alle Gammawerte 1.0 betragen!
Die Parameter werden als Fließkommazahlen angegeben.
.PD 0
.RSs
.IPs <0.1\-10>
initialer Gammawert (Standard: 1.0)
.IPs <\-2\-2>
initialer Kontrast, wobei negative Werte ein Negativbild bewirken
(Standard: 1.0)
.IPs <\-1\-1>
initiale Helligkeit (Standard: 0.0)
.IPs <0\-3>
initiale Sättigung (Standard: 1.0)
.IPs <0.1\-10>
Gammawert der roten Komponente (Standard: 1.0)
.IPs <0.1\-10>
Gammawert der grünen Komponente (Standard: 1.0)
.IPs <0.1\-10>
Gammawert der blauen Komponente (Standard: 1.0)
.IPs <0\-1>
Der Parameter weight kann verwendet werden, um die Wirkung hoher Gammawerte auf
helle Bildbereiche zu reduzieren, sie also z.B.\& davon abzuhalten
zu übersteuern und ganz weiss zu werden.
Bei 0.0 hat die Gammakorrektur gar keinen Effekt mehr, bei 1.0 hat sie die
volle Stärke.
.RE
.PD 1
.
.TP
.B hue[=Farbton:Sättigung]
Softwareequalizer mit interaktiver Kontrolle wie beim Hardwareequalizer, für
Karten/\Treiber, die Farbton- und Sättigungskontrolle nicht in Hardware
unterstützen.
.PD 0
.RSs
.IPs <\-180\-180>
initiale Farbtonstärke (Standard: 0.0)
.IPs <\-100\-100>
initiale Sättigung, wobei negative Werte zu negativer Chrominanz führen
(Standard: 1.0)
.RE
.PD 1
.
.TP
.B halfpack[=f]
Konvertiert planares YUV 4:2:0 in halbhohes, gepacktes 4:2:2, wobei
der Farbanteil beibehalten und die Helligkeit nach unten angepasst wird.
Nützlich bei Ausgaben auf Geräte mit niedriger Auflösung, bei denen
die Hardwareskalierung schlechte Qualität liefert oder nicht verfügbar ist.
Kann auch als primitiver Deinterlacer benutzt werden, der nur auf dem
Helligkeitsanteil arbeitet und sehr wenig CPU-Leistung erfordert.
.PD 0
.RSs
.IPs "<f>\ \ "
In der Voreinstellung bildet halfpack beim Downsampling den Durchschnitt
von Zeilenpaaren.
Jeder von 0 oder 1 verschiedene Wert liefert das
Standard(downsampling)verhalten.
.RSss
0: Benutze beim Downsampling nur die geraden Zeilen.
.br
1: Benutze beim Downsampling nur die ungeraden Zeilen.
.REss
.RE
.PD 1
.
.TP
.B ilpack[=Modus]
Wenn interlaced-Videos in YUV 4:2:0-Formaten gespeichert wird, wird das
Interlacing der Chrominanz wegen vertikalen Resamplings der Chrominanzkanäle
nicht an den richtigen Stellen dargestellt.
Dieser Filter packt die planaren 4:2:0-Daten in das YUY2 (4:2:2)-Format
mit den Chrominanzlinien an den richten Stellen.
So kommen die Daten für Helligkeit und Chrominanz für jede Zeile vom selben
Feld.
.PD 0
.RSs
.IPs <Modus>
Wähle den Skalierungs-Modus.
.RSss
0: Bildpunktverdopplung (nearest-neighbor), schnell aber ungenau
.br
1: lineare Interpolation (Standard)
.REss
.RE
.PD 1
.
.TP
.B harddup
Nur in Verbindung mit MEncoder nützlich.
Wenn harddup bei der Encodierung verwendet wird, sorgt es dafür, dass doppelte
Frames auch im encodierten Output doppelt vorkommen.
Dies verbraucht ein wenig mehr Platz, ist jedoch für die Ausgabe in
MPEG-Dateien nötig oder dann, wenn der Videostream nach der Encodierung
getrennt und neu zusammengesetzt werden soll (demux und remux).
Die Option sollte am oder nahe am Ende der Filterkette stehen, es sei denn, du
hast einen guten Grund, es anders zu machen.
.
.TP
.B softskip
Nur in Verbindung mit MEncoder nützlich.
Softskip verschiebt den Schritt des Encodierungsvorgangs, Frames zu
Überspringen (Wegzulassen) von der Position vor der Filterkette in die
Filterkette hinein.
Dies erlaubt denjenigen Filtern, die alle Frames untersuchen müssen
(umgekehrtes Telecine, zeitliche Rauschunterdrückung), korrekt zu arbeiten.
Sollte nach den Filtern, die alle Frames untersuchen müssen, platziert werden
und vor all denjenigen, die CPU-intensiv sind.
.
.TP
.B decimate[=max:hi:lo:frac]
Lässt Frames weg, die sich nicht sehr on den vorigen unterscheiden, um die
Framerate zu reduzieren.
Die Hauptanwendung für diesen Filters ist die Encodierung bei sehr niedrigen
Bitraten (z.B.\& Streaming über eine Modemverbindung), er kann aber
theoretisch auch dazu benutzt werden, Filme zu reparieren, die mit
inversed-telecine fehlerhaft encodiert worden sind.
.PD 0
.RSs
.IPs <max>
Setzt eine obere Grenze für die Anzahl aufeinanderfolgender Frames, die
weggelassen werden können (falls positiv), sonst das kleinste Intervall
zwischen weggelassenen Frames (falls negativ).
.IPs <hi>,<lo>,<frac>
Ein Frame ist Kanditat dafür, weggelassen zu werden, falls keine 8x8-Region
sich mehr unterscheidet als der Schwellenwert <hi> angibt und falls sich nicht
mehr als der Anteil <frac> angibt (wobei 1 das ganze Bild bedeutet) vom
Schwellenwert <lo> unterscheidet.
Werte für <hi> und <lo> beziehen sich auf 8x8-Pixelblöcke und repräsentieren
aktuelle Unterschiede der Pixelwerte.
Ein Schwellenwert von 64 entspricht also einer Einheit im Unterschied für jeden
Pixel oder derselben unterschiedlichen Ausbreitung über einen Block.
.RE
.PD 1
.
.TP
.B dint[=sense:level]
Der verwerfende Deinterlace-Filter (drop-deinterlace, dint) erkennt und
verwirft den ersten einer Gruppe von interlaced Frames.
.PD 0
.RSs
.IPs <0.0\-1.0>
relative Differenz zwischen benachbarten Pixeln (Standard: 0.1)
.IPs <0.0\-1.0>
Wie groß der als interlaced erkannte Teil eines Bildes sein muss, damit der
Frame verworfen wird (Standard: 0.15).
.RE
.PD 1
.
.TP
.B lavcdeint (VERALTET)
FFmpeg-Deinterlace-Filter, gleichbedeutend mit \-vf pp=fd
.
.TP
.B kerndeint[=thresh[:map[:order[:sharp[:twoway]]]]]
Donald Grafts adaptiver Kernel-Deinterlacer.
Führt ein Deinterlacing von Teilen des Videos durch, falls ein
wählbarer Schwellenwert überschritten wird.
.PD 0
.RSs
.IPs <0\-255>
Schwellenwert (Standard: 10)
.IPs <map>
.RSss
0: Ignoriere Pixel, die den Schwellenwert überschreiten (Standard).
.br
1: Färbt Pixel, die den Schwellenwert überschreiten, weiß.
.REss
.IPs <order>
.RSss
0: Rühre die Felder nicht an (Standard).
.br
1: Tausche die Felder.
.REss
.IPs <sharp>
.RSss
0: Deaktiviere zusätzliches Schärfen (Standard).
.br
1: Füge zusätzliche Schärfe hinzu.
.REss
.IPs <twoway>
.RSss
0: Deaktiviert zwei-Wege-Schärfung (default).
.br
1: Aktiviert zwei-Wege-Schärfung.
.REss
.RE
.PD 1
.
.TP
.B "unsharp=l|cBxH:Menge[:l|cWxH:Menge]"
Unschärfemaske / Gaußscher Weichzeichner
.RS
.IPs "l\ \ \ \ "
Wendet den Effekt auf den Helligkeitsanteil an.
.IPs "c\ \ \ \ "
Wendet den Effekt auf den Farbanteil an.
.IPs <Breite>x<Höhe>
Breite und Höhe der Matrix, die in beide Richtungen
ungerade sein muss (min = 3x3, max = 13x11 oder 11x13, normalerweise
zwischen 3x3 und 7x7).
.IPs Menge
relative "Menge" der Schärfe/\:Unschärfe, die dem Bild hinzugefügt
wird (ein vernünftiger Bereich ist \-1.5\-1.5).
.RSss
<0: weichzeichnen
.br
>0: schärfen
.REss
.RE
.
.TP
.B "swapuv\ "
Vertauscht die U- und V-Ebene.
.
.TP
.B il=[d|i][s][:[d|i][s]]
Führt ein (De)Interleaving von Zeilen durch.
Das Ziel dieses Filters ist es, die Bearbeitung von interlaced Bildern zu
ermöglichen, ohne sie vorher zu deinterlacen.
Du kannst eine interlaced DVD filtern und am Fernseher ausgeben, ohne
das Interlacing zu entfernen.
Während Deinterlacing (mit dem Postprocessing-Filter) Interlacing permanent
entfernt (smoothing, averaging, etc.\&), teilt
dieser Filter das Bild in zwei Felder auf (sogenannte Halbbilder),
so dass diese unabhängig voneinander gefiltert und wieder interleavt werden
können.
.PD 0
.RSs
.IPs d
deinterleave, entschachteln (einen über dem anderen plazieren)
.IPs i
interleave, verschachteln
.IPs s
vertauschen der Felder (gerade und ungerade Zeilen austauschen)
.RE
.PD 1
.
.TP
.B fil=[i|d]
Führt ein (De)Interleaving von Zeilen durch.
Dieser Filter ist dem il-Filter sehr ähnlich, jedoch viel schneller.
Der Hauptnachteil ist, dass er nicht immer funktioniert.
Besonders in Kombination mit anderen Filtern kann es zu zufällig gestörten
Bildern kommen.
Sei also froh, wenn es funktioniert, beschwere dich aber nicht, falls bei
deiner Filterkombination Fehler auftreten.
.PD 0
.RSs
.IPs d
Deinterleave der Felder, platziert beide Seite an Seite.
.IPs i
Erneutes Interleave der Felder (kehrt den Effekt von fil=d um).
.RE
.PD 1
.
.TP
.B field[=n]
Extrahiert ein einzelnes Feld eines interlaced Bildes mit Stride-Arithmetik,
um Verschwendung von CPU-Zeit zu vermeiden.
Der optionale Parameter n gibt an, ob das gerade oder ungerade Feld extrahiert
wird (abhängig davon, ob n selber gerade oder ungerade ist).
.
.TP
.B detc[=Var1=Wert1:Var2=Wert2:...]
Versucht, den 'Telecine'-Prozess umzukehren, um einen sauberen,
nicht-interlaced-Stream mit der Framerate des Films wiederherzustellen.
Dieser war der erste und primitivste Inverse-Telecine-Filter, der zu
MPlayer/\:MEncoder hinzugefügt wurde.
Er speichert Telecine-3:2-Muster zwischen und folgt ihnen soweit wie möglich.
Dies macht in tauglich für perfekt-telecined Material, selbst bei
Vorhandensein eines gewissen Grades an Störung.
Er wird jedoch nicht funktionieren bei Vorhandensein komplexer
Post-Telecine-Änderungen.
Die Entwicklung an diesem Filter findet nicht weiter statt, da ivtc, pullup
und filmdint für die meisten Anwendungen besser geeignet sind.
Die folgenden Argumente (Syntax siehe oben) steuern das Verhalten des
detc-Filters:
.RSs
.IPs "<dr>\ "
Setzt den Framedropping-Modus.
.RSss
0: Kein Frame wird ausgelassen, um eine feste Framerate der Ausgabe
zu erhalten (Standard).
.br
1: Ein Frame wird immer dann verworfen, wenn es keine Auslassungen oder
Telecine-Zusammenführungen innerhalb der letzten 5 Frames gab.
.br
2: Ein ständiges Verhältnis von 5:4 der Eingabe zur Ausgabe wird beibehalten.
.br
.I ANMERKUNG:
Benutze Modus 1 oder 2 mit MEncoder.
.REss
.IPs "<am>\ "
Analyse-Modus.
.RSss
0: Festgelegtes Muster mit initialer Anzahl der Frames angegeben durch <fr>.
.br
1: aggressive Suche nach Telecine-Muster (Standard).
.REss
.IPs "<fr>\ "
Setzt die initiale Anzahl der Frames in Folge.
0\-2 sind die drei sauberen, progressiven Frames; 3 und 4 sind die beiden
interlaced-Frames.
Der Standardwert, \-1, bedeutet 'nicht in Telecine-Abfolge'.
Die hier angegebene Zahl gibt den Typ des imaginären vorigen Frames an, bevor
der Film beginnt.
.IPs "<t0>, <t1>, <t2>, <t3>"
Schwellenwerte, die in bestimmten Modi verwendet werden.
.RE
.
.TP
.B ivtc[=1]
Experimenteller 'zustandsloser' Inverse-Telecine-Filter.
Anstatt zu versuchen, ein Muster zu finden, wie es der detc-Filter tut, trifft
ivtc seine Entscheidungen unabhängig für jeden Frame.
Dies liefert wesentlich bessere Resultate für Material, das ausgiebiger
Editierung unterzogen wurde, nachdem Telecine angewendet wurde.
Im Endeffekt ist es jedoch nicht so nachsichtig bei leicht gestörtem Input,
wie bei Capturing von TV-Input.
Der optionale Parameter (ivtc=1) entspricht der Option dr=1 des detc-Filters
und sollte nur von MEncoder, nicht von MPlayer verwendet werden.
Wie bei detc muss auch hier bei Benutzung von MEncoder die korrekte
Ausgabe-Framerate (\-ofps 24000/1001) angegeben werden.
Die Entwicklung an itvc findet nicht weiter statt, da die Filter pullup und
filmdint genauer zu sein scheinen.
.
.TP
.B pullup[=jl:jr:jo:ju:sb:mp]
Pulldown-Umkehrungs- (inverse telecine) Filter der dritten Generation, der
mixed Hard-telecine- und Progressive-Material mit 24000/1001 und 30000/1001 fps
handhaben kann.
Der Pullup-Filter ist wesentlich robuster als detc oder ivtc, da er
für Entscheidungen zukünftigen Kontext zurate zieht.
Wie ivtc auch ist pullup zustandslos in dem Sinne, dass er nicht nach einem zu
folgenden Muster sucht, sondern stattdessen nach vorne schaut, um Gegenstücke
zu finden und progressive Frames zusammenzusetzen.
Der Filter befindet sich noch in der Entwicklung, scheint aber akkurat zu
arbeiten.
.RSs
.IPs "jl, jr, jt, und jb"
Diese Optionen bestimmen die zu ignorierende Menge "Müll"
links, rechts, oben und unten am Bildrand, respektive.
Links/\:rechts sind in Einheiten von 8 Pixeln anzugeben, oben/\:unten in
Einheiten von 2 Zeilen.
Der Standardwert ist 8 Pixel an jeder Seite.
.br
.IPs "sb (strict breaks)"
Setzen dieser Option auf 1 reduziert die Chancen von pullup,
gelegentlich einen falsch getroffenen Frame zu generieren.
Es kann jedoch auch dazu führen, dass während schnellen bewegten Szenen eine
exzessive Anzahl an Frames ausgelassen wird.
Im Gegensatz dazu führt ein Setzen auf \-1 dazu, dass pullup Felder leichter
zuordnet.
Dies kann helfen beim Verarbeiten von Videomaterial, das zwischen Feldern
leicht verwischt ist, jedoch kann es auch zu interlaced Frames in der Ausgabe
führen.
.br
.IPs "mp (metric plane)"
Diese Option kann auf 1 oder 2 gesetzt werden, um bei den
Berechnungen von pullup eine Chrominanzebene anstelle einer Helligkeitsebene
zu verwenden.
Dies kann die Genauigkeit bei sehr sauberem Quellmaterial verbessern,
vermutlich wird die Qualitätt jedoch verschlechtert, vor allem wenn es sich um
Videomaterial in Graustufen handelt oder Regenbogeneffekte sichbar sind.
Der vorwiegende Zweck vom Setzen von mp auf Chrominanzebene ist, die
CPU-Auslastung zu verringern und pullup in Echtzeit oder auf langsamen
Maschinen zu benutzen.
.REss
.RS
.sp 1
.I ANMERKUNG:
Lasse beim Encodieren auf jede Anwendung von pullup den Filter softskip folgen.
Dies stellt sicher, dass pullup jeden Frame betrachtet.
Falls dies nicht geschieht, führt dies zu einer unkorrekten Ausgabe und wird
auf Grund von Designbeschränkungen auf Codec-/\:Filterebene normalerweise
abbrechen.
.REss
.
.TP
.B filmdint[=Optionen] Inverse telecine-Filter, ähnlich dem Pullup-Filter oben.
Er ist konstruiert, jedes Pulldown-Muster zu handhaben, inklusive mixed soft
und hard telecine sowie begrenzter Unterstützung für Filme, deren
Framerate für die Wiedergabe auf einem Fernseher verringert oder
erhöht worden ist.
Nur die Luminanzebene wird benutzt, um Frameunterbrechungen zu finden.
Falls es zu einem Feld keinen Treffer gibt, wird das Deinterlacing mit einer
einfachen linearen Approximation durchgeführt.
Falls die Quelle aus MPEG-2-Material besteht, muss dieser der erste Filter
sein, um Zugang zu den Feld-Flags zu erlauben, die vom MPEG-2-Decoder gesetzt
werden.
Abhängig von der MPEG-Quelle kannst du diesen Hinweis ignorieren, solange du
keine Warnungen "Bottom-first field" bekommst.
Werden keine Optionen angegeben, bewerkstelligt dieser Filter normales inverse
telecine und sollte zusammen mit mencoder \-fps 30000/1001 \-ofps 24000/1001
benutzt werden.
Wird dieser Filter mit mplayer benutzt wird, kommt es zu unregelmäßigen
Frameraten, aber dies ist im Allgemeinen besser als pp=lb oder gar kein
Deinterlacing zu benutzen.
Es können mehrere Optionen getrennt durch / angegeben werden.
.RSs
.IPs crop=<w>:<h>:<x>:<y>
Genau wie der Filter crop, aber schneller, und er funktioniert auch mit mixed
hard und soft telecined-Inhalten, wenn y kein Vielfaches von 4 ist.
Falls x oder y das Abschneiden von nicht-ganzzahligen Pixeln erfordern würde,
wird die Chrominanzebene erweitert.
Das bedeutet üblicherweise, dass x und y geradzahlig sein müssen.
.IPs io=<ifps>:<ofps>
Für alle ifps Eingabeframes wird der Filter ofps Ausgabeframes liefern.
Das Verhältnis von ifps/\:ofps sollte dem Verhältnis \-fps/\-ofps entsprechen.
Dies könnte benutzt werden, um Filme zu filtern, die auf einem Fernseher mit
einer anderen Framerate als der originalen wiedergegeben werden.
.IPs luma_only=<n>
Ist n ungleich 0, wird die Chrominanzebene unverändert kopiert.
Dies ist nützlich für Fernseher im YV12-Modus, die eine der Chrominanzebenen
wegfallen lassen.
.IPs mmx2=<n>
Auf der x86-Architektur, falls n=1, benutze MMX2-optimierte Funktionen, falls
n=2, benutze 3DNow!-optimierte Funktionen, sonst einfach C.
Wird diese Option nicht angegeben, werden MMX2 und 3DNow! automatisch erkannt.
Benutze diese Option, um die automatische Erkennung zu übergehen.
.IPs fast=<n>
Bei größeren Werten für n wird dies den Filter auf Kosten der Genauigkeit
beschleunigen.
Der Standardwert ist n=3.
Ist n ungerade, so wird ein Frame, der direkt auf einen mit dem
REPEAT_FIRST_FIELD-MPEG-Flag markierten Frame folgt, als progressive angesehen.
Daher wird sich der Filter keinen soft-telecined MPEG-2-Inhalten widmen.
Dies ist der einzige Effekt dieses Flags, falls MMX2 oder 3DNow! verfügbar ist.
Ohne MMX2 und 3DNow! und falls n=0 oder 1, werden dieselben Berechnungen
durchgeführt wie mit n=2 oder 3.
Ist n=2 oder 3, so wird die Anzahl der Helligkeitslevels, die benutzt werden,
um Frameunterbrechungen zu finden, von 256 auf 128 reduziert, was einen
schnelleren Filter zur Folge hat, ohne dabei viel an Genauigkeit zu verlieren.
Ist n=4 oder 5, so wird eine schnellere, aber weniger genauere Metrik benutzt,
um Frameunterbrechungen zu finden, welche dazu neigt, hohe vertikale Details
als interlaced-Inhalte fehlzuinterpretieren.
.IPs verbose=<n>
Falls n von null verschieden ist, gibt dies die detaillierteren Metriken für
jeden Frame aus.
Nützlich für Debugging-Zwecke.
.IPs dint_thres=<n>
Schwellenwert für Deinterlacing.
Wird während des Deinterlacing von nicht zugeordneten Frames benutzt.
Größere Werte bedeuten weniger Deinterlacing; benutze n=256, um Deinterlacing
komplett abzuschalten.
Standardwert ist n=8.
.IPs comb_thres=<n>
Schwellenwert für den Vergleich von top fields und bottom fields.
Standardwert ist 128.
.IPs diff_thres=<n>
Schwellenwert, um die zeitliche Veränderung eines Feldes zu
erkennen.
Standardwert ist 128.
.IPs sad_thres=<n>
Summe des "Absolute Difference"-Schwellenwerts, Standardwert ist 64.
.RE
.
.TP
.B softpulldown
Dieser Filter arbeitet nur mit MEncoder korrekt und richtet sich nach den
MPEG-2-Flags, die für soft 3:2-Pulldown (soft telecine) benutzt werden.
Wenn du einen der Filter ivtc oder detc für Filme benutzen möchtest, die zum
Teil 'soft telecined' sind, sollte er durch das Einfügen dieses Filters
zuverlässiger gemacht werden.
.
.TP
.B divtc[=Optionen]
Inverse telecine für deinterlaced Videos.
Falls 3:2-pulldown telecined Videomaterial eins der Felder verloren hat oder
deinterlaced ist durch ein Verfahren, das ein Feld beibehält und das andere
interpoliert, ist das Ergebnis ein ruckelndes Video, das jeden vierten Frame
doppelt enthält.
Dieser Filter beabsichtigt, diese Duplikate zu finden, zu entfernen und die
ursprüngliche Framerate des Films wiederherzustellen.
Bei Benutzung dieses Filters musst du einen Wert für \-ofps angeben, der 4/5
der Framerate der Eingabedatei entspricht.
Außerdem musst du den Filter softskip an eine spätere Stelle der Filterkette
stellen um sicherzustellen, dass dictc alle Frames sieht.
Es sind zwei verschiedene Modi verfügbar:
Der Modus mit einem Durchlauf ist die Standardeinstellung und sehr einfach zu
benutzen, hat aber den Nachteil, dass alle Änderungen in der telecine-Phase
(verlorengegangene Frames oder schlechte Bearbeitungungen) kurzzeitiges
Ruckeln verursachen, bis der Filter wieder synchronisieren kann.
Der Modus mit zwei Durchläufen vermeidet dies durch Analyse des ganzen Videos
im Voraus, so dass er Phasenänderungen vorher kennt und die Resynchronisierung
an der exakten Stelle durchführen kann.
Diese Durchläufe entsprechen
.B nicht
dem ersten und zweiten Durchlauf des Encodierungsvorgangs.
Du musst einen extra-Durchlauf mit Durchlauf 1 von divtc vor der eigentlichen
Encodierung durchführen, die das resultierende Video verwirft.
Benutze \-nosound \-ovc raw \-o /dev/null, um Verschwendung von CPU-Zeit für
diesen Durchlauf zu vermeiden.
Du kannst außerdem sowas wie crop=2:2:0:0 hinter divtc hinzufügen, um die
Dinge noch etwas weiter zu beschleunigen.
Benutze dann divtc-Durchlauf 2 für die eigentliche Encodierung.
Wenn du mehrere Encoder-Durchläufe machste, benutze divtc-Durchlauf 2 für all
diese.
Die Optionen sind:
.RSs
.IPs pass=1|2
Benutze Modus mit zwei Durchläufen.
.IPs file=<Dateiname>
Setzt den Dateinamen für das Logfile beim Modus mit zwei Durchläufen (Standard:
"framediff.log").
.IPs threshold=<Wert>
Setzt die minimale Stärke, die das telecine-Muster haben muss, damit der Filter
es als solches wahrnimmt (Standard: 0.5).
Dies wird benutzt, um bei sehr dunklen oder fast still stehenden Videos die
Erkennung von falschen Mustern zu vermeiden.
.IPs window=<numframes>
Setzt die Anzahl der vorangegangenen Frames, die bei der Suche nach Mustern
berücksichtigt werden (Standard: 30).
Ein längeres Zeitfenster erhöht die Zuverlässigkeit der Mustersuche, ein
kürzeres Zeitfenster jedoch verbessert die Reaktionszeit für Änderungen in der
telecine-Phase.
Dies betrifft nur den Modus mit einem einzigen Durchlauf.
Der Modus mit zwei Durchläufen benutzt zur Zeit ein festes Zeitfenster, das
nach vorne und
hinten gerichtet ist.
.IPs phase=0|1|2|3|4
Setzt die anfängliche telecine-Phase für den Modus mit einem Durchlauf
(Standard: 0).
Der Modus mit zwei Durchläufen kann in die Zukunft sehen, so dass er von Anfang
an die richtige Phase wählen kann, der Modus mit einem Durchlauf kann nur
raten.
Er erkennt die richtige Phase, wenn er sie findet, aber diese Option kann
genutzt werden, um ein mögliches Haken am Anfang zu korrigieren.
Der erste Durchlauf des Modus mit zwei Durchläufen benutzt dies auch; wenn du
also die
Ausgabe des ersten Durchlaufs speicherst, bekommst du als Ergebnis eine
konstante Phase.
.IPs deghost=<Wert>
Setzt den Schwellenwert für die Entfernung von stark unscharfen
Bildern (Deghosting) (0\-255 für Modus mit einem, \-255\-255 für Modus mit zwei
Durchläufen, Standard: 0).
Ist der Wert ungleich null, wird Deghosting benutzt.
Dies ist für Videomaterial gedacht, das deinterlaced wurde in der Art, dass
die Felder übereinandergelegt wurden anstatt eins von beiden wegzulassen.
Deghosting erhöht Kompressionsartefakte in übereinandergelegten Frames, daher
wird der Parameterwert als Schwellenwert benutzt, um diejenigen Pixel vom
Deghosting auszuschließen, die sich vom vorigen in weniger als dem angegebenen
Wert unterscheiden.
Wird der Modus mit zwei Durchläufen verwendet, so kann ein negativer Wert
benutzt werden,
damit der Filter zu Beginn des zweiten Durchlaufs das ganze Video analysiert
um zu entscheiden, ob Deghosting verwendet werden muss oder nicht.
Der Filter wählt dann entweder null oder den absoluten Wert des Parameters.
Gib diesen Parameter im zweiten Durchlauf an, im ersten bewirkt er keinen
Unterschied.
.RE
.
.TP
.B phase=[t|b|p|a|u|T|B|A|U][:v]
Verzögert interlaced Video um die Zeit eines Feldes, so dass sich die
Reihenfolge der Felder ändert.
Die Absicht ist, Videos im PAL-Format zu korrigieren, die bei der Umsetzung
von Film zu Video mit umgekehrter Feldreihenfolge aufgenommen wurden.
Die Optionen sind:
.RSs
.IPs t
Nimm die Feldreihenfolge top-first, transferiere dabei bottom-first.
Der Filter verzögert das untere (bottom) Feld.
.IPs b
Nimm die Feldreihenfolge bottom-first, transferiere dabei top-first.
Der Filter verzögert das obere (top) Feld.
.IPs p
Nimm auf und transferiere mit derselben Feldreihenfolge.
Dieser Modus existiert nur als Referenz zur Dokumentation anderer Optionen;
falls du es trotzdem auswählst, wird der Filter guten Gewissens nichts tun ;-)
.IPs a
Nimm die Feldreihenfolge, die durch die Flags der Felder automatisch bestimmt
werden und transferiere die andere.
Der Filter wählt einen der Modi t und b Frame für Frame aus unter Zuhilfenahme
der Feld-Flags.
Ist keine Feldinformation verfügbar, arbeitet er wie bei Angabe von u.
.IPs u
Nimm unbekannte oder variable, transferiere die andere Feldreihenfolge.
Der Filter wählt einen der Modi t und b Frame für Frame aus durch Analyse der
Bilder und sucht diejenige Alternative mit dem besten Treffer zwischen den
Feldern aus.
.IPs T
Nimm die Feldreihenfolge top-first, transferiere unbekannte oder variable.
Der Filter wählt einen der Modi t und p nach Analyse der Bilder.
.IPs B
Nimm die Feldreihenfolge bottom-first, transferiere unbekannte oder variable.
Der Filter wählt einen der Modi b und p nach Analyse der Bilder.
.IPs A
Nimm die durch Feld-Flags bestimmte Feldreihenfolge, transferiere
unbekannte oder variable.
Der Filter wählt einen der Modi t und p nach Analyse der Felder und Bilder.
Ist keine Feldinformation verfügbar, arbeitet der Filter wie Angabe von U.
Dies ist der Standardmodus.
.IPs U
Nimm auf und transferiere unbekannte oder variable Feldreihenfolge.
Der Filter wählt einen der Modi t, b oder p nur anhand der Bildanalyse.
.IPs v
Ausführliche Vorgehensweise.
Gibt den ausgewählten Modus für jeden Frame sowie die gemittelte quadrierte
Differenz der Felder für die Auswahlen von t, b und p aus.
.RE
.
.TP
.B telecine[=Start]
Wende 3:2 'telecine'-Prozess an, um die Framerate um 20% zu erhöhen.
Dies funktioniert mit MPlayer vermutlich nicht korrekt, kann jedoch in
Verbindung mit 'mencoder \-fps 30000/1001 \-ofps 30000/1001 \-vf telecine'
benutzt werden.
Beide fps-Optionen müssen angegeben werden!
(A/V-Synchronisation wird verlorengehen, wenn sie falsch sind.)
Der optionale Parameter Start bestimmt, wo im telecine-Muster zu beginnen ist
(0\-3).
.
.TP
.B tinterlace[=Modus]
Temporäres Interlacing der Felder \- verschmelze Paare von Frames in einen
Frame, halbiere dabei die Framerate.
Geradzahlige Frames werden in das obere Feld verschoben, ungerade in das
untere Feld.
Dies kann benutzt werden, um den Effekt des Filters tfields (im Modus 0)
komplett umzukehren.
Verfügbare Modi sind:
.PD 0
.RSs
.IPs 0
Verschiebe ungerade Frames in das obere Feld, geradzahlige in das untere.
Dies generiert einen Frame voller Höhe bei halbierter Framerate.
.IPs 1
Gib nur ungerade Frames aus, geradzahlige werden weggelassen; die Höhe bleibt
unverändert.
.IPs 2
Gib nur geradzahlige Frames aus, ungerade werden weggelassen; die Höhe bleibt
unverändert.
.IPs 3
Expandiere jeden Frame zu voller Höhe, aber fülle alternierende Zeilen
schwarz; die Framerate bleibt unverändert.
.IPs 4
Verschachtele gerade Zeilen von geraden Frames mit ungeraden Zeilen von
ungeraden Frames.
Die Höhe bleibt ungeändert bei halber Framerate.
.RE
.PD 1
.
.TP
.B tfields[=Modusi[:Feld_Dominanz]]
Temporäre Auftrennung der Felder \- trenne die Felder in ganze Frames auf;
dies verdoppelt die Framerate.
Genau wie beim Filter telecine wird tfields nur bei MEncoder korrekt arbeiten,
und nur dann, wenn sowohl \-fps als auch \-ofps mit der gewünschten (doppelten)
Framerate angegeben werden!
.PD 0
.RSs
.IPs <Modus>
0: Lasse die Felder unangetastet (wird zu Sprüngen/\:Flackern führen).
.br
1: Interpoliere fehlende Zeilen. (Der benutzte Algorithmus ist möglicherweise
nicht allzu gut.)
.br
2: Wandle Felder mit linearer Interpolation zu 1/4 Pixel um (kein Sprung).
.br
4: Wandle Felder mit dem 4tap-Filter zu 1/4 Pixel um (höhere Qualität) (Standard).
.IPs <Feld_Dominanz>\ (VERALTET)
\-1: automatisch (Standard)
Funktioniert nur, wenn der Decoder angemessene Informationen ausgibt und keine
anderen Filter in der Filterkette vor tfields kommen, die diese Informationen
verwefen; sonst fällt der Filter zurück auf 0 (obere Felder zuerst).
.br
0: obere Felder zuerst
.br
1: untere Felder zuerst
.br
.I ANMERKUNG:
Diese Option wird in einer zukünftigen Version vermutlich entfernt.
Benutze stattdessen \-field\-dominance.
.RE
.PD 1
.
.TP
.B yadif=[Modus[:Felddominanz]]
Noch ein Deinterlacing-Filter
.PD 0
.RSs
.IPs <Modus>
0: Gib 1 Frame für jeden Frame aus.
.br
1: Gib 1 Frame für jedes Feld aus.
.br
2: Wie 0, überspringt aber die Überprüfung für räumliches Interlacing.
.br
3: Wie 1, überspringt aber die Überprüfung für räumliches Interlacing.
.IPs <Felddominanz>\ (VERALTET)
Arbeitet wie tfields.
.br
.I ANMERKUNG:
Diese Option wird in einer zukünftigen Version vermutlich entfernt.
Benutze stattdessen \-field\-dominance.
.RE
.PD 1
.
.TP
.B mcdeint=[Modus[:Parität[:QP]]]
Bewegungskompensierender Deinterlacer.
Dieser benötigt ein Feld pro Frame als Input und muss daher zusammen mit
tfields=1 oder yadif=1/3 oder einem Äquivalent verwendet werden.
.PD 0
.RSs
.IPs <Modus>
0: schnell
.br
1: mittel
.br
2: langsam, iterative Bewegungsabschätzung
.br
3: besonders langsam, wie 2 plus mehrere Referenzframes
.IPs <Parität>
0 oder 1 bestimmt, welches Feld verwendet wird (Beachte: bisher keine
automatische Erkennung!).
.IPs "<QP>\ "
Höhere Werte sollten zu einem weicheren Bewegungsvektorfeld aber weniger
optimalen individuellen Vektoren führen.
.RE
.PD 1
.
.TP
.B "boxblur=Radius:Stärke[:Radius:Stärke]"
Kastenunschärfe
.PD 0
.RSs
.IPs <Radius>
Stärke des Unschärfefilters
.IPs <Stärke>
Anzahl der Anwendungen des Filters
.RE
.PD 1
.
.TP
.B sab=Radius:pf:colorDiff[:Radius:pf:colorDiff]
umrissabhängige Glättung/Unschärfe (shape adaptive blur)
.PD 0
.RSs
.IPs <Radius>
Stärke des Glättungsfilters (~0.1\-4.0) (je größer desto langsamer)
.IPs "<pf>\ "
Stärke der Vorfilterung (~0.1\-2.0)
.IPs <colorDiff>
maximale Differenz zwischen Pixeln, damit diese betrachtet werden
(~0.1\-100.0)
.RE
.PD 1
.
.TP
.B smartblur=Radius:Stärke:Schwellenwert[:Radius:Stärke:Schwellenwert]
intelligente Glättung
.PD 0
.RSs
.IPs <Radius>
Stärke des Glättungsfilters (~0.1\-5.0) (je größer desto langsamer)
.IPs <Stärke>
glätten (0.0\-1.0) oder schärfen (\-1.0\-0.0)
.IPs <Schwellenwert>
Filterung von allem (0), nur gleichförmigen Bereichen (0\-30) oder nur Kanten
(\-30\-0)
.RE
.PD 1
.
.TP
.B perspective=x0:y0:x1:y1:x2:y2:x3:y3:t
Korrigiere die Perspektive von Filmen, die nicht lotrecht zum Bildschirm
gefilmt wurden.
.PD 0
.RSs
.IPs <x0>,<y0>,...
Koordinaten der Ecken links oben, rechts oben, links unten, rechts unten
.IPs "<t>\ \ "
lineare (0) oder kubische (1) Neuberechnung
.RE
.PD 1
.
.TP
.B "2xsai\ \ "
Benutzt den 2x-Skalier- und Interpolationsalgorithmus für die Skalierung
und Glättung des Bildes.
.
.TP
.B "1bpp\ \ \ "
Konvertierung von 1bpp-Bitmaps nach YUV/\:BGR 8/\:15/\:16/\:32
.
.TP
.B down3dright[=Zeilen]
Positioniert stereoskopische Bilder neu und ändert deren Größe.
Extrahiert beide Stereofelder und setzt sie nebeneinander.
Dabei wird die Größe so geändert, dass das ursprüngliche Größenverhältnis
beibehalten wird.
.PD 0
.RSs
.IPs <Zeilen>
Anzahl der Zeilen, die von der Mitte des Bildes ausgewählt werden sollen
(Standard: 12)
.RE
.PD 1
.
.TP
.B bmovl=versteckt:opak:fifo
Der Bitmap-Overlay-Filter liest Bitmaps von einem FIFO und zeigt sie oberhalb
des Filmfensters an, was ein paar Transformationen der Bilder erlaubt.
Ein kleines Testprogramm findest du in TOOLS/\:bmovl-test.c.
.PD 0
.RSs
.IPs <versteckt>
Setzt den Standardwert des 'hidden'-Flags (0=sichtbar, 1=unsichtbar).
.IPs <opak>
Setzt den Standardwert des 'opak'-Flags (0=transparent, 1=opak).
.IPs <fifo>
Pfad und Dateiname des FIFOs (eine named pipe, die 'mplayer \-vf bmovl'
mit der kontrollierenden Anwendung verknüpft).
.RE
.PD 1
.sp 1
.RS
Die FIFO-Kommandos sind folgende:
.RE
.PD 0
.RSs
.IPs "RGBA32 Breite Höhe xpos ypos alpha clear"
gefolgt von Breite*Höhe*4 Bytes raw-RGBA32-Daten.
.IPs "ABGR32 Breite Höhe xpos ypos alpha clear"
gefolgt von Breite*Höhe*4 Bytes raw-ABGR32-Daten.
.IPs "RGB24 Breite Höhe xpos ypos alpha clear"
gefolgt von Breite*Höhe*3 Bytes raw-RGB32-Daten.
.IPs "BGR24 Breite Höhe xpos ypos alpha clear"
gefolgt von Breite*Höhe*3 bytes raw-BGR32-Daten.
.IPs "ALPHA Breite Höhe xpos ypos alpha"
Ändert die Alpha-Transparenz für den angegebenen Bereich.
.IPs "CLEAR Breite Höhe xpos ypos"
Löscht den Bereich.
.IPs OPAQUE
Deaktiviert die Alpha-Transparenz.
Schicke "ALPHA 0 0 0 0 0" an den FIFO, um sie wieder zu aktivieren.
.IPs "HIDE\ "
Versteckt die Bitmap.
.IPs "SHOW\ "
Zeigt die Bitmap an.
.RE
.PD 1
.sp 1
.RS
Die Argumente sind folgende:
.RE
.PD 0
.RSs
.IPs "<Breite>, <Höhe>"
Größe des Bildes/Bereiches.
.IPs "<xpos>, <ypos>"
Starte bei Position x/y.
.IPs <alpha>
Setzt die Alpha-Differenz.
Wenn du den Wert auf \-255 setzt, dann kannst du mit einer Sequenz von
ALPHA-Kommandos den Bereich auf \-225, \-200, \-175 etc.\& setzen, um einen netten
Fade-In-Effekt zu erzielen! ;)
.RSss
0:    genau wie bei der Vorlage.
.br
255:  Bedecke alles.
.br
\-255: Mache alles transparent.
.REss
.IPs <clear>
Lösche den Framebuffer vor dem "Blitting".
.RSss
0: Das Blitting eines Bildes wird nur über dem vorigen (darunterliegenden)
angewendet, daher brauchst du nicht jedesmal, wenn ein kleiner Teil des
Bildschirms aktualisiert wird, 1,8MB RGBA32-Daten an den FIFO schicken.
.br
1: löschen
.REss
.RE
.PD 1
.
.TP
.B framestep=I|[i]step
Rendert nur jeden n-ten Frame oder jeden Intra-Frame (Keyframe).
.sp 1
Rufst du den Filter mit groß geschriebenem I als Parameter auf, so werden
.B nur
Keyframes gerendert.
Für DVDs bedeutet dies im Allgemeinen, dass nur einer von 15/12
(IBBPBBPBBPBBPBB) Frames dargestellt wird, bei AVIs wirkt diese Option bei
jedem Szenenwechsel oder jedem keyint-Wert (siehe \-lavcopts keyint=Wert,
falls du MEncoder zum Encodieren des Videos benutzt).
.sp 1
Wird ein Keyframe gefunden, so wird ein 'I!' gefolgt von einem Zeilenumbruch
ausgegeben, wobei die aktuelle Zeile der Ausgabe von MPlayer/\:MEncoder
auf dem Bildschirm bleibt, da sie die Zeit (in Sekunden) und die
Framenummer des Keyframes enthält.
(Du kannst diese Angabe benutzen, um ein AVI korrekt zu splitten.)
.sp 1
Rufst du den Filter mit einem numerischen Parameter 'step' auf, so wird nur
ein Frame von 'step' vielen angezeigt.
.sp 1
Setzt du ein klein geschriebenes 'i' vor diese Nummer, so wird 'I!' angezeigt
(wie beim Parameter I).
.sp 1
Gibst du nur das i an, so passiert nichts mit den Frames, aber es wird
ein 'I!' für jeden Keyframe ausgegeben.
.
.TP
.B tile=xtiles:ytiles:Ausgabe:Start:delta
Kachelt eine Reihe von Bildern zu einem größeren Bild.
Lässt du einen Parameter weg oder benutzt einen Wert kleiner als 0, so wird
der Standardwert benutzt.
Du kannst auch aufhören, wenn du zufrieden bist (... \-vf tile=10:5 ...).
Es ist vermutlich eine gute Idee, den Filter scale vor das Kacheln zu
setzen :-)
.sp 1
Die Parameter sind folgende:
.sp 1
.PD 0
.RSs
.IPs <xtiles>
Anzahl der Kacheln auf der X-Achse (Standard: 5)
.IPs <ytiles>
Anzahl der Kacheln auf der Y-Achse (Standard: 5)
.IPs <Ausgabe>
Stelle die Kacheln erst dann dar, wenn <Ausgabe> viele Frames erreicht sind,
wobei <Ausgabe> eine Zahl sein sollte, die kleiner ist als xtile * ytile.
Fehlende Kacheln werden leer gelassen.
Du könntest zum Beispiel nach jeden 50 Frames alle 2 Sekunden bei 25 fps
ein 8 * 7 Kacheln großes Bild erstellen.
.IPs <Start>
Dicke des äußeren Rahmens in Pixeln (Standard: 2)
.IPs <delta>
Dicke des inneren Rahmens in Pixeln (Standard: 4)
.RE
.PD 1
.
.TP
.B delogo[=x:y:b:h:t]
Unterdrückt das Logo eines Fernsehsenders durch einfache Interpolation der
umgebenden Pixel.
Setze einfach ein Rechteck, das das Logo bedeckt, und sieh zu, wie es
verschwindet (und manchmal etwas unschöneres entsteht \- deine Erfahrungen
können variieren).
.PD 0
.RSs
.IPs <x>,<y>
die linke obere Ecke des Logos
.IPs <b>,<h>
Breite und Höhe des bereinigten Rechtecks
.IPs <t>
Dicke des fließenden Übergangs des Rechtecks zum Rest (wird zur Breite und
Höhe addiert).
Auf \-1 gesetzt wird ein grünes Rechteck auf den Bildschirm gezeichnet, um das
Finden der richtigen Parameter für x,y,w und h zu erleichtern.
.RE
.PD 1
.
.TP
.B remove-logo=/pfad/zur/logo_bitmap_datei.pgm
Unterdrückt das Senderlogo unter Benutzung des angegebenen PGM- oder PPM-Bildes
um herauszufinden, welche Bildpunkte das Logo umfassen.
Die Breite und Höhe des Bildes muss denen des zu bearbeitenden Videos
entsprechen.
Benutzt das Bild und einen runden Weichzeichnungsalgorithmus, um das Logo zu
entfernen.
.RSs
.IPs /pfad/zur/logo_bitmap_datei.pgm
[Pfad] + Dateiname des Filterbildes.
.RE
.
.TP
.B zrmjpeg[=Optionen]
Software-Encoder von YV12 nach MJPEG für die Benutzung des
zr2-Videoausgabetreibers.
.RSs
.IPs maxheight=<h>|maxwidth=<b>
Diese Optionen setzen die maximale Breite und Höhe, die die zr-Karte handhaben
kann (die Filterschicht von MPlayer kann diese momentan nicht abfragen).
.IPs {dc10+,dc10,buz,lml33}-{PAL|NTSC}
Benutze diese Option, um die Werte für maxwidth und maxheight bei einer
bekannten Kombination für Karte/Modus automatisch zu setzen.
Gültige Optionen sind zum Beispiel dc10-PAL und buz-NTSC (Standard: dc10+PAL).
.IPs color|bw
Setze Encodierung auf Farbe oder schwarz/weiß.
Schwarz/weiß-Encodierung ist schneller.
Encodierung in Farbe ist Standard.
.IPs hdec={1,2,4}
Horizontale Dezimierung 1, 2 oder 4.
.IPs vdec={1,2,4}
Vertikale Dezimierung 1, 2 oder 4.
.IPs quality=1\-20
Setze Kompressionsqualität für JPEG [BESTE] 1 \- 20 [SEHR SCHLECHT].
.IPs fd|nofd
Der Standard ist, dass die Dezimierung nur dann durchgeführt wird, wenn die
Zoran Hardware die erzeugten MJPEG-Bilder auf die originale Größe
hochskalieren kann.
Die Option fd weist den Filter an, die geforderte Skalierung immer auszuführen
(hässlich).
.RE
.
.TP
.B screenshot=Präfix
Erlaubt das Erstellen von Schnappschüssen des Videos mit Hilfe
von Slave-Kommandos, die an Tasten gebunden werden können.
Siehe Dokumentation des Slave-Modus und den Abschnitt INTERAKTIVE STEUERUNG
für Details.
Standardmäßig werden Dateien mit dem Namen 'shotNNNN.png' im aktuellen Verzeichnis
abgelegt, NNNN entspricht hierbei der ersten verfügbaren Nummer \- keine Datei
wird überschrieben.
Durch Angabe eines Präfixes lassen sich Name und Verzeichnis ändern, so
werden z. B. mit \-vf screenshot=shots/now Dateien mit Namen nowNNNN.png im
Verzeichnis shots abgelegt.
Der Filter führt zu keiner Mehrbelastung, solange er nicht benutzt wird und
akzeptiert beliebige Farbräume, es ist also ungefährlich ihn in die
Konfigurationsdatei mit aufzunehmen.
.RE
.
.TP
.B "ass\ \ \ \ "
Verschiebt das Zeichnen der SSA/ASS-Untertitel an einen beliebigen Punkt in der
Videofilterkette.
Nur sinnvoll mit der Option \-ass.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-vf ass,screenshot"
Verschiebt das Rendern von SSA/ASS vor den Filter screenshot.
Auf diese Weise geschossene Schnappschüsse werden die Untertitel enthalten.
.RE
.PD 1
.
.TP
.B blackframe[=Menge:Schwellenwert]
Erkenne Frames, die (fast) komplett schwarz sind.
Kann nützlich sein, um Kapitelübergänge oder Werbung zu erkennen.
Ausgabezeilen bestehen aus der Framenummer des erkannten Frames, dem
prozentualen Schwarzanteil, dem Frametyp und der Framenummer des zuletzt
vorgekommenen Keyframes.
.RSs
.IPs <Menge>
Prozentaler Anteil der Pixel, die unter dem Schwellenwert liegen müssen
(Standard: 98).
.IPs <Schwellenwert>
Schwellenwert, unter dem ein Pixelwert als schwarz angenommen wird
(Standard: 32).
.RE
.PD 1
.
.TP
.B stereo3d[=in:out]
Stereo3d wandelt zwischen verschiedenen stereoskopischen Bildformaten um.
.RSs
.IPs <in>
Stereoskopisches Eingabeformat. MÃ¶gliche Werte:
.RS
.B sbsl oder side_by_side_left_first
.RS
nebeneinander parallel (linkes Auge links, rechtes Auge rechts)
.RE
.B sbsr oder side_by_side_right_first
.RS
nebeneinander gekreuzt (rechtes Auge links, linkes Auge rechts)
.RE
.B abl oder above_below_left_first
.RS
oben-unten (linkes Auge oben, rechtes Auge unten)
.RE
.B abl oder above_below_right_first
.RS
oben-unten (rechtes Auge oben, linkes Auge unten)
.RE
.B ab2l oder above_below_half_height_left_first
.RS
oben-unten mit halber HÃ¶henauflÃ¶sung (linkes Auge oben, rechtes Auge unten)
.RE
.B ab2r oder above_below_half_height_right_first
.RS
oben-unten mit halber HÃ¶henauflÃ¶sung (rechtes Auge oben, linkes Auge unten)
.RE
.RE
.IPs <out>
Stereoskopisches Ausgabeformat. MÃ¶gliche Werte sind alle Eingabeformate, sowie:
.RS
.B arcg oder anaglyph_red_cyan_gray
.RS
anaglyph rot/cyan grau (roter Filter auf dem linken Auge, cyan Filter auf dem
rechten Auge)
.RE
.B arch oder anaglyph_red_cyan_half_color
.RS
anaglyph rot/cyan halbfarbig (roter Filter auf dem linken Auge, cyan Filter auf
dem rechten Auge)
.RE
.B arcc oder anaglyph_red_cyan_color
.RS
anaglyph rot/cyan farbig (roter Filter auf dem linken Auge, cyan Filter auf dem
rechten Auge)
.RE
.B arcd oder anaglyph_red_cyan_dubios
.RS
anaglyph red/cyan farbig optimiert mit der Least-Squares-Projektion von Dubois
(roter Filter auf dem linken Auge, cyan Filter auf dem rechten Auge)
.RE
.B agmg oder anaglyph_green_magenta_gray
.RS
anaglyph grÃ¼n/magenta grau (grÃ¼ner Filter auf dem linken Auge, magenta Filter
auf dem rechten Auge)
.RE
.B agmh oder anaglyph_green_magenta_half_color
.RS
anaglyph grÃ¼n/magenta halbfarbig (grÃ¼ner Filter auf dem linken Auge, magenta
Filter auf dem rechten Auge)
.RE
.B agmc oder anaglyph_green_magenta_color
.RS
anaglyph grÃ¼n/magenta farbig (grÃ¼ner Filter auf dem linken Auge, magenta Filter
auf dem rechten Auge)
.RE
.B aybg oder anaglyph_yellow_blue_gray
.RS
anaglyph gelb/blau grau (gelber Filter auf dem linken Auge, blauer Filter auf
dem rechten Auge)
.RE
.B aybh oder anaglyph_yellow_blue_half_color
.RS
anaglyph gelb/blau halbfarbig (gelber Filter auf dem linken Auge, blauer Filter
auf dem rechten Auge)
.RE
.B aybc oder anaglyph_yellow_blue_color
.RS
anaglyph gelb/blau farbig (gelber Filter auf dem linken Auge, blauer Filter auf
dem rechten Auge)
.RE
.B ml oder mono_left
.RS
mono Ausgabe (nur linkes Auge)
.RE
.B mr oder mono_right
.RS
mono Ausgabe (nur rechtes Auge)
.RE
.RE
.RE
.
.
.
.SH "ALLGEMEINE ENCODING-OPTIONEN (NUR BEI MENCODER)"
.
.TP
.B \-audio\-delay <beliebige Fließkommazahl>
Verzögert entweder Audio oder Video durch Setzen eines Verzögerungsfeldes im
Dateikopf (Standard: 0.0).
Dies wird bei der Encodierung keinen der beiden Streams verzögern, der Player
jedoch wird das Verzögerungsfeld beachten und kompensieren.
Positive Werte verzögern den Ton und negative Werte verzögern das Video.
Beachte, dass diese Option das genaue Gegenstück zur Option \-delay ist.
Zum Beispiel, wenn ein Video korrekt abgespielt wird mit \-delay 0.2, kannst
Du das Video mit MEncoder reparieren, indem du \-audio\-delay \-0.2 verwendest.
Momentan funktioniert diese Option nur mit dem Standardmuxer (\-of avi).
Wenn du einen anderen Muxer benutzt, musst du stattdessen \-delay verwenden.
.
.TP
.B \-audio\-density <1\-50>
Anzahl der Audioblöcke pro Sekunde (Standard ist 2, was in 0.5s langen
Audioblöcken resultiert).
.br
.I ANMERKUNG:
Nur bei CBR (konstanter Bitrate), VBR (variable Bitrate) dagegen ignoriert
diese Einstellung, da jedes Paket in einen eigenen Block kommt.
.
.TP
.B \-audio\-preload <0.0\-2.0>
Setzt das Audiopuffer-Zeitintervall (Standard: 0.5s).
.
.TP
.B \-fafmttag <format>
Hiermit kann die Audioformat-Kennzeichnung der Ausgabedatei überschrieben werden.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-fafmttag 0x55"
Legt fest, dass die Ausgabedatei die Kennzeichnung 0x55 (mp3) enthält.
.RE
.PD 1
.
.TP
.B \-ffourcc <fourcc>
Hiermit kann das FourCC-Feld der Ausgabedatei überschrieben werden.
.sp
.I BEISPIEL:
.PD 0
.RSs
.IPs "-ffourcc div3"
Legt fest, dass die Ausgabedatei als FourCC-Feld 'div3' enthält.
.RE
.PD 1
.
.TP
.B \-force\-avi\-aspect <0.2\-3.0>
Überschreibe den Aspekt, der im AVI-OpenDML-vprp-Header gespeichert ist.
Dies kann benutzt werden, um den Aspekt mit '\-ovc copy' zu ändern.
.
.TP
.B \-frameno\-file <Dateiname> (VERALTET)
Gibt die Audiodatei an, in der die Zuweisungen der Framenummern stehen, die im
ersten (nur Audio-) Durchlauf in einem speziellen Modus mit drei Durchläufen
erstellt wurden.
.br
.I ANMERKUNG:
Die Benutzung dieses Modus wird höchstwahrscheinlich die
Audio-/\:Video-Synchronisation zerstören.
Benutze diesen Modus nicht.
Er wird nur aus Gründen der Rückwärtskompatibilität behalten und in einer
zukünftigen Version vermutlich entfernt.
.
.TP
.B \-hr\-edl\-seek
Benutze eine präzisere, jedoch wesentlich langsamere Methode, Bereiche zu
überspringen.
Bereiche, die markiert sind, übersprungen zu werden, werden nicht direkt
übergangen, sondern es werden alle Frames decodiert, aber nur die benötigten
Frames werden encodiert.
Dies erlaubt das Starten in Bereichen zwischen Keyframes.
.br
.I ANMERKUNG:
Es ist nicht garantiert, dass dies mit der Option '\-ovc copy' funktioniert.
.
.TP
.B \-info <Option1:Option2:...> (nur bei AVIs)
Gibt die Werte für den Info-Dateikopf der resultierenden AVI-Datei an.
.sp 1
Die verfügbaren Optionen sind:
.RSs
.IPs "help\ "
Zeigt diese Beschreibung.
.IPs name=<Wert>
Titel des Films
.IPs artist=<Wert>
Künstler oder Autor des Films
.IPs genre=<Wert>
Kategorie des Films
.IPs subject=<Wert>
Inhalte der Datei
.IPs copyright=<Wert>
Copyright-Informationen
.IPs srcform=<Wert>
Urpsrungsform des digitalisierten Materials
.IPs comment=<Wert>
allgemeine Kommentare über den Film
.RE
.
.TP
.B \-noautoexpand
Füge den Filter expand nicht automatisch in die Filterkette von MEncoder ein.
Nützlich, um zu kontrollieren, an welcher Stelle der Filterkette die Untertitel
dargestellt werden, falls Untertitel fest in den Film eincodiert werden.
.
.TP
.B \-noencodedups
Versuche nicht, doppelte Frames doppelt zu encodieren; gib immer
Zero-byte-Frames aus, um Duplikate anzudeuten.
Zero-byte-Frames werden sowieso geschrieben, solange kein Filter oder
Encoder geladen wird, der in der Lage ist, doppelte Frames zu encodieren.
Zur Zeit ist der einzige solche Filter harddup.
.
.TP
.B \-noodml (nur bei \-of AVI)
Schreibe keinen OpenDML-Index für AVI-Dateien >1GB.
.
.TP
.B \-noskip
Verwirf keine Bilder.
.
.TP
.B \-o <Dateiname>
Schreibt in die angegebene Datei.
.br
Falls ein Standarddateiname benutzt werden soll, kann diese Option in die
MEncoder-Konfigurationsdatei geschrieben werden.
.
.TP
.B \-oac <Codecname>
Encodiere Audio mit dem angegebenen Audiocodec (kein Standardwert vorhanden).
.br
.I ANMERKUNG:
\-oac help liefert eine Liste der verfügbaren Audiocodecs.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "-oac copy"
kein Encodieren, nur eine Kopie des Streams
.IPs "-oac pcm"
Encodiere zu unkomprimiertem PCM.
.IPs "-oac mp3lame"
Encodiere zu MP3 (benutzt LAME).
.IPs "\-oac lavc"
Encodiere mit dem libavcodec Codec.
.RE
.PD 1
.
.TP
.B \-of <Format> (BETA\-CODE!)
Gib in das angegebene Containerformat aus (Standard: AVI).
.br
.I ANMERKUNG:
Mit \-of help bekommst du eine Liste vorhandener Containerformate.
.sp 1
.I BEISPIELE:
.PD 0
.RSs
.IPs "\-of avi"
Encodiere zu AVI.
.IPs "\-of mpeg"
Encodiere zu MPEG (siehe auch \-mpegopts).
.IPs "\-of lavf"
Encodiere mit den Muxern von libavcodec (siehe auch \-lavfopts).
.IPs "\-of rawvideo"
reiner (raw) Videostream (kein Muxing \- nur ein Videostream)
.IPs "\-of rawaudio"
reiner (raw) Audiostream (kein Muxing \- nur ein Audiostream)
.RE
.PD 1
.
.TP
.B \-ofps <fps>
Setzt die Anzahl der Bilder pro Sekunde (fps) für die Ausgabedatei, die
unterschiedlich zu der der Quelldatei sein kann.
Diese Option muss gesetzt werden, wenn eine Quelldatei mit
variabler Framerate (ASF, einige MOV) oder ein progressiver (30000/1001
fps telecined MPEG) Film encodiert wird.
.
.TP
.B \-ovc <Codecname>
Encodiere Video mit dem angegebenen Codec (kein Standardwert gesetzt).
.br
.I ANMERKUNG:
Mit \-ovc help erhältst du eine Liste verfügbarer Codecs.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-ovc copy"
kein Encodieren, sondern nur eine Kopie des Videostreams
.IPs "\-ovc raw"
Encodiere zu einem frei wählbaren Format (benutze '\-vf format', um dieses
auszuwählen).
.IPs "\-ovc lavc"
Encodiere mit einem libavcodec Codec.
.RE
.PD 1
.
.TP
.B \-passlogfile <Dateiname>
Schreibe die Informationen des ersten Durchlaufs anstelle der Standarddatei
divx2pass.log in die angegebene Datei.
.
.TP
.B \-skiplimit <Wert>
Gibt die maximale Anzahl ausgelassener Bilder nach einem encodierten Frame an
(mit \-noskiplimit gibt es ein solches Limit nicht).
.
.TP
.B \-vobsubout <Basisname>
Gibt den Basisnamen für die Ausgabe der .idx- und .sub-Dateien an.
Damit wird das Rendern der Untertitel im encodierten Film deaktiviert, und
die Untertitel werden statt dessen in eine VOBsub-Untertiteldatei umgeleitet.
.
.TP
.B \-vobsuboutid <Sprach-ID>
Gibt den zweibuchstabigen Sprachcode für die Untertitel an.
Dieser Wert überschreibt, was von der DVD oder der .ifo-Datei gelesen wurde.
.
.TP
.B \-vobsuboutindex <Index>
Gibt den Index der VOBsub-Untertitel in den Ausgabedateien an (Standardwert:
0).
.
.
.
.SH "CODEC-SPEZIFISCHE ENCODING-OPTIONEN (NUR BEI MENCODER)"
Für die Encodierung kannst du Codec-spezifische Parameter angeben, indem du
folgende Syntax benutzt:
.
.TP
.B \-<codec>opts <Option1[=Wert1]:Option2[=Wert2]:...>
.
.PP
Wobei <Codec> einer der folgenden sein kann: lavc, xvidenc, mp3lame,
toolame, twolame, nuv, xvfw, faac, x264enc, mpeg und lavf.
.
.
.SS mp3lame (\-lameopts)
.
.TP
.B "help\ \ \ "
Liefert einen Hilfstext.
.
.TP
.B vbr=<0\-4>
zu verwendender Bitratenmodus
.PD 0
.RSs
.IPs 0
cbr
.IPs 1
mt
.IPs 2
rh (default)
.IPs 3
abr
.IPs 4
mtrh
.RE
.PD 1
.
.TP
.B "abr\ \ \ \ "
durchschnittliche (average) Bitrate
.
.TP
.B "cbr\ \ \ \ "
konstante Bitrate
Dies erzwingt den CBR-Modus auch bei nachfolgenden Modi mit ABR-Presets.
.
.TP
.B br=<0\-1024>
Bitrate in kBit/s (nur bei CBR und ABR)
.
.TP
.B q=<0\-9>
Qualität (0 \- höchste, 9 \- niedrigste) (nur bei VBR)
.
.TP
.B aq=<0\-9>
Qualität des Algorithmus (0 \- am besten/\:langsamsten, 9 \- am
schlechtesten/\:schnellsten)
.
.TP
.B ratio=<1\-100>
Kompressionsverhältnis
.
.TP
.B vol=<0\-10>
Audioeingangsverstärkung
.
.TP
.B mode=<0\-3>
(Standard: automatisch)
.PD 0
.RSs
.IPs 0
Stereo
.IPs 1
Joint-Stereo
.IPs 2
Dual-Channel
.IPs 3
Mono
.RE
.PD 1
.
.TP
.B padding=<0\-2>
.PD 0
.RSs
.IPs 0
kein Padding
.IPs 1
alles
.IPs 2
automatische Anpassung
.RE
.PD 1
.
.TP
.B "fast\ \ \ "
Aktiviert schnelles Encodieren bei nachfolgenden Modi mit VBR-Presets.
Führt zu leicht schlechterer Qualität und höheren Bitraten.
.
.TP
.B highpassfreq=<Frequenz>
Setzt die Frequenz für Highpass-Filterung in Hz.
Frequenzen unterhalb der angegebenen werden abgeschnitten.
Ein Wert von \-1 deaktiviert die Filterung, ein Wert von 0 lässt LAME die Werte
für die Frequenz automatisch wählen.
.
.TP
.B lowpassfreq=<Frequenz>
Setzt die Frequenz für Lowpass-Filterung in Hz.
Frequenzen oberhalb der angegebenen werden abgeschnitten.
Ein Wert von \-1 deaktiviert die Filterung, ein Wert von 0 lässt LAME die Werte
für die Frequenz automatisch wählen.
.
.TP
.B preset=<Wert>
Werte für verschiedene Presets
.RSs
.IPs "help\ "
Gibt Informationen über die Presets und über weitere Optionen aus.
.IPs medium
VBR-Encodierung, gute Qualität, Bitrate im Rahmen von ca. 150\-180 kBit/s
.IPs standard
VBR-Encodierung, hohe Qualität, Bitrate im Rahmen von ca. 170\-210 kBit/s
.IPs extreme
VBR-Encodierung, sehr hohe Qualität, Bitrate im Rahmen von ca. 200\-240 kBit/s
.IPs instane
CBR-Encodierung, Preset mit der besten Qualität, Bitrate 320 kBit/s
.IPs <8\-320>
ABR-Encodierung mit der gegebenen Bitrate im Mittel
.RE
.sp 1
.RS
.I BEISPIELE:
.RE
.PD 0
.RSs
.IPs fast:preset=standard
Für die meisten Leute reicht das aus und bietet schon ziemlich gute Qualität.
.IPs cbr:preset=192
Encodiere mit ABR-Preset bei erzwungener konstanter Bitrate von 192 kBit/s.
.IPs preset=172
Encodiere mit ABR-Preset bei einer durchschnittlichen Bitrate von 172 kBit/s.
.IPs preset=extreme
Für Menschen mit einem sehr guten Gehör und entsprechender HiFi-Ausstattung.
.RE
.PD 1
.
.
.SS toolame und twolame (\-toolameopts und \-twolameopts respektive)
.
.TP
.B br=<32\-384>
Im CBR-Modus gibt dieser Parameter die Bitrate in kbps an, im VBR-Modus ist er
die minimal erlaubte Bitrate pro Frame.
VBR funktioniert nicht mit einem Wert unter 112.
.
.TP
.B vbr=<\-50\-50> (nur bei VBR)
Bereich für Abweichungen; falls negativ verlagert der Encoder die
durchschnittliche Bitrate zum unteren Limit, wenn positiv zum höheren.
Auf 0 gesetzt wird CBR benutzt (Standard).
.
.TP
.B maxvbr=<32\-384> (nur bei VBR)
maximal erlaubte Bitrate pro Frame in kBit/s
.
.TP
.B mode=<stereo  |  jstereo  |  mono  |  dual>
(Standard: mono bei 1-Kanal-Audio, sonst stereo)
.
.TP
.B psy=<\-1\-4>
psychoakustisches Modell (Standard: 2)
.
.TP
.B errprot=<0 | 1>
Füge Fehlerkorrektur hinzu.
.
.TP
.B debug=<0\-10>
Debugging-Level
.RE
.PD 1
.
.
.SS faac (\-faacopts)
.
.TP
.B br=<Bitrate>
mittlere Bitrate in kBit/s (schließt Option quality aus)
.
.TP
.B quality=<1\-1000>
Qualitätsmodus, je höher desto besser (schließt Option br aus)
.
.TP
.B object=<1\-4>
Komplexität des Objekttyps
.PD 0
.RSs
.IPs 1
MAIN (Standard)
.IPs 2
LOW
.IPs 3
SSR
.IPs 4
LTP (extrem langsam)
.RE
.PD 1
.
.TP
.B mpeg=<2|4>
MPEG-Version (Standard: 4)
.
.TP
.B "tns\ \ \ \ "
Aktiviert temporäre Rauschanpassung.
.
.TP
.B cutoff=<0\-sampling_rate/2>
Frequenz, ab der abgeschnitten wird (Standard: sampling_rate/2)
.
.TP
.B "raw\ \ \ \ "
Speichert den Bitstream als reine Arbeitsdaten mit Extrainformationen im
Dateikopf des Containers (Standard: 0, entspricht ADTS).
Setze diese Option nicht, wenn du sie nicht unbedingt brauchst, sonst wirst
du den Audiostream später nicht erneut muxen können.
.RE
.PD 1
.
.
.SS lavc (\-lavcopts)
Viele Optionen von libavcodec (kurz lavc) sind nur knapp dokumentiert.
Lies die Sourcen für alle Details.
.PP
.I BEISPIEL:
.PD 0
.RSs
.IPs vcodec=msmpeg4:vbitrate=1800:vhq:keyint=250
.RE
.PD 1
.
.TP
.B o=<Schlüssel>=<Wert>[,<Schlüssel>=<Wert>[,...]]
Übergib AVOptions an den libavcodec-Encoder.
Beachte, ein Patch, um o= überflüssig zu machen und alle unbekannten Optionen
durch das AVOption-System zu übergeben, ist willkommen.
Eine komplette Liste der AVOptions findest du im FFmpeg-Handbuch.
Beachte, dass manche Optionen mit MEncoder-Optionen in Konflikt stehen
können.
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.PD 0
.IPs o=bt=100k
.PD 1
.RE
.
.TP
.B acodec=<Wert>
Audiocodec (Standard: mp2)
.PD 0
.RSs
.IPs "ac3\ \ "
Dolby Digital (AC-3)
.IPs adpcm_*
Adaptive PCM Formate \- siehe HTML-Dokumentation für Details.
.IPs "flac\ "
Free Lossless Audio Codec (FLAC)
.IPs "g726\ "
G.726 ADPCM
.IPs libamr_nb
3GPP Adaptive Multi-Rate (AMR) narrow-band
.IPs libamr_wb
3GPP Adaptive Multi-Rate (AMR) wide-band
.IPs libfaac
Advanced Audio Coding (AAC) \- benutzt FAAC
.IPs libmp3lame
MPEG-1 Audio Layer 3 (MP3) \- benutzt LAME
.IPs "mp2\ \ "
MPEG-1 Audio Layer 2 (MP2)
.IPs pcm_*
PCM Formate \- siehe HTML-Dokumentation für Details.
.IPs roq_dpcm
Id Software RoQ DPCM
.IPs sonic
experimenteller, einfacher, verlustbehafteter Codec
.IPs sonicls
experimenteller, einfacher, verlustfreier Codec
.IPs vorbis
Vorbis
.IPs wmav1
Windows Media Audio v1
.IPs wmav2
Windows Media Audio v2
.RE
.PD 1
.
.TP
.B abitrate=<Wert>
Audiobitrate in kbps (Standard: 224)
.
.TP
.B atag=<Wert>
Benutze die angegebene Windows-Audioformatkennung (z.B.\& atag=0x55).
.
.TP
.B bit_exact
Benutze nur bitgenaue Algorithmen (außer (I)DCT).
Zusätzlich deaktiviert bit_exact mehrere Optimierungen und sollte daher
nur für Regressionstests verwendet werden, die binär identische Dateien
benötigen, selbst wenn sich die Version des Encoders ändert.
Dies unterdrückt in MPEG-4-Streams außerdem den user_data-Dateikopf.
Benutze diese Option nicht, wenn du nicht genau weißt, was du tust.
.
.TP
.B threads=<1\-8>
Maximale Anzahl der zu benutzenden Threads (Standard: 1).
Kann einen leicht negativen Effekt auf die Bewegungsabschätzung haben.
.RE
.
.TP
.B vcodec=<Wert>
Verwende den angegebenen Codec (Standard: mpeg4).
.PD 0
.RSs
.IPs "asv1\ "
ASUS Video v1
.IPs "asv2\ "
ASUS Video v2
.IPs dvvideo
Sony Digital Video
.IPs "ffv1\ "
FFmpegs verlustfreier Videocodec
.IPs ffvhuff
nicht-standardkonformes, 20% kleineres HuffYUV, benutzt YV12
.IPs "flv\ \ "
Sorenson H.263, verwendet in Flash-Videos
.IPs "h261\ "
H.261
.IPs "h263\ "
H.263
.IPs h263p
H.263+
.IPs huffyuv
HuffYUV
.IPs libtheora
Theora
.IPs libx264
x264 H.264/AVC MPEG-4 Part 10
.IPs libxvid
Xvid MPEG-4 Part 2 (ASP)
.IPs ljpeg
Lossless JPEG
.IPs mjpeg
Motion JPEG
.IPs mpeg1video
MPEG-1 Video
.IPs mpeg2video
MPEG-2 Video
.IPs mpeg4
MPEG-4 (DivX 4/\:5)
.IPs msmpeg4
DivX 3
.IPs msmpeg4v2
MS MPEG4v2
.IPs roqvideo
ID Software RoQ Video
.IPs "rv10\ "
ein alter RealVideo Codec
.IPs "snow (siehe auch: vstrict)"
FFmpegs experimenteller Wavelet-basierter Codec
.IPs "svq1\ "
Apple Sorenson Video 1
.IPs "wmv1\ "
Windows Media Video, Version 1 (WMV7)
.IPs "wmv2\ "
Windows Media Video, Version 2 (WMV8)
.RE
.PD 1
.
.TP
.B vqmin=<1\-31>
minimaler Quantisierungsparameter
.RSs
.IPs 1
Nicht empfohlen (viel größere Datei, geringer Qualitätsunterschied und
seltsame Seiteneffekte: msmpeg4 und h263 werden eine sehr geringe Qualität
liefern und die Bitratenkontrolle wird verwirrt sein, was auch eine geringere
Qualität zur Folge hat; manche Decoder werden es nicht decodieren können).
.IPs 2
Empfohlen für normales Encodieren mit mpeg4/\:mpeg1video (Standard).
.IPs 3
Empfohlen für h263(p)/\:msmpeg4.
Der Grund dafür, 3 dem Wert 2 vorzuziehen ist, dass 2 zu Overflows führen kann.
(Dies wird zukünftig für h263(p) korrigiert werden, indem der
Quantisierungsparameter pro Macro-Block geändert wird; msmpeg4 kann nicht
korrigiert werden, da es dies nicht unterstützt.)
.RE
.
.TP
.B lmin=<0.01\-255.0>
Minimaler Frame-Level basierter Lagrange-Multiplikator für die
Bitratenkontrolle (Standard: 2.0).
Lavc wird Quantisierungparameter, die unter dem Wert für lmin liegen, kaum
verwenden.
Ein niedriger Wert für lmin bewirkt, dass lavc für manche Frames eher
niedrigere Quantisierungsparameter verwendet, jedoch nicht niedriger als der
angegebene Wert für vqmin.
Entsprechend wird ein größerer Wert für lmin bewirken, dass lavc niedrige
Quantisierungsparameter eher nicht verwendet, auch wenn vqmin diese erlaubt
hätte.
Vermutlich willst du lmin ungefähr gleich vqmin setzen.
Wenn adaptive Quantisierung verwendet wird, wirkt sich die Änderung von
lmin/lmax weniger stark aus; siehe mblmin/mblmax.
.RE
.
.TP
.B lmax=<0.01\-255.0>
Maximaler Lagrange-Multiplikator für die Bitratenkontrolle (Standard: 31.0)
.RE
.
.TP
.B mblmin=<0.01\-255.0>
Minimaler Macroblock-Level basierter Lagrange-Multiplikator für die
Bitratenkontrolle (Standard: 2.0).
Dieser Parameter wirkt sich auf Optionen für die adaptive Quantisierung wie
qprd, lumi_mask, usw aus.
.RE
.
.TP
.B mblmax=<0.01\-255.0>
Maximaler Macroblock-Level basierter Lagrange-Multiplikator für die
Bitratenkontrolle (Standard: 31.0).
.RE
.
.TP
.B vqscale=<0\-31>
Encodierung mit konstantem Quantisierungsparameter bzw.\& konstanter Qualität
(wählt den 'fixed quantizer'-Modus).
Ein kleinerer Wert bedeutet bessere Qualität bei größeren Dateien (Standard: \-1).
Im Falle des snow Codecs bedeutet der Wert 0 verlustfreie Encodierung.
Da die anderen Codecs dies nicht unterstützen, hat vqscale=0 bei diesen
nicht-definierte Auswirkungen.
Der Wert 1 wird nicht empfohlen (siehe vqmin für Details).
.
.TP
.B vqmax=<1\-31>
Maximaler Quantisierungsparameter, Werte im Bereich 10\-31
sollten vernünftig sein (Standard: 31).
.
.TP
.B mbqmin=<1\-31>
veraltet, benutze vqmin
.
.TP
.B mbqmax=<1\-31>
veraltet, benutze vqmax
.
.TP
.B vqdiff=<1\-31>
maximaler Unterschied der Quantisierungsparameter zwischen
aufeinanderfolgenden Intra- und P-Frames (Standard: 3)
.
.TP
.B vmax_b_frames=<0\-4>
maximale Anzahl der B-Frames zwischen nicht-B-Frames
.PD 0
.RSs
.IPs 0
keine B-Frames (Standard)
.IPs 0\-2
vernünftiger Bereich für MPEG-4
.RE
.PD 1
.
.TP
.B vme=<0\-5>
Verfahren für die Bewegungsabschätzung.
Verfügbare Modi sind die folgenden:
.PD 0
.RSs
.IPs 0
keine (sehr geringe Qualität)
.IPs 1
volle (langsam, momentan nicht gewartet und deaktiviert)
.IPs 2
log (geringe Qualität, momentan nicht gewartet und deaktiviert)
.IPs 3
phods (geringe Qualität, momentan nicht gewartet und deaktiviert)
.IPs 4
EPZS: Größe=1 diamond, Größe kann mit den *dia-Optionen angepasst werden
(Standard).
.IPs 5
X1 (experimentell, verweist momentan nur auf EPZS)
.IPs 8
iter (iterativ überlappter Block, wird nur bei snow benutzt)
.RE
.PD 1
.sp 1
.RS
.br
.I ANMERKUNG:
0\-3 ignorieren momentan den Umfang der gebrauchten Bits, die Qualität
kann daher gering sein.
.RE
.
.TP
.B me_range=<0\-9999>
Umfang der Bewegungsabschätzung (Standard: 0 (unbegrenzt))
.
.TP
.B mbd=<0\-2> (siehe auch *cmp, qpel)
Macroblock decision algorithm: Entscheidungsalgorithmus für Macro-Blocks (hohe
Qualitätsstufe), encodiert jeden Macro-Block in allen Modi und wählt den
besten aus.
Dies ist zwar langsam, führt aber zu besserer Qualität und Dateigröße.
Wenn mbd auf 1 oder 2 gesetzt ist, wird der mbcmp-Wert beim Vergleich von
Macro-Blöcken ignoriert (der mbcmp-Wert wird jedoch in anderen Bereichen
verwendet, insbesondere bei den Bewegungssuchalgorithmen).
Falls jedoch irgendeine Vergleichseinstellung (precmp, subcmp, cmp oder mbcmp)
ungleich null ist, wird eine langsamere aber bessere Bewegungssuche verwendet,
die auf halbe Pixel genau arbeitet.
Dabei ist egal, auf welchen Wert mbd gesetzt wurde.
Wenn qpel gesetzt ist, wird in jedem Falle auf Viertelpixel genaue
Bewegungssuche verwendet.
.PD 0
.RSs
.IPs 0
Benutze von mbcmp gegebene Vergleichsfunktion (Standard).
.IPs 1
Wählt denjenigen Modus für einen Macro-Block, der die wenigsten Bits benötigt
(entspricht vhq).
.IPs 2
Wählt den Modus für einen Macro-Block mit der geringsten Ratenverzerrung
.RE
.PD 1
.
.TP
.B "vhq\ \ \ \ "
Bewirkt das gleiche wie mbd=1, wird aus Kompatibilitätsgründen beibehalten.
.
.TP
.B "v4mv\ \ \ "
Erlaubt 4 Motion-Vectors pro Macro-Block (leicht verbesserte Qualität).
Arbeitet besser in Verbindung mit mbd > 0.
.
.TP
.B "obmc\ \ \ "
Bewegungskompensation überlappender Blöcke (H.263+)
.
.TP
.B "loop\ \ \ "
Loop-Filter (H.263+)
Beachte, dass diese Option nicht funktioniert.
.
.TP
.B inter_threshold <\-1000\-1000>
Bewirkt zur Zeit absolut gar nichts.
.
.TP
.B keyint=<0\-300>
Maximale Anzahl von Bildern zwischen zwei Keyframes (Standard: 250, was einem
Keyframe alle zehn Sekunden bei einem 25fps-Film entspricht.
Dies ist der empfohlene Standardwert für MPEG-4).
Die meisten Codecs benötigen regelmäßig Keyframes, um die Anhäufung von
Versatzfehlern zu begrenzen.
Keyframes werden auch für das Spulen in Filmen gebraucht, da nur ein Sprung zu
Keyframes möglich ist.
Keyframes jedoch benötigen mehr Platz als andere Frames,
daher bedeutet ein höherer Wert hier geringfügig kleinere Dateien und damit
weniger genaues Spulen.
0 ist gleichbedeutend mit 1, was jeden Frame zu einem Keyframe macht.
Werte > 300 werden nicht empfohlen, da die Qualität abhängig von Decoder,
Encoder und Glück schlecht sein kann.
Für MPEG-1/2 sind Werte <=30 üblich.
.
.TP
.B sc_threshold=<\-1000000000\-1000000000>
Schwellenwert für die Erkennung eines Szenenwechsels.
Ein Keyframe wird von libavcodec eingefügt, wenn ein Szenenwechsel entdeckt
wird.
Mit dieser Option kannst du die Sensitivität dieser Erkennung bestimmen.
\-1000000000 bedeutet, dass mit jedem Frame ein Szenenwechsel erkannt wird;
1000000000 bedeutet, dass gar keine Szenenwechsel erkannt werden (Standard: 0).
.
.TP
.B sc_factor=<jede mögliche Ganzzahl>
Bewirkt, dass Frames mit höheren Quantisierungsparametern eher eine Erkennung
eines Szenenwechsels bewirken und libavcodec veranlassen, einen Intra-Frame zu
benutzen (Standard: 1).
1\-16 ist ein sinnvoller Bereich.
Werte zwischen 2 und 6 können bewirken, den PSNR-Wert zu erhöhen (um bis zu
ungefähr 0.04 dB) und Intra-Frames in Szenen mit viel Bewegung besser zu
platzieren.
Höhere Werte als 6 könnten den PSNR-Wert leicht erhöhen (um ungefähr 0.01 dB
mehr als sc_factor=6) aber zu bemerkbar schlechterer Qualität führen.
.
.TP
.B vb_strategy=<0\-2> (nur bei Durchlauf 1)
Strategie, mit der zwischen Intra-/P-/B-Frames gewählt wird:
.PD 0
.RSs
.IPs 0
Benutzt immer die maximale Anzahl B-Frames (Standard).
.IPs 1
Vermeide B-Frames in schnell bewegten Szenen.
Siehe die Option b_sensitivity, um Feineinstellungen für diese Option
vorzunehmen.
.IPs 2
Platziert B-Frames mehr oder weniger optimal, um maximale Qualität zu
erbringen (langsamer).
Du kannst versuchen, den Einfluß auf die Geschwindigkeit durch
Herumprobieren mit der Option brd_scale zu verringern.
.RE
.PD 1
.
.TP
.B b_sensitivity=<jede Ganzzahl größer als 0>
Macht Anpassungen, wie sensitiv vb_strategy=1 Bewegung erkennt und den Gebrauch
von B-Frames vermeidet (Standard: 40).
Geringere Empfindlichkeit führt zu mehr B-Frames.
Der Gebrauch von mehr B-Frames verbessert PSNR normalerweise, zu viele B-Frames
jedoch können die Qualität in hochbewegten Szenen stören.
Wenn es nicht gerade einen extrem hohen Anteil Bewegung gibt, kann
b_sensitivity sicher auf einen Wert unter dem Standardwert verringert werden;
10 ist in den meisten Fällen ein brauchbarer Wert.
.
.TP
.B brd_scale=<0\-10>
Skaliert Frames für dynamische B-Frame-Entscheidungen herunter (Standard: 0).
Jedesmal, wenn brd_scale um eins erhöht wird, werden die Bildabmessungen durch
zwei geteilt, was die Geschwindigkeit um den Faktor vier verbessert.
Beide Abmessungen des komplett herunterskalierten Bildes müssen gerade Zahlen
sein, daher benötigt brd_scale=1 originale Abmessungen, die ein Vielfaches von
vier sind, für brd_scale=2 ein Vielfaches von acht usw.
Mit anderen Worten müssen beide Abmessungen des Originalbildes ohne Rest
teilbar sein durch 2^(brd_scale+1).
.
.TP
.B bidir_refine=<0\-4>
Verfeinert die beiden Motion-Vectors, die in bidirektionalen Makroblöcken
benutzt werden, anstatt die Vektoren der Vorwärts- und Rückwärtssuche zu
benutzen.
Diese Option hat ohne B-Frames keine Wirkung.
.PD 0
.RSs
.IPs 0
Deaktiviert (Standard).
.IPs 1\-4
Benutze eine weitergehende Suche (größere Werte sind langsamer).
.RE
.PD 1
.
.TP
.B vpass=<1\-3>
Aktiviert den internen Modus für zwei (oder mehr) Durchläufe.
Gib diese Option nur an, wenn du mit zwei (oder mehr) Durchläufen encodieren
möchtest.
.PD 0
.RSs
.IPs 1
erster Durchlauf (siehe auch turbo)
.IPs 2
zweiter Durchlauf
.IPs 3
N-ter Durchlauf (zweiter und nachfolgende Durchläufe beim N-pass-Modus)
.RE
.RS
Hier also wie es funktioniert und benutzt wird:
.br
Der erste Durchlauf (vpass=1) schreibt eine Datei mit Statistiken.
Du möchtest vielleicht ein paar CPU-intensive Optionen deaktivieren, wie es
der Modus "turbo" tut.
.br
Im Modus mit zwei Durchläufen wird im zweiten Durchlauf (vpass=2) die
Statistikdatei gelesen, und die Bitratenkontrolle fällt dementsprechende
Entscheidungen.
.br
Im N-pass-Modus (vpass=3, das ist kein Schreibfehler) wird beides getan: Erst
werden die Statistiken eingelesen, dann überschrieben.
Wenn die Möglichkeit besteht, dass du diesen Vorgang abbrechen musst, solltest
du die Datei divx2pass.log vorher sichern.
Du kannst alle Encodierungsoptionen verwenden, außer sehr CPU-lastigen
wie "qns".
.br
Du kannst denselben Durchlauf wiederholt durchführen, um die Encodierung zu
verfeinern.
Jeder nachfolgende Durchlauf wird die Statistiken des vorigen benutzen, um die
Ergebnisse zu verbessern.
Der letzte Durchlauf kann beliebige CPU-intensive Optionen beinhalten.
.br
Wenn du mit zwei Durchläufen encodieren möchtest, benutze zuerst vpass=1 und
dann vpass=2.
.br
Wenn du mit drei oder mehr Durchläufen encodieren möchtest, benutze vpass=1 für
den ersten Durchlauf, dann vpass=3 und dann vpass=3 immer wieder, bis du mit
dem Ergebnis zufrieden bist.
.RE
.PD 1
.sp 1
.RS
huffyuv:
.RE
.PD 0
.RSs
.IPs "pass 1"
Speichert Statistiken.
.IPs "pass 2"
Encodiert mit einer optimalen Huffman-Tabelle, basierend auf den Statistiken
des ersten Durchlaufs.
.RE
.PD 1
.
.TP
.B turbo (nur im Modus mit zwei Durchläufen)
Erhöht die Geschwindigkeit des ersten Durchgangs drastisch, indem schnellere
Algorithmen benutzt und CPU-intensive Optionen deaktiviert werden
Dies wird den PSNR-Wert im Ganzen wahrscheinlich ein wenig (etwa
0.01dB) und Typ und PSNR-Wert einzelner Frames ein wenig mehr (bis zu
0.03db) verringern.
.
.TP
.B aspect=<x/y>
Speichere den Filmaspekt intern, wie bei MPEG-Dateien.
Dies ist eine viel elegantere Lösung als den Film neu zu skalieren, da die
Qualität nicht verringert wird.
MPlayer und ein paar weitere Player werden diese Dateien korrekt wiedergeben,
andere werden das Größenverhältnis falsch darstellen.
Der Parameter für das Verhältnis kann als Bruch oder Fließkommawert angegeben
werden.
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.PD 0
.IPs "aspect=16/9 oder aspect=1.78"
.PD 1
.RE
.
.TP
.B autoaspect
Das gleiche wie die Option aspect, wobei jedoch das Verhältnis automatisch
berechnet wird.
Veränderungen in der Filterkette wie crop/\:expand/\:scale/\:etc.\& werden
dabei berücksichtigt.
Diese Option verursacht keine Performanceeinbußen, du kannst sie also getrost
immer aktivert lassen.
.
.TP
.B vbitrate=<Wert>
Gibt die Bitrate an (Standard: 800).
.br
.I WARNUNG:
1kBit = 1000 Bits
.PD 0
.RSs
.IPs 4\-16000
(in kBit)
.IPs 16001\-24000000
(in Bit)
.RE
.PD 1
.
.TP
.B vratetol=<Wert>
ungefähre Dateigrößentoleranz in kBit.
Werte im Bereich 1000\-100000 sind vernünftig.
(Warnung: 1kBit = 1000 Bits)
(Standard: 8000)
.br
.I ANMERKUNG:
vratetol sollte im zweiten Durchlauf nicht zu groß sein, es kann sonst in
Verbindung mit vrc_(min|max)rate zu Problemen kommen.
.
.TP
.B vrc_maxrate=<Wert>
maximale Bitrate in kBit/\:Sek
(Standard: 0, unbegrenzt)
.
.TP
.B vrc_minrate=<Wert>
minimale Bitrate in kBit/\:Sek
(Standard: 0, unbegrenzt)
.
.TP
.B vrc_buf_size=<Wert>
Puffergröße in kBit
Für MPEG-1/2 setzt dies außerdem die vbv-Puffergröße; benutze 327
für VCDs, 917 für SVCDs und 1835 für DVDs.
.
.TP
.B vrc_buf_aggressivity
momentan nutzlos
.
.TP
.B vrc_strategy
Methode zur Bitratenkontrolle.
Beachte, dass manche der die Bitratenkontrolle betreffenden Optionen nicht
wirksam sind, wenn vrc_strategy nicht auf 0 gesetzt ist.
.PD 0
.RSs
.IPs 0
Benutze die interne lavc-Bitratenkontrolle (Standard).
.IPs 1
Benutze die Xvid-Bitratenkontrolle (experimentell; MEncoder muss mit
Unterstützung für Xvid 1.1 oder höher kompiliert worden sein).
.RE
.PD 1
.
.TP
.B vb_qfactor=<\-31.0\-31.0>
Quantisierungsparameter zwischen B- und Nicht-B-Frames
(Standard: 1.25)
.
.TP
.B vi_qfactor=<\-31.0\-31.0>
Quantisierungsparameter zwischen Intra- und Nicht-Intraframes
(Standard: 0.8)
.
.TP
.B vb_qoffset=<\-31.0\-31.0>
Offset des Quantisierungsparameters zwischen B- und Nicht-B-Frames
(Standard: 1.25)
.
.TP
.B vi_qoffset=<\-31.0\-31.0>
Offset des Quantisierungsparameters zwischen Intra- und Nicht-Intraframes
(Standard: 0.0)
.br
falls v{b|i}_qfactor > 0
.br
Intra-/B-Frame-Quantisierungsparameter = P-Frame-Quantisierungsparameter *
v{b|i}_qfactor + v{b|i}_qoffset
.br
sonst
.br
benutze die normale Bitratenkontrolle (lege den nächsten
P-Frame-Quantisierungsparameter nicht fest) und setze
q= \-q * v{b|i}_qfactor + v{b|i}_qoffset
.br
.I TIPP:
Für Encodierung mit unterschiedlichen aber konstanten Quantisierungsparametern
für Intra-/P- und B-Frames kannst du folgendes benutzen:
lmin= <ip_quant>:lmax= <ip_quant>:vb_qfactor= <b_quant/\:ip_quant>.
.
.TP
.B vqblur=<0.0\-1.0> (erster Durchlauf)
Glättung des Quantisierungsparameters (Standard: 0.5); größere Werte bilden den
Durchschnitt über längere Zeit (langsamerer Wechsel).
.PD 0
.RSs
.IPs 0.0
Glättung des Quantisierungsparameters deaktiviert.
.IPs 1.0
Bildet für den Quantisierungsparameter den Durchschnitt aller vorangegangenen
Frames.
.RE
.PD 1
.
.TP
.B vqblur=<0.0\-99.0> (zweiter Durchlauf)
Gaußsche Unschärfe des Quantisierungsparameters (Standard: 0.5); größere Werte
bilden den Durchschnitt über längere Zeit (langsamerer Wechsel).
.
.TP
.B vqcomp=<Wert>
Kompression des Quantisierungsparameters, vrc_eq hängt davon ab
(Standard: 0.5).
.I ANMERKUNG:
Die wahrgenommene Qualität ist optimal irgendwo zwischen den Extremen des
Bereichs.
.
.TP
.B vrc_eq=<Gleichung>
hauptsächlich verwendete Gleichung für die Bitratenkontrolle
.RE
.RSs
.IPs 1+(tex/\:avgTex-1)*qComp
ungefähr die Gleichung des Codes der alten Bitratenkontrolle
.IPs tex^qComp
wobei qcomp = 0.5 oder einem ähnlichen Wert (Standard)
.RE
.PP
.RS
Infixoperatoren:
.RE
.RSs
.IPs +,\-,*,/,^
.RE
.PP
.RS
Variablen:
.RE
.RSs
.IPs "tex\ \ "
Texturkomplexität
.IPs iTex,pTex
Intra- und Nicht-Intra-Texturkomplexität
.IPs avgTex
durchschnittliche Texturkomplexität
.IPs avgIITex
durchschnittliche Intra-Texturkomplexität bei Intraframes
.IPs avgPITex
durchschnittliche Intra-Texturkomplexität bei P-Frames
.IPs avgPPTex
durchschnittliche Nicht-Intra-Texturkomplexität bei P-Frames
.IPs avgBPTex
durchschnittliche Nicht-Intra-Texturkomplexität bei B-Frames
.IPs "mv\ \ \ "
für Motion-Vectors verwendete Bits
.IPs fCode
maximale Länge der Motion-Vectors in log2-Skalierung
.IPs iCount
Anzahl der Intra-Macroblöcke /\: Anzahl der Macroblöcke
.IPs "var\ \ "
räumliche Komplexität
.IPs mcVar
zeitliche Komplexität
.IPs qComp
auf der Kommandozeile angegebener Wert für qcomp
.IPs "isI, isP, isB"
Ist 1 bei einem Bildtyp I/P/B, sonst 0.
.IPs "Pi,E\ "
Schau in dein Lieblingsmathebuch.
.RE
.PP
.RS
Funktionen:
.RE
.RSs
.IPs max(a,b),min(a,b)
Maximum /\: Minimum
.IPs gt(a,b)
(greater than) ist 1 falls a>b, sonst 0
.IPs lt(a,b)
(less than) ist 1 falls a<b, sonst 0
.IPs eq(a,b)
(equals) ist 1 falls a==b, sonst 0
.IPs "sin, cos, tan, sinh, cosh, tanh, exp, log, abs"
.RE
.
.TP
.B vrc_override=<Optionen>
Vom Benutzer angegebene Qualität für bestimmte Abschnitte
(Ende, Abspann, ...).
Die Optionen haben folgenden Aufbau: <Startframe>, <Endframe>,
<Qualität>[/<Startframe>, <Endframe>, <Qualität>[/...]]:
.PD 0
.RSs
.IPs "Qualität (2\-31)"
Quantisierungsparameter
.IPs "Qualität (\-500\-0)"
Qualitätskorrektur in %
.RE
.PD 1
.
.TP
.B vrc_init_cplx=<0\-1000>
anfängliche Komplexität (Durchlauf 1)
.
.TP
.B vrc_init_occupancy=<0.0\-1.0>
initiale Pufferbelegung als Bruchteil von vrc_buf_size (Standard: 0.9)
.
.TP
.B vqsquish=<0|1>
Gibt an, wie die Quantisierungsparameter zwischen qmin und qmax beibehalten
werden:
.PD 0
.RSs
.IPs 0
Benutze Clipping.
.IPs 1
Benutzt eine schöne ableitbare Funktion (Standard).
.RE
.PD 1
.
.TP
.B vlelim=<\-1000\-1000>
Setzt die Schwelle für die Eliminierung von einzelnen Koeffizienten beim
Helligkeitsanteil.
Bei negativen Werten wird auch der DC-Koeffizient betrachtet (sollte
mindestens \-4 or niedriger sein, wenn mit quant=1 encodiert wird):
.PD 0
.RSs
.IPs 0
deaktiviert (Standard)
.IPs \-4
JVT-Empfehlung
.RE
.PD 1
.
.TP
.B vcelim=<\-1000\-1000>
Setzt die Schwelle für die Eliminierung von einzelnen Koeffizienten beim
Farbanteil.
Bei negativen Werten wird auch der DC-Koeffizient betrachtet (sollte
mindestens \-4 or niedriger sein, wenn mit quant=1 encodiert wird):
.PD 0
.RSs
.IPs 0
deaktiviert (Standard)
.IPs 7
JVT-Empfehlung
.RE
.PD 1
.
.TP
.B vstrict=<\-2|\-1|0|1>
strikte Einhaltung des Standards
.PD 0
.RSs
.IPs 0
deaktiviert
.IPs 1
Nur empfehlenswert, wenn die Ausgabe mit einem MPEG-4-Referenzdecoder
decodiert werden soll.
.IPs \-1
Erlaubt die Benutzung libavcodec-spezifischer Erweiterungen (Standard).
.IPs \-2
Erlaubt die Benutzung experimenteller Codecs und Features, die von zukünftigen
Versionen von MPlayer möglicherweise nicht abspielbar sein werden (snow).
.RE
.PD 1
.
.TP
.B "vdpart\ "
Datenpartitionierung.
Fügt zwei Bytes pro Videopaket hinzu und erhöht die Fehlerresistenz beim
Transfer über unzuverlässige Kanäle (z.B.\& Streaming über das Internet).
Jedes Videopaket wird in drei separate Partitionen aufgeteilt:
.PD 0
.RSs
.IPs "1. MVs"
Bewegung
.IPs "2. DC-Koeffizienten"
niedrig aufgelöstes Bild
.IPs "3. AC-Koeffizienten"
Details
.RE
.PD 1
.RS
MV und DC sind am wichtigsten, sie zu verlieren bedeutet ein viel schlechteres
Bild als der Verlust von AC und der ersten oder zweiten Partition.
MV und DC sind viel kleiner als die dritte Partition (AC), was bedeutet, dass
auftretende Fehler die AC-Partition viel häufiger treffen wird als die MV- und
DC-Partitionen.
Daher sieht das Bild mit Partitionierung viel besser aus, denn ohne eine
solche würde ein Fehler AC/\:DC/\:MV in gleichem Umfang zerstören.
.RE
.
.TP
.B vpsize=<0\-10000> (siehe auch vdpart)
Videopaketgröße, erhöht die Fehlerresistenz.
.PD 0
.RSs
.IPs "0\ \ \ \ "
deaktiviert (Standard)
.IPs 100\-1000
gute Wahl
.RE
.PD 1
.
.TP
.B "ss\ \ \ \ \ "
slice-structured- (anteilig strukturierter) Modus für H.263+
.
.TP
.B "gray\ \ \ "
Encodierung zu Graustufenbildern (schneller)
.
.TP
.B vfdct=<0\-10>
DCT-Algorithmus
.PD 0
.RSs
.IPs 0
Wählt automatisch einen guten (Standard).
.IPs 1
schneller Integer-Algorithmus
.IPs 2
genauer Integer-Algorithmus
.IPs 3
MMX
.IPs 4
mlib
.IPs 5
AltiVec
.IPs 6
Fließkomma-AAN
.RE
.PD 1
.
.TP
.B idct=<0\-99>
IDCT-Algorithmus
.br
.I ANMERKUNG:
Nach unserem Wissensstand bestehen all diese IDCT-Algorithmen die IEEE1180-Tests.
.PD 0
.RSs
.IPs 0
Wählt automatisch einen guten (Standard).
.IPs 1
JPEG-Referenzalgorithmus (Integer)
.IPs 2
simple
.IPs 3
simplemmx
.IPs 4
libmpeg2mmx (ungenau, benutze ihn nicht mit einem keyint > 100)
.IPs 5
ps2
.IPs 6
mlib
.IPs 7
arm
.IPs 8
AltiVec
.IPs 9
sh4
.IPs 10
simplearm
.IPs 11
H.264
.IPs 12
VP3
.IPs 13
IPP
.IPs 14
xvidmmx
.IPs 15
CAVS
.IPs 16
simplearmv5te
.IPs 17
simplearmv6
.RE
.PD 1
.
.TP
.B lumi_mask=<0.0\-1.0>
Helligkeitsmaskierung ist eine 'psychosensorische' Einstellung, die die
Tatsache nutzen soll, dass das menschliche Auge dazu neigt, in sehr hellen
Teilen eines Bildes weniger Details zu erkennen.
Helligkeitsmaskierung komprimiert sehr helle Stellen stärker als
durchschnittlich helle, so dass ein paar Bits eingespart werden, die dann auf
andere Frames verwendet werden können, was die subjektive Qualität im Ganzen
erhöht, den PSNR-Wert dabei jedoch möglicherweise reduziert.
.br
.I WARNUNG:
Sei vorsichtig, zu große Werte können katastrophale Ergebnisse liefern.
.br
.I WARNUNG:
Große Werte mögen auf einigen Monitoren gut aussehen, können auf anderen aber
auch schrecklich aussehen.
.PD 0
.RSs
.IPs "0.0\ \ "
deaktiviert (Standard)
.IPs 0.0\-0.3
sinnvoller Bereich
.RE
.PD 1
.
.TP
.B dark_mask=<0.0\-1.0>
Dunkelheitsmaskierung ist eine 'psychosensorische' Einstellung, die die
Tatsache nutzen soll, dass das menschliche Auge dazu neigt, in sehr dunklen
Teilen eines Bildes weniger Details zu erkennen.
Dunkelheitsmaskierung komprimiert sehr dunkle Stellen stärker als
durchschnittlich dunkle, so dass ein paar Bits eingespart werden, die dann auf
andere Frames verwendet werden können, was die subjektive Qualität im Ganzen
erhöht, den PSNR-Wert dabei jedoch möglicherweise reduziert.
.br
.I WARNUNG:
Sei vorsichtig!
Zu große Werte können katastrophale Ergebnisse liefern.
.br
.I WARNUNG:
Große Werte mögen auf einigen Monitoren gut aussehen, können auf anderen
Monitoren /\: dem Fernseher /\: TFTs aber auch schrecklich aussehen.
.PD 0
.RSs
.IPs "0.0\ \ "
deaktiviert (Standard)
.IPs 0.0\-0.3
sinnvoller Bereich
.RE
.PD 1
.
.TP
.B tcplx_mask=<0.0\-1.0>
Maskierung der zeitlichen Komplexität (Standard: 0.0 (deaktiviert)).
Stell dir eine Szene mit einem Vogel vor, der durch die ganze Szene fliegt;
tcplx_mask wird die Quantisierungsparameter der zum Vogel gehörenden
Macroblöcke erhöhen (und so deren Qualität verringern), da das menschliche
Auge normalerweise nicht die Zeit hat, alle Details des Vogels wahrzunehmen.
Sei gewarnt, dass es für kurze Zeit schrecklich aussieht, wenn das Objekt
anhält (z.B.\& bei der Landung des Vogels), bis der Encoder bemerkt, dass das
Objekt angehalten hat und die Blöcke neu definiert werden müssen.
Die eingesparten Bits werden auf andere Teile des Videos verwendet, was die
subjektiv wahrgenommene Qualität erhöhen kann \- vorausgesetzt, tcplx_mask ist
sorgfältig gewählt.
.
.TP
.B scplx_mask=<0.0\-1.0>
Gebietsbezogene Maskierung der Komplexität.
Größere Werte helfen bei Blockartefakten, falls kein Deblocking-Filter
beim Decodieren benutzt wird, was vielleicht keine gute Idee ist.
.br
Stell die eine Szene vor mit Gras (was üblicherweise eine hohe gebietsbezogene
Komplexität hat), einem blauen Himmel und einem Haus; scplx_mask wird die
Quantisierungsparameter der zum Gras gehörenden Macroblöcke erhöhen, was deren
Qualität verringert, um mehr Bits auf den Himmel und das Haus zu verwenden.
.br
.I TIPP:
Schneide alle schwarzen Balken komplett ab, da sie die Qualität der
Macroblöcke verringern (gilt auch ohne scplx_mask).
.PD 0
.RSs
.IPs "0.0\ \ "
deaktiviert (Standard)
.IPs 0.0\-0.5
sinnvoller Bereich
.RE
.PD 1
.sp 1
.RS
.I ANMERKUNG:
Diese Einstellung hat nicht denselben Effekt wie die Benutzung einer
benutzerdefinierten Matrix, die hohe Frequenzen stärker komprimieren würde, da
scplx_mask die Qualität der P-Blöcke verringert, selbst wenn sich nur die
DC-Koeffizienten ändern.
Das Ergebnis mit scplx_mask wird vermutlich nicht so gut aussehen.
.RE
.
.TP
.B p_mask=<0.0\-1.0> (siehe auch vi_qfactor)
Verringert die Qualität von Interblöcken.
Dies ist das Äquivalent zum Erhöhen der Qualität der Intrablöcke, da dieselbe
mittlere Bitrate von der Bitratenkontrolle zur ganzen Videosequenz zugeteilt
wird (Standard: 0.0 (deaktiviert)).
p_mask=1.0 verdoppelt die Anzahl der jedem Intrablock zugeteilten Bits.
.
.TP
.B border_mask=<0.0\-1.0>
Randbearbeitung (border processing) bei MPEG-ähnlichen Encodern.
Randbearbeitung erhöht den Quantisierungsparameter für Makroblöcke, die
weniger als ein Fünftel der Framebreite/\:-höhe vom Rand des Frames entfernt
sind, da sie visuell oft weniger bedeutsam sind.
.
.TP
.B "naq\ \ \ \ "
Normalisierte adaptive Quantisierung (experimentell).
Wenn adaptive Quantisierung benutzt wird (*_mask), dann wird der
durchschnittliche Quantisierungsparameter pro Macroblock eventuell
nicht mehr dem geforderten Quantisierungsparameter auf Framelevel entsprechen.
Naq versucht dann, den pro Macroblock verwendeten Quantisierungsparameter
anzupassen, um den geforderten Durchschnitt beizubehalten.
.
.TP
.B "ildct\ \ "
Benutze die interlaced DCT.
.
.TP
.B "ilme\ \ \ "
Benutze interlaced Bewegungsabschätzung (schließt qpel gegenseitig aus).
.
.TP
.B "alt\ \ \ \ "
Benutzt eine alternative Suchtabelle.
.
.TP
.B "top=<\-1\-1>\ \ \ "
.PD 0
.RSs
.IPs \-1
automatisch
.IPs 0
bottom field first (unteres Feld zuerst)
.IPs 1
top field first (oberes Feld zuerst)
.RE
.PD 1
.
.TP
.B format=<Wert>
.PD 0
.RSs
.IPs "YV12\ "
Standard
.IPs "444P\ "
für ffv1
.IPs "422P\ "
für HuffYUV, verlustfreies JPEG, dv und ffv1
.IPs "411P\ "
für verlustfreies JPEG, dv und ffv1
.IPs "YVU9\ "
für verlustfreies JPEG, ffv1 und svq1
.IPs "BGR32"
für verlustfreies JPEG und ffv1
.RE
.PD 1
.
.TP
.B "pred\ \ \ "
(für HuffYUV)
.PD 0
.RSs
.IPs 0
linke Vorhersage
.IPs 1
Vorhersage der Ebene/\:des Gradienten
.IPs 2
Medianvorhersage
.RE
.PD 1
.
.TP
.B "pred\ \ \ "
(für verlustfreies JPEG)
.PD 0
.RSs
.IPs 0
linke Vorhersage
.IPs 1
obere Vorhersage
.IPs 2
linke obere Vorhersage
.IPs 3
Vorhersage der Ebene/\:des Gradienten
.IPs 6
Durchschnittsvorhersage
.RE
.PD 1
.
.TP
.B "coder\ \ "
(für ffv1)
.PD 0
.RSs
.IPs 0
vlc-Codierung (Golomb-Rice)
.IPs 1
arithmetische Codierung (CABAC)
.RE
.PD 1
.
.TP
.B context
(für ffv1)
.PD 0
.RSs
.IPs 0
Modell zu kleinem Kontext
.IPs 1
Modell zu großem Kontext
.RE
.PD 1
.sp 1
.RS
(für ffvhuff)
.RE
.PD 0
.RSs
.IPs 0
vorbestimmte Huffman-Tabellen (eingebaut oder two-pass)
.IPs 1
adaptive Huffman-Tabellen
.RE
.PD 1
.
.TP
.B "qpel\ \ \ "
Benutze auf ein viertel Pixel ("quarter pel") genaue Bewegungsabschätzung
(schließt ilme gegenseitig aus).
.br
.I ANMERKUNG:
Dies scheint nur für Encodierung mit hohen Bitraten sinnvoll zu sein.
.
.TP
.B mbcmp=<0\-2000>
Setzt die Vergleichsfunktion für Macroblockentscheidungen; hat nur
Auswirkungen bei mbd=0.
Dies wird auch bei manchen Bewegungssuchalgorithmen verwendet, in welchem
Falle sie unabhängig von der mbd-Einstellung Auswirkungen hat.
.PD 0
.RSs
.IPs "0 (SAD)"
Summe der absoluten Differenzen, schnell (Standard)
.IPs "1 (SSE)"
Summe der quadrierten Fehler
.IPs "2 (SATD)"
Summe der absoluten Hadamard-transformierten Differenzen
.IPs "3 (DCT)"
Summe der absoluten DCT-transformierten Differenzen
.IPs "4 (PSNR)"
Summe der quadratischen Quantisierungsfehler (zu vermeiden, niedrige Qualität)
.IPs "5 (BIT)"
Anzahl der für den Block benötigten Bits
.IPs "6 (RD)"
Ratenverzerrung (rate distortion) optimal, langsam
.IPs "7 (ZERO)"
0
.IPs "8 (VSAD)"
Summe der absoluten vertikalen Differenzen
.IPs "9 (VSSE)"
Summe der quadrierten vertikalen Differenzen
.IPs "10 (NSSE)"
Rauschen beibehaltende Summe der quadrierten Differenzen
.IPs "11 (W53)"
5/\:3-Wavelet, wird nur bei snow verwendet
.IPs "12 (W97)"
9/\:7-Wavelet, wird nur bei snow verwendet
.IPs "+256\ "
Benutze auch die Farbinformation, funktioniert momentan nicht (korrekt) mit
B-Frames.
.RE
.PD 1
.
.TP
.B ildctcmp=<0\-2000>
Setzt die Vergleichsfunktion für interlaced DCT-Entscheidungen (siehe mbcmp
für eine Liste der verfügbaren Vergleichsfunktionen).
.
.TP
.B precmp=<0\-2000>
Setzt die Vergleichsfunktion für "pre pass"-Bewegungsabschätzung (siehe mbcmp
für eine Liste der verfügbaren Vergleichsfunktionen) (Standard: 0).
.
.TP
.B cmp=<0\-2000>
Setzt die Vergleichsfunktion für "full pel"-Bewegungsabschätzung (siehe mbcmp
für eine Liste der verfügbaren Vergleichsfunktionen) (Standard: 0).
.
.TP
.B subcmp=<0\-2000>
Setzt die Vergleichsfunktion für "sub pel"-Bewegungsabschätzung (siehe mbcmp
für eine Liste der verfügbaren Vergleichsfunktionen) (Standard: 0).
.
.TP
.B skipcmp=<0\-2000>
FIXME: Dokumentiere diese Option.
.
.TP
.B nssew=<0\-1000000>
Diese Einstellung kontrolliert die NSSE-Gewichtung, wobei eine höhere
Gewichtung stärkeres Rauschen erzeugt.
NSSE 0 ist identisch mit SSE.
Vielleicht findest du dies nützlich, wenn du die Beibehaltung von etwas
Rauschen in deinem encodierten Video besser findest als es vor dem Encodieren
herauszufiltern. (Standard: 8)
.
.TP
.B predia=<\-99\-6>
Rautentyp und -größe für "pre pass"-Bewegungsabschätzung
.
.TP
.B dia=<\-99\-6>
Rautentyp und -größe für die Bewegungsabschätzung.
Bewegungsabschätzung ist ein iterativer Prozess.
Eine kleine Raute zu benutzen begrenzt die Suche nicht auf das Auffinden von nur
kleinen Motion-Vectors.
Es ist nur irgendwie wahrscheinlicher, dass die Suche anhält, bevor der beste
Motion-Vector gefunden wurde \- vor allem, wenn Rauschen involviert ist.
Größere Rauten erlauben eine ausgedehntere Suche nach dem besten
Motion-Vector, welche daher langsamer ist, dafür aber zu einem besseren
Ergebnis führt.
.br
Große normale Rauten sind qualitativ besser als an das Muster anpassende
("shape adaptive") Rauten.
.br
An das Muster anpassende Rauten sind ein guter Kompromiss zwischen
Geschwindigkeit und Qualität.
.br
.I ANMERKUNG:
Die Größen von normalen und an das Muster anpassende Rauten haben
nicht dieselbe Bedeutung.
.RSs
.IPs \-3
an das Muster anpassende (schnell) Raute der Größe 3
.IPs \-2
an das Muster anpassende (schnell) Raute der Größe 2
.IPs \-1
ungerade Multi-Hexagon-Suche (langsam)
.IPs  1
Normale Raute der Größe 1 (Standard), entspricht einer Raute des Typs EPZS.
.nf
.ne
      0
     000
      0
.fi
.IPs 2
normale Raute der Größe 2
.nf
.ne
      0
     000
    00000
     000
      0
.fi
.RE
.
.TP
.B "trell\ \ "
Trellis-Quantisierung.
Hiermit wird die optimale Encodierung für jeden 8x8-Block gefunden.
Die Trellis-Quantisierung ist bei gegenseitiger Abschätzung von PSNR-Wert gegen
die Bitrate optimal (unter der Annahme, dass durch die IDCT keine
Rundungsfehler ins Spiel kommen \- was natürlich nicht der Fall ist).
Sie findet einfach einen Block für das Minimum von Fehler und lambda*Bits.
.PD 0
.RSs
.IPs lambda
vom Quantisierungsparameter (QP) abhängige Konstante
.IPs "bits\ "
Menge der für die Encodierung eines Blocks benötigten Bits
.IPs error
Summe der quadrierten Quantisierungsfehler
.RE
.PD 1
.
.TP
.B "cbp\ \ \ \ "
Ratenverzerrtes optimal codiertes Blockmuster (coded block pattern).
Wird dasjenige codierte Blockmuster auswählen, das Verzerrung + lambda*Rate
minimiert.
Dies kann nur zusammen mit der Trellis-Quantisierung benutzt werden.
.
.TP
.B "mv0\ \ \ \ "
Versuche jeden Macroblock mit Motion-Vector=<0,0> zu encodieren und wähle
den besseren.
Dies hat keinen Effekt, falls mbd=0.
.
.TP
.B mv0_threshold=<jede nicht-negative Ganzzahl>
Wenn umgebende Bewegungsvektoren <0,0> sind und die Auswertung der
Bewegungsabschätzung des aktuellen Blocks kleiner als mv0_threshold ist, so
wird <0,0> für den Bewegungsvektor benutzt und jede weitere
Bewegungsabschätzung wird übersprungen (Standard: 256).
mv0_threshold auf 0 abzusenken kann eine leichte (0.01dB) Erhöhung des PSNR
zur Folge haben und das encodierte Video möglicherweise leicht besser aussehen
lassen; mv0_threshold auf über 320 zu erhöhen führt zu einem niedrigeren PSNR
und visueller Qualität.
Höhere Werte beschleunigen die Encodierung ganz leicht (normalerweise weniger
als 1%, abhängig von den anderen verwendeten Optionen).
.br
.I ANMERKUNG:
Diese Option setzt nicht voraus, dass mvm0 aktiviert ist.
.
.TP
.B qprd (nur mit mbd=2)
ratenverzerrter optimaler Quantisierungsparameter bei gegebenem lambda für
jeden Macroblock
.
.TP
.B last_pred=<0\-99>
Menge der Bewegungsvorhersagen vom vorigen Frame
.PD 0
.RSs
.IPs 0
(Standard)
.IPs a
Benutzt ein 2a+1 x 2a+1 Macroblockquadrat von Motion-Vector-Vorhersagen vom
vorigen Frame.
.RE
.PD 1
.
.TP
.B preme=<0\-2>
"pre-pass"-Bewegungsabschätzung
.PD 0
.RSs
.IPs 0
deaktiviert
.IPs 1
nur nach Intraframes (Standard)
.IPs 2
immer
.RE
.PD 1
.
.TP
.B subq=<1\-8>
"subpel refinement"-Qualität (für qpel) (Standard: 8 (hohe Qualität))
.br
.I ANMERKUNG:
Diese Einstellung hat signifikante Auswirkung auf die Geschwindigkeit.
.
.TP
.B refs=<1\-8>
Anzahl der Referenz-Frames, die bei der Bewegungsabschätzung berücksichtigt
werden sollen (nur bei Snow) (Standard: 1)
.
.TP
.B "psnr\ \ \ "
Gibt den maximalen Signal-zu-Rauschabstand (peak signal to noise ratio) für
das komplette Video nach dem Encodieren aus und speichert die PSNR-Werte für
jedes Bild in einer Datei der Form 'psnr_hhmmss.log'.
Ausgegebene Werte haben die Einheit dB (Dezibel), je höher desto besser.
.
.TP
.B mpeg_quant
Benutze MPEG-Quantisierungsparameter anstelle von H.263.
.
.TP
.B "aic\ \ \ \ "
Aktiviere AC-Vorhersage für MPEG-4 oder fortgeschrittene Intra-Vorhersage
(advanced intra prediction) für H.263+.
Dies wird die Qualität leicht erhöhen (um die 0.02 dB PSNR) und die Encodierung
leicht verlangsamen (ungefähr 1%).
.br
.I ANMERKUNG:
vqmin sollte 8 oder höher sein für H.263+ AIC.
.
.TP
.B "aiv\ \ \ \ "
alternativer "inter vlc" für H.263+
.
.TP
.B "umv\ \ \ \ "
unbegrenzte Motion-Vectors (unlimited MVs) (nur bei H.263+)
Erlaubt die Encodierung von beliebig langen Motion-Vectors.
.
.TP
.B ibias=<\-256\-256>
Intra-Quantisierungsverzerrung (256 entspricht 1.0,
MPEG-Quantisierungsstandard: 96, H.263-artiger Quantisierungsstandard: 0)
.br
.I ANMERKUNG:
Die H.263-MMX-Quantisierung kann positive Verzerrungen nicht verarbeiten
(setze vfdct=1 oder 2), die MPEG-MMX-Quantisierung kann negative Verzerrungen
nicht verarbeiten (setze vfdct=1 oder 2).
.
.TP
.B pbias=<\-256\-256>
Inter-Quantisierungsverzerrung (256 entspricht 1.0,
MPEG-Quantisierungsstandard: 0, H.263-artiger Quantisierungsstandard: \-64)
.br
.I ANMERKUNG:
Die H.263-MMX-Quantisierung kann positive Verzerrungen nicht verarbeiten
(setze vfdct=1 oder 2), die MPEG-MMX-Quantisierung kann negative Verzerrungen
nicht verarbeiten (setze vfdct=1 oder 2).
.br
.I TIPP:
Eine eher positive Verzerrung (\-32 \- \-16 anstatt \-64) scheint den
PSNR-Wert zu verbessern.
.
.TP
.B (no)dct_decimate
Eliminiert dct-Blocks in P-Frames, die nur einen einzigen kleinen
Koeffizienten beinhalten (Standard: aktiviert).
Dies wird ein paar Details entfernen, daher wird es Bits einsparen, die auf
andere Frames verwendet werden können, was hoffentlich die wahrgenommene
Qualität insgesamt verbessert.
Wenn du nicht-Anime-Inhalt mit hoher Bitrate komprimierst, möchtest du diese
Option vielleicht deaktivieren, um so viele Details wie möglich beizubehalten.
.
.TP
.B nr=<0\-100000>
Rauschunterdrückung (noise reduction), 0 bedeutet deaktiviert.
0\-600 ist ein sinnvoller Bereich für typischen Inhalt, für etwas
verrauschteren Inhalt kannst du den Wert etwas erhöhen (Standard: 0).
Durch den geringen Einfluss auf die Geschwindigkeit möchtest du diese Option
der Rauschunterdrückung mit Filtern wie denoise3d oder hqdn3d vielleicht
vorziehen.
.
.TP
.B qns=<0\-3>
Rauschanpassung des Quantisierungsparameters, "Quantizer noise shaping".
Anstatt die Quantisierung so zu wählen, dass dem Quellvideo im Sinne von PSNR
am besten entsprochen wird, wählt die Rauschanpassung die Quantisierung so,
dass Rauschen (normalerweise Ringbildungen) durch ähnlichfrequenten Inhalt im
Bild maskiert wird.
Größere Werte sind langsamer, müssen aber nicht unbedingt zu besserer Qualität
führen.
Dies kann und sollte zusammen mit der Trellis-Quantisierung benutzt werden, in
welchem Falle diese (optimal für konstante Gewichtung) als Einstiegspunkt für
die iterative Suche benutzt wird.
.PD 0
.RSs
.IPs 0
deaktiviert (Standard)
.IPs 1
Verringere nur die absoluten Werte der Koeffizienten.
.IPs 2
Ändere Koeffizienten nur vor dem letzten von 0 verschiedenen Koeffizient + 1.
.IPs 3
Versuche alle.
.RE
.PD 1
.
.TP
.B inter_matrix=<durch Kommas getrennte Matrix>
Benutze eine eigene Intermatrix.
Braucht eine kommaseparierte Zeichenkette von 64 Integerwerten.
.
.TP
.B intra_matrix=<durch Kommas getrennte Matrix>
Benutze eine eigene Intramatrix.
Braucht eine kommaseparierte Zeichenkette von 64 Integerwerten.
.
.TP
.B vqmod_amp
experimentelle Modulation des Quantisierungsparameters
.
.TP
.B vqmod_freq
experimentelle Modulation des Quantisierungsparameters
.
.TP
.B "dc\ \ \ \ \ "
Intra-DC-Genauigkeit in Bits (Standard: 8).
Wenn du vcodec=mpeg2video angibst, kann dieser Wert 8, 9, 10 oder 11 sein.
.
.TP
.B cgop (siehe auch sc_threshold)
Schließt alle GOPs.
Funktioniert momentan nur, wenn die Szenenwechselerkennung deaktiviert ist
(sc_threshold=1000000000).
.
.TP
.B (no)lowdelay
Setzt den low-delay-Flag für MPEG-1/2 (deaktiviert B-Frames).
.
.TP
.B vglobal=<0\-3>
Kontrolliere das Schreiben globaler Videoheader.
.PD 0
.RSs
.IPs 0
Der Codec entscheidet, wo globale Header geschrieben werden (Standard).
.IPs 1
Schreibe globale Header nur in Extradata (benötigt für .mp4/MOV/NUT).
.IPs 2
Schreibe globale Header nur vor Keyframes.
.IPs 3
Kombiniere 1 und 2.
.RE
.PD 1
.
.TP
.B aglobal=<0\-3>
Das gleiche wie vglobal für Audioheader.
.
.TP
.B level=<Wert>
Setze CodecContext Level.
Benutze 31 oder 41, um das Video auf einer Playstation 3 abspielen zu können.
.
.TP
.B skip_exp=<0\-1000000>
FIXME: Dokumentiere diese Option.
.
.TP
.B skip_factor=<0\-1000000>
FIXME: Dokumentiere diese Option.
.
.TP
.B skip_threshold=<0\-1000000>
FIXME: Dokumentiere diese Option.
.
.
.SS nuv (\-nuvopts)
.
NuppelVideo basiert auf RTJPEG und LZO.
Normalerweise werden Frames zuerst mit RTJPEG encodiert und dann mit LZO
komprimiert; es ist jedoch möglich, entweder einen oder beide Durchgänge zu
deaktivieren.
Als Ergebnis kannst du also tatsächlich raw i420, LZO-komprimiertes i420,
RTJPEG oder normales LZO-komprimiertes RTJPEG ausgeben.
.br
.I ANMERKUNG:
Die nuvrec-Dokumentation enthält einige Anweisungen und Beispiele zu
Einstellungen, die für die meisten TV-Encodierungen genutzt werden können.
.
.TP
.B c=<0\-20>
Chrominanzschwellenwert (Standard: 1)
.
.TP
.B l=<0\-20>
Helligkeitsschwellenwert (Standard: 1)
.
.TP
.B "lzo\ \ \ \ "
Aktiviert LZO-Kompression (Standard).
.
.TP
.B "nolzo\ \ "
Deaktiviert LZO-Kompression.
.
.TP
.B q=<3\-255>
Qualitätslevel (Standard: 255)
.
.TP
.B "raw \ \ \ "
Deaktiviert RTJPEG-Encodierung.
.
.TP
.B "rtjpeg\ "
Aktiviert RTJPEG-Encodierung (Standard).
.
.
.SS xvidenc (\-xvidencopts)
.
Es sind drei Modi verfügbar: konstante Bitrate (CBR), feste
Quantisierungsparameter und Encodieren in zwei Durchläufen (two-pass).
.
.TP
.B pass=<1|2>
Gibt die Nummer des Durchlaufs im Modus mit zwei Durchläufen an.
.
.TP
.B turbo (nur im Modus mit zwei Durchläufen)
Erhöht die Geschwindigkeit des ersten Durchgangs drastisch, indem schnellere
Algorithmen benutzt und CPU-intensive Optionen deaktiviert werden.
Dies wird den PSNR-Wert im Ganzen wahrscheinlich ein wenig verringern und Typ
und PSNR-Wert einzelner Frames ein wenig mehr verändern.
.
.TP
.B bitrate=<Wert> (nur bei CBR oder im Modus mit zwei Durchläufen)
Setzt die zu benutzende Bitrate in kBits/\:Sekunde, wenn der Wert < 16000 ist,
oder in Bits/\:Sekunde, wenn der Wert > 16000 ist.
Ist <Wert> negativ, so benutzt Xvid dessen absoluten Wert als Zielgröße des
Videos (in kBytes) und berechnet die zugehörige Bitrate automagisch.
(Standard: 687 kBits/s)
.
.TP
.B fixed_quant=<1\-31>
Aktiviert den Modus mit festen Quantisierungsparametern und legt den zu
benutzenden Quantisierungsparameter fest.
.
.TP
.B zones=<Zone0>[/<Zone1>[/...]] (nur bei CBR oder Modus mit zwei Durchläufen)
Vom Benutzer angegebene Qualität für bestimmte Abschnitte (Ende, Abspann, ...).
Jede Zone hat die Form <Start-Frame>,<Modus>,<Wert>, wobei <Modus> einer der
folgenden sein kann:
.PD 0
.RSs
.IPs "q"
Überschreiben des konstanten Quantisierungsparameters, wobei Wert=<2.0\-31.0>
den Wert des Quantisierungsparameters angibt.
.IPs "w"
Überschreiben der Gewichtung der Ratenkontrolle, wobei Wert=<0.01\-2.00> die
Qualitätskorrektur in % angibt.
.RE
.PD 1
.sp 1
.RS
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs zones=90000,q,20
Encodiere alles Frames ab Frame 90000 mit einem konstanten
Quantisierungsparameter von 20.
.IPs zones=0,w,0.1/10001,w,1.0/90000,q,20
Encodiere alle Frames 0\-10000 mit 10% der Bitrate und alle Frames von 90000
bis zum Ende mit einem konstanten Quantisierungsparameter von 20.
Beachte, dass die zweite Zone benötigt wird, um die erste Zone zu beschränken,
da ohne diese alles bis zu Frame 89999 mit 10% der Bitrate encodiert würde.
.RE
.PD 1
.
.TP
.B me_quality=<0\-6>
Diese Option kontrolliert das Bewegungsabschätzungssubsystem.
Je höher der Wert, desto genauer sollte die Abschätzung sein (Standard: 6).
Je genauer die Abschätzung ist, desto mehr Bits können eingespart werden.
Die Präzision wird auf Kosten der CPU-Zeit erreicht; benutze also niedrigere
Werte, falls du Encodierung in Echtzeit brauchst.
.
.TP
.B (no)qpel
MPEG-4 benutzt normalerweise eine Präzision halber Pixel für die
Bewegungsabschätzung.
Der Standard schlägt einen Modus vor, in dem es Encodern erlaubt ist, eine
Präzision von einem viertel Pixel zu verwenden.
Dies führt gewöhnlicherweise zu einem schärferen Bild.
Nachteilig ist, dass dies einen großen Einfluss auf die Bitrate hat, und
manchmal verhindert dies auch ein besseres Bild bei fester Bitrate.
Es ist besser, durch Tests im Einzelfall zu entscheiden, ob es sich lohnt,
diese Option zu aktivieren.
.
.TP
.B (no)gmc
Aktiviert Globale Bewegungskompensation (Global Motion Compensation), welche
Xvid spezielle Frames (GMC-Frames) generieren lässt, die sich gut für
Pan/\:Zoom/\:Drehung von Bildern eignen.
Ob das Benutzen dieser Option Bits einspart, hängt sehr vom Quellmaterial ab.
.
.TP
.B (no)trellis
Die Trellis-Quantisierung ist eine Art adaptive Quantisierungsmethode, die Bits
einspart, indem sie die Quantisierungskoeffizienten so verändert, dass sie vom
Entropie-Encoder stärker komprimiert werden können.
Der Einfluss auf die Qualität ist gut, und falls VHQ für dich zu viel
CPU-Leistung braucht, kann diese Option eine gute Möglichkeit sein, mit
weniger Aufwand als bei VHQ ein paar Bits einzusparen (und bei fester Bitrate
die Qualität zu erhöhen) (Standard: aktiviert).
.
.TP
.B (no)cartoon
Aktiviere diese Option, wenn die zu encodierende Sequenz ein Anime/\:Cartoon
ist.
Sie modifiziert ein paar Xvid-interne Schwellenwerte, so dass Xvid bei
Frametypen und Motion-Vectors für flach aussehende Cartoons bessere
Entscheidungen trifft.
.
.TP
.B (no)chroma_me
Normalerweise benutzt der Algorithmus für die Bewegungsabschätzung nur
Helligkeitsinformationen, um den besten Motion-Vector zu finden.
Für manches Videomaterial jedoch kann die Benutzung der Chrominanzebenen
helfen, bessere Resultate zu finden.
Diese Einstellung (de)aktiviert die Benutzung der Chrominanzebenen für die
Bewegungsabschätzung (Standard: aktiviert).
.
.TP
.B (no)chroma_opt
Aktiviert einen Vorfilter für die Farbtonoptimierung.
Er wird ein paar Tricks auf die Farbinformationen anwenden, um Kammeffekte an
Kanten zu minimieren.
Er wird die Qualität auf Kosten der Zeit für die Encodierung verbessern.
Naturgemäß verringert er den PSNR-Wert, da die mathematische Abweichung zum
Originalbild größer wird, aber der subjektive Eindruck wird besser sein.
Da er Farbinformationen benutzt, solltest du ihn bei Encodierung im
Schwarz/weiß-Modus abschalten.
.
.TP
.B (no)hq_ac
Aktiviert die 'High Quality AC coefficient prediction', also die Vorhersage
von Koeffizienten für Intra-Frames von benachbarten Blöcken (Standard:
aktiviert).
.
.TP
.B vhq=<0\-4>
Der Algorithmus für die Bewegungsabschätzung basiert auf der Suche im
normalen Farbraum und versucht, einen Motion-Vector zu finden, der die
Differenz zwischen dem ursprünglichen und dem encodierten Frame minimiert.
Ist diese Option aktiviert, benutzt Xvid außerdem den Frequenzbereich
(frequency domain, DCT), um nach einem Motion-Vector zu suchen, der nicht nur
den Unterschied in einem bestimmten Gebiet, sondern außerdem die encodierte
Länge eines Blocks minimiert.
Vom schnellsten zum langsamsten:
.PD 0
.RSs
.IPs 0
aus
.IPs 1
Entscheidung des Modus (Inter-/\:Intra-Macro-Block) (Standard)
.IPs 2
begrenzte Suche
.IPs 3
mittlere Suche
.IPs 4
ausgiebige Suche
.RE
.PD 1
.
.TP
.B (no)lumi_mask
Adaptive Quantisierung erlaubt den Quantisierungsparametern der Macro-Blöcke,
sich innerhalb eines Frames zu unterscheiden.
Dies ist eine 'psychosensorische' Einstellung, die die Tatsache nutzen soll,
dass das menschliche Auge dazu neigt, in sehr hellen und sehr dunklen Teilen
eines Bildes weniger Details zu erkennen.
Sie komprimiert diese Bereiche stärke als mittlere, was Bits einspart, die
dafür für andere Frames benutzt werden können, so wird die subjektive Qualität
im Ganzen erhöht, der PSNR-Wert dabei jedoch möglicherweise reduziert.
.
.TP
.B (no)grayscale
Sorgt dafür, dass Xvid die Chrominanzebenen verwirft, so dass das encodierte
Video schwarz/weiß wird.
Beachte, dass dies den Encodierungsvorgang nicht beschleunigt, es werden in
der letzten Stufe der Encodierung einfach keine Farbdaten geschrieben.
.
.TP
.B (no)interlacing
Encodiert die Felder von interlaced Videomaterial.
Schalte diese Option bei interlaced Inhalten ein.
.br
.I ANMERKUNG:
Solltest du das Video anders skalieren, brauchst du einen Skalierer, der
interlaced Material bemerkt; du kannst einen solchen mit \-vf
scale=<Breite>:<Höhe>:1 aktivieren.
.
.TP
.B min_iquant=<0\-31>
minimaler Wert für den Quantisierungsparameter für Intra-Frames (Standard: 2)
.
.TP
.B max_iquant=<0\-31>
maximaler Wert für den Quantisierungsparameter für Intra-Frames (Standard: 2)
.
.TP
.B min_pquant=<0\-31>
minimaler Wert für den Quantisierungsparameter für P-Frames (Standard: 2)
.
.TP
.B max_pquant=<0\-31>
maximaler Wert für den Quantisierungsparameter für P-Frames (Standard: 31)
.
.TP
.B min_bquant=<0\-31>
minimaler Wert für den Quantisierungsparameter für B-Frames (Standard: 2)
.
.TP
.B max_bquant=<0\-31>
minimaler Wert für den Quantisierungsparameter für B-Frames (Standard: 31)
.
.TP
.B min_key_interval=<Wert> (nur im Modus mit zwei Durchläufen)
minimale Anzahl Frames zwischen zwei Keyframes (Standard: 0)
.
.TP
.B max_key_interval=<Wert>
maximale Anzahl Frames zwischen zwei Keyframes (Standard: 10*fps)
.
.TP
.B quant_type=<h263|mpeg>
Bestimmt die zu benutzende Quantisierungsmethode.
Bei hohen Bitraten wirst du meinen, dass die MPEG-Quantisierung mehr Details
behält.
Bei niedrigen Bitraten wird die Glättung von H.263 weniger Blockartefakte
liefern.
Bei der Benutzung eigener Matrizen
.B muss
die MPEG-Quantisierung benutzt werden.
.
.TP
.B quant_intra_matrix=<Dateiname>
Lädt eine Datei mit einer eigenen Intra-Matrix.
Du kannst eine solche mit dem Matrixeditor von xvid4conf erstellen.
.
.TP
.B quant_inter_matrix=<Dateiname>
Lädt eine Datei mit einer eigenen Inter-Matrix.
Du kannst eine solche mit dem Matrixeditor von xvid4conf erstellen.
.
.TP
.B keyframe_boost=<0\-1000> (nur im Modus mit zwei Durchläufen)
Diese Option verlagert einige Bits aus dem Vorrat anderer Frametypen zu
Intra-Frames, so dass die Qualität von Keyframes verbessert wird.
Diese Menge ein extra Anteil, daher wird ein Wert von 10 den Keyframes 10%
mehr Bits als sonst zuteilen (Standard: 0).
.
.TP
.B kfthreshold=<Wert> (nur im Modus mit
zwei Durchläufen)
Arbeitet mit kfreduction zusammen.
Bestimmt den minimalen Abstand, unter dem zwei Frames als aufeinanderfolgend
gelten und gemäß kfreduction anders behandelt werden (Standard: 10).
.
.TP
.B kfreduction=<0-\100> (nur im Modus mit zwei Durchläufen)
Die oberen beiden Einstellungen können genutzt werden, um die Größe von
Keyframes anzupassen, die du für zu nah hintereinander zum ersten hältst.
kfthreshold setzt den Bereich, in dem Keyframes reduziert werden, und
kfreduction bestimmt die Reduktion der Bitrate, die angewendet wird.
Der letzte Intra-Frame wird normal behandelt (Standard: 30).
.
.TP
.B max_bframes=<0\-4>
Maximale Anzahl der B-Frames, die zwischen Intra- und P-Frames gesetzt wird
(Standard: 2).
.
.TP
.B bquant_ratio=<0\-1000>
Verhältnis von B-Frames zu nicht-B-Frames bei der Quantisierung, 150=1.50
(Standard: 150).
.
.TP
.B bquant_offset=<\-1000\-1000>
Offset von B-Frames zu nicht-B-Frames bei der Quantisierung, 100=1.00
(Standard: 100).
.
.TP
.B bf_threshold=<\-255\-255>
Diese Option erlaubt dir, die Priorität für die Benutzung von B-Frames
anzugeben.
Je höher der Wert, desto wahrscheinlicher wird ein B-Frame benutzt (Standard:
0).
Vergiss nicht, dass B-Frames normalerweise einen höheren
Quantisierungsparameter benutzen, daher kann aggressives Erzeugen von B-Frames
zu schlechterer visueller Qualität führen.
.
.TP
.B (no)closed_gop
Diese Option weist Xvid an, jede GOP (Group Of Pictures, Gruppe von Bildern,
die von zwei I-Frames begrenzt sind) zu schließen, was die GOPs unabhängig
voneinander macht.
Dies bedeutet lediglich, dass der letzte Frame einer GOP entweder ein P- oder
ein N-Frame ist, nicht aber ein B-Frame.
Es ist normalerweise sinnvoll, diese Option zu aktivieren (Standard:
aktiviert).
.
.TP
.B (no)packed
Diese Option ist dazu gedacht, Probleme mit der Framereihenfolge zu lösen bei
der Encodierung in Containerformate wie AVI, die mit aus der Reihenfolge
gekommenen Frames nicht umgehen können.
In der Praxis können die meisten (sowohl Software- als auch Hardware-) Decoder
die Framereihenfolge richtig handhaben, es kann sie sogar verwirren, wenn
diese Option aktiviert ist, daher kannst du sie mit Sicherheit weglassen;
aktiviere sie nur, wenn du genau weißt, was du tust.
.br
.I WARNUNG:
Dies erzeugt einen ungültigen Bitstream, der höchstwahrscheinlich von keinem
ISO-MPEG-4-Decoder außer DivX/\:libavcodec/\:Xvid dekodiert werden kann.
.br
.I WARNUNG:
Dies wird außerdem eine vorgetäuschte DivX-Version in der Datei speichern,
welche die Fehlerkorrekturmechanismen mancher Decoder verwirren kann.
.
.TP
.B frame_drop_ratio=<0\-100> (nur bei max_bframes=0)
Diese Einstellung erlaubt die Erstellung von Videostreams mit variabler
Framerate.
Der Wert dieser Einstellung gibt den Schwellenwert an, ab dem ein Frame nicht
encodiert wird, wenn nämlich die Differenz des folgenden zum vorigen Frame
kleiner oder gleich diesem Schwellenwert ist (ein sogenanntes n-vop wird in
den Stream geschrieben).
Bei der Wiedergabe wird bei Erreichen eines n-vop der vorige Frame dargestellt.
.br
.I WARNUNG:
Rumspielen mit dieser Einstellung kann zu ruckelnden Videos führen, benutze
sie also auf eigenes Risiko!
.
.TP
.B rc_reaction_delay_factor=<Wert>
Dieser Parameter kontrolliert die Anzahl der Frames, die die
CBR-Bitratenkontrolle wartet, bevor sie auf Änderungen der Bitrate reagiert
und sie anpasst, um in einer durchschnittlich großen Spanne von Frames eine
konstante Bitrate zu erhalten.
.
.TP
.B rc_averaging_period=<Wert>
Eine wirklich konstante Bitrate ist nur schwer zu erreichen.
Abhängig vom Videomaterial kann die Bitrate variabel und schwer vorauszusagen
sein.
Daher benutzt der Xvid-Encoder einen durchschnittlichen Zeitraum, für den er
eine gegebene Anzahl Bits garantiert (minus einer kleinen Schwankung).
Diese Option setzt die Anzahl der Frames, über denen Xvid die Bitrate mittelt,
um eine konstante Bitrate zu erreichen.
.
.TP
.B rc_buffer=<Wert>
Größe des Bitratenkontrollpuffers
.
.TP
.B curve_compression_high=<0\-100>
Diese Einstellung erlaubt Xvid, einen gewissen Teil der Bits weg von Szenen
mit hohen Bitraten zu nehmen und dem allgemeinen Vorrat für Bits hinzuzufügen.
Du kannst diese Option benutzen, falls du einen Film mit so vielen schnell
bewegten Szenen hast, dass die Szenen mit geringeren Bitraten anfangen,
schlecht auszusehen (Standard: 0).
.
.TP
.B curve_compression_low=<0\-100>
Diese Einstellung erlaubt Xvid, einen gewissen Teil der allgemein verfügbaren
Bits den Szenen zuzuteilen, die mit niedrigeren Bitraten codiert
werden, wobei dafür dem ganzen Video ein paar Bits weggenommen werden.
Die kann sich nützlich erweisen, wenn du ein paar Szenen mit eigentlich
niedriger Bitrate hast, die trotzdem Blockeffekte zeigen (Standard: 0).
.
.TP
.B overflow_control_strength=<0\-100>
Während des ersten Durchlaufs im Modus mit zwei Durchläufen wird eine skalierte
Bitratenkurve berechnet.
Die Differenz zwischen dieser erwarteten Kurve und dem bei der Encodierung
erzielten Resultat wird Overflow genannt.
Offensichtlich versucht die Bitratenkontrolle beim zweiten Durchlauf, diesen
Overflow zu
kompensieren, indem er über die nächsten Frames verteilt wird.
Diese Einstellung kontrolliert, wie stark ein Overflow für jeden neuen
Frame verteilt wird.
Niedrige Werte erlauben eine lässige Kontrolle des Overflows, so dass sehr
hohe Bitraten langsamer abgefangen werden (was bei kurzen Clips die
Präzision verringern kann).
Hohe Werte machen Änderungen der Bit-Verteilung abrupter, möglicherweise sogar
zu abrupt, wenn du zu hohe Werte wählst, was zu Artefakten führen kann
(Standard: 5).
.br
.I ANMERKUNG:
Diese Einstellung hat großen Einfluss auf die Qualität, spiele damit also nur
vorsichtig!
.
.TP
.B max_overflow_improvement=<0\-100>
Während der Zuteilung von Bits für Frames kann die Kontrolle für den Overflow
die Größe eines Frames erhöhen.
Dieser Parameter bestimmt den maximalen Anteil, um den dieser Kontrolle
erlaubt wird, die Größe eines Frames im Vergleich zu der idealen Kurve zu
erhöhen (Standard: 5).
.
.TP
.B max_overflow_degradation=<0\-100>
Während der Zuteilung von Bits für Frames kann die Kontrolle für den Overflow
die Größe eines Frames verringern.
Dieser Parameter bestimmt den maximalen Anteil, um den dieser Kontrolle
erlaubt wird, die Größe eines Frames im Vergleich zu der idealen Kurve zu
verringern (Standard: 5).
.
.TP
.B container_frame_overhead=<0...>
Gibt den durchschnittlichen Frame-Overhead pro Frame in Bytes an.
Meistens geben Benutzer die Zielbitrate für ein Video an, ohne dabei den
Overhead des Videocontainers zu beachten.
Dieser kleine aber (meistens) konstante Overhead kann dazu führen, dass die
gewünschte Dateigröße überschritten wird.
Xvid erlaubt Benutzern, den Anteil des Overheads anzugeben, der pro Frame
erzeugt wird (gib nur einen Durchschnittswert pro Frame an).
0 hat eine spezielle Bedeutung, sie lässt Xvid eigene Standardwerte
wählen (Standard: 24 \- durchschnittlicher Overhead für AVIs).
.
.TP
.B profile=<profile_name>
Beschränkt Optionen und VBV (höchste Bitrate innerhalb kurzer Zeit) anhand
Simple, Advanced-Simple und der DivX-Profile.
Resultierende Videos sollten von Standalone-Geräten, die diese
Profilspezifikationen unterstützen, abspielbar sein.
.PD 0
.RSs
.IPs unrestricted
keine Beschränkungen (Standard)
.IPs "sp0\ \ "
Simple-Profil Level 0
.IPs "sp1\ \ "
Simple-Profil Level 1
.IPs "sp2\ \ "
Simple-Profil Level 2
.IPs "sp3\ \ "
Simple-Profil Level 3
.IPs "asp0\ "
Advanced-Simple-Profil Level 0
.IPs "asp1\ "
Advanced-Simple-Profil Level 1
.IPs "asp2\ "
Advanced-Simple-Profil Level 2
.IPs "asp3\ "
Advanced-Simple-Profil Level 3
.IPs "asp4\ "
Advanced-Simple-Profil Level 4
.IPs "asp5\ "
Advanced-Simple-Profil Level 5
.IPs dxnhandheld
DXN-Handheld-Profil
.IPs dxnportntsc
DXN-Portable NTSC-Profil
.IPs dxnportpal
DXN-Portable PAL-Profil
.IPs dxnhtntsc
DXN-Home-Theater NTSC-Profil
.IPs dxnhtpal
DXN-Home-Theater PAL-Profil
.IPs dxnhdtv
DXN-HDTV-Profil
.RE
.PD 1
.RS
.I ANMERKUNG:
Diese Profile sollten in Verbindung mit einem entsprechenden \-ffourcc benutzt
werden.
Generell anwendbar ist DX50, da manche Geräte Xvid nicht, die meisten aber
DivX erkennen.
.RE
.
.TP
.B par=<Modus>
Gibt den Modus für das Pixel-Aspektverhältnis (Pixel Aspect Ratio, PAR) an,
also dem Größenverhältnis der Pixel (nicht zu verwechseln mit dem Aspekt auf
dem Bildschirm (Display Aspect Ratio, DAR).
PAR ist das Verhältnis von Breite zu Höhe eines einzelnen Pixels.
Beide Verhältnisse stehen also in folgendem Zusammenhang: DAR = PAR *
(Breite/\:Höhe).
.br
MPEG-4 definiert 5 verschiedene Pixel-Aspekte sowie einen erweiterten, der es
erlaubt, einen eigenen spezifischen Pixel-Aspekt anzugeben.
Fünf Standardmodi können angegeben werden:
.PD 0
.RSs
.IPs vga11
Das ist der normale PAR für Inhalte auf dem PC.
Pixel sind hierbei einheitliche Quadrate.
.IPs pal43
PAL-Standard 4:3 PAR.
Pixel sind Rechtecke.
.IPs pal169
das gleiche wie oben
.IPs ntsc43
das gleiche wie oben
.IPs ntsc169
das gleiche wie oben (Vergiss nicht, das genaue Verhältnis anzugeben.)
.IPs "ext\ \ "
Erlaubt dir, einen eigenen Aspekt (PAR) mit par_width und par_height anzugeben.
.RE
.PD 1
.RS
.I ANMERKUNG:
Normalerweise ist das Setzen der Optionen aspect und autoaspect ausreichend.
.RE
.
.TP
.B par_width=<1\-255> (nur bei par=ext)
Gibt die Breite des Pixel-Größenverhältnisses an.
.
.TP
.B par_height=<1\-255> (nur bei par=ext)
Gibt die Höhe des Pixel-Größenverhältnisses an.
.
.TP
.B aspect=<x/y | f (Fließkommazahl)>
Speichere den Filmaspekt intern, wie bei MPEG-Dateien.
Dies ist eine viel elegantere Lösung als den Film neu zu skalieren, da die
Qualität nicht verringert wird.
MPlayer und ein paar andere Player werden diese Dateien korrekt wiedergeben,
andere werden das Größenverhältnis falsch darstellen.
Der Parameter für das Verhältnis kann als Bruch oder Fließkommawert angegeben
werden.
.
.TP
.B (no)autoaspect
Das gleiche wie die Option aspect, wobei jedoch das Verhältnis automatisch
berechnet wird, Veränderungen in der Filterkette wie
crop/\:expand/\:scale/\:etc.\& werden dabei berücksichtigt.
.
.TP
.B "psnr\ \ \ "
Gib den PSNR-Wert (Peak Signal to Noise Ratio) des kompletten Films nach dem
Encodieren aus und speichere ihn für jeden einzelnen Frame in einer Datei der
Form 'psnr_hhmmss.log' im aktuellen Verzeichnis.
Die gelieferten Werte haben die Einheit dB (Dezibel), je höher desto besser.
.
.TP
.B "debug\ \ "
Speichert Statistiken für jeden einzelnen Frame in ./\:xvid.dbg.
(Dies ist nicht das Logfile des Modus mit zwei Durchläufen.)
.RE
.
.PP
.sp 1
Die folgende Option ist nur bei Xvid 1.1.x verfügbar.
.
.TP
.B bvhq=<0|1>
Diese Einstellung erlaubt mögliche Auswahlen des Encodierungsvorgangs für
B-Frames, einen Raten-störungsoptimierten Operator verwenden, was für
P-Frames mit der Option vhq getan wird.
Dies liefert besser aussehende B-Frames, während fast keine
Performance-Einbußen auftreten (Standard: 1).
.
.PP
.sp 1
Die folgende Option ist nur bei Xvid 1.2.x verfügbar.
.
.TP
.B threads=<0\-n>
Erzeugt n Threads für die Bewegungsabschätzung (Standard: 0).
Die Bildhöhe geteilt durch 16 ergibt die maximale Anzahl Threads, die
verwendet werden kann.
.
.
.SS x264enc (\-x264encopts)
.
.TP
.B bitrate=<Wert>
Setzt die durchschnittliche Bitrate auf kbits/\:Sekunde (Standard: aus).
Da die lokale Bitrate variieren kann, ist es möglich, dass dieser
Durchschnittswert für sehr kurze Videos ungenau berechnet wird (siehe ratetol).
Konstante Bitraten können erreicht werden, indem man diese Option mit
vbv_maxrate kombiniert, allerdings vermindert das die Qualität signifikant.
.
.TP
.B qp=<0\-51>
Diese Option wählt den Quantizer für P-Frames.
Intra- und B-Frames werden mit diesem Wert jeweils durch ip_factor und
pb_factor verrechnet.
20\-40 ist ein brauchbarer Bereich.
Niedrigere Werte bewirken geringere Verlusten bei höheren Bitraten.
0 ist verlustfrei.
Beachte, dass die Quantisierung bei H.264 anders funktioniert als bei
MPEG-1/2/4:
Die Quantisierungsparameter (QP) von H.264 liegen auf einer logarithmischen
Skala.
Das Mapping ist ungefähr H264QP = 12 + 6*log2(MPEGQP).
Beispielsweise ist MPEG bei QP=2 vergleichbar mit H.264 bei QP=18.
.
.TP
.B crf=<1.0\-50.0>
Aktiviert den "constant quality mode" und legt die Qualität fest.
Die Skala ist ähnlich der des QP.
Ähnlich wie die Bitraten-basierten Modi ermöglicht
dies, für jeden Frame einen anderen QP festzulegen, je nach dessen Komplexität.
.
.TP
.B pass=<1\-3>
2- oder 3-pass-Modus (d.h. mit 2 oder 3 Durchläufen) aktivieren.
Es wird empfohlen, immer im 2- oder 3-pass-Modus zu enkodieren, da dies zu
einer besseren Bit-Verteilung und allgemein besseren Qualität führt.
.PD 0
.RSs
.IPs 1
Erster Durchlauf
.IPs 2
Zweiter Durchlauf (bei Encodierung mit zwei Durchläufen)
.IPs 3
n-ter Durchlauf (zweiter und dritter Durchlauf des 3-Durchläufe-Modus)
.RE
.RS
Und so funktioniert es bzw.\& so wird es angewandt:
.br
Der erste Durchlauf (pass=1) erstellt Statistiken über das Video und
schreibt diese in eine Datei.
Es bietet sich an, einige CPU-intensive Optionen zu deaktivieren; abgesehen von
denen, die als Voreinstellung aktiviert sind.
.br
Im 2-pass-Modus liest der zweite Durchlauf (pass=2) diese Datei wieder ein und
berechnet auf dieser Grundlage die Bitratenkontrolle.
.br
Im 3-pass-Modus tut der zweite Durchlauf (pass=3, dies ist kein Tippfehler)
beides: Zuerst liest er die Statistiken ein, dann überschreibt er sie.
Du kannst alle Optionen verwenden, außer vielleicht den sehr CPU-intensiven.
.br
Der dritte Durchlauf (pass=3) macht das gleiche wie der zweite Durchlauf,
außer dass er die Statisitiken des zweiten Durchlaufs verwendet.
Du kannst alle Optionen verwenden, einschließlich der sehr CPU-intensiven.
.br
Der erste Durchlauf kann entweder eine durchschnittliche Bitrate (ABR) oder
einen konstanten Quantizer verwenden.
ABR wird empfohlen, da dafür nicht das Ermitteln eines Quantizers nötig ist.
Nachfolgende Durchläufe sind ABR; es muss eine Bitrate angegeben werden.
.REss
.
.TP
.B turbo=<0\-2>
Schneller erster Durchlauf.
Während des ersten Durchlaufs des Encodierens mit mehreren Durchläufen kann
die Geschwindigkeit durch Deaktivieren einiger Optionen gesteigert werden \-
ohne bzw. ohne merkliche Minderung der Qualität des letzten Durchlaufs.
.PD 0
.RSs
.IPs 0
deaktiviert (Standard)
.IPs 1
Reduziere subq und frameref und deaktiviere einige "inter macroblock partitions
analysis"-Modi.
.IPs 2
Reduziere subq und frameref auf 1, verwende eine "diamond ME"-Suche und
deaktiviere alle "partitions analysis"-Modi.
.RE
.RS

Stufe 1 kann die Geschwindigkeit des ersten Durchlaufs bis auf das Doppelte
erhöhen, ohne das globale PSNR im Vergleich zu einem vollen ersten Durchlauf zu
verändern.
.br
Stufe 2 kann die Geschwindigkeit des ersten Durchlaufs bis auf das Vierfache
erhöhen \- bei einer Veränderung des PSNR von ca. +/\- 0.05dB im Vergleich zu
einem vollen ersten Durchlauf.
.REss
.
.TP
.B keyint=<Wert>
Setzt das maximale Intervall zwischen IDR-Frames (Standard: 250).
Höhere Werte sichern Bits und erhöhen dadurch die Qualität auf Kosten der
Suchpräzision.
Anders als MPEG-1/2/4 ist H.264 nicht von DCT-Versatz bei hohen keyint-Werten
betroffen.
.
.TP
.B keyint_min=<1\-keyint/2>
Setzt das minimale Intervall zwischen IDR-Frames (Standard: 25).
Wenn innerhalb dieses Intervalls Szenenwechsel stattfinden, werden sie dennoch
als Intra-Frames encodiert, sie starten aber nicht mit einem neuen GOP.
In H.264 begrenzen Intra-frames nicht unbedingt einen geschlossen GOP, da ein
P-Frame durch mehrere als nur den vorangehenden Frame vorausberechnet werden
kann (siehe auch frameref).
Daher sind Intra-Frames nicht notwendigerweise spulbar.
IDR-Frames verhindern, dass nachfolgende P-Frames sich auf einen Frame vor dem
IDR-Frame beziehen.
.
.TP
.B scenecut=<\-1\-100>
Legt fest, wie aggressiv zusätzliche Intra-Frames eingefügt werden (Standard:
40).
Mit geringen Werten für scenecut muss der Codec oft einen Intra-Frame einfügen,
wenn er den Wert für keyint übersteigen würde.
Gute Werte für scenecut finden evtl.\& eine bessere Position für Intra-Frames.
Hohe Werte setzen mehr Intra-Frames als nötig ein und verschwenden damit Bits.
\-1 schaltet die scenecut-Erkennung ab, dadurch werden Intra-Frames nur einmal
pro jedem anderen keyint-Frame eingesetzt, sogar wenn ein Szenenwechsel früher
stattfindet.
Diese ist nicht empfehlenswert und verschwendet Bitraten, denn als scenecuts
enkodierte P-Frames sind genau so groß wie I-Frames, ohne dabei aber den
"keyint counter" zurückzusetzen.
.
.TP
.B frameref=<1\-16>
Die Anzahl der vorhergehenden Frames, die zum Vorausberechnen in B- und
P-Frames
verwendet werden (Standard: 1).
Das ist besonders effektiv bei animierten Filmen; bei Realfilm-Material nehmen
die Verbesserungen bei mehr als etwa 6 Referenz-Frames ziemlich schnell ab.
Dies hat keinen Einfluss auf die Dekodiergeschwindigkeit, erhöht aber den zum
Encodieren benötigten Speicherbedarf.
Einige Dekodierer können maximal 15 Referenz-Frames behandeln.
.
.TP
.B bframes=<0\-16>
maximale Anzahl aufeinanderfolgender B-Frames zwischen Intra- and P-Frames
(Standard: 0)
.
.TP
.B (no)b_adapt
Legt automatisch fest, wann und wieviele B-Frames verwendet werden, bis maximal
zum o.a. Wert (Standard: an).
Falls diese Option deaktiviert ist, wird die maximale Anzahl für B-Frames
verwendet.
.
.TP
.B b_bias=<\-100\-100>
Erlaubt Einflussnahme auf die Funktion von b_adapt.
Ein höherer Wert für b_bias erzeugt mehr B-Frames (Standard: 0).
.
.TP
.B (no)b_pyramid
Ermöglicht die Verwendung von B-Frames als Referenz für die Vorhersage anderer
Frames.
Nehmen wir als Beispiel 3 aufeinanderfolgende Frames: I0 B1 B2 B3 P4.
Ohne diese Option verhalten sich B-Frames genau wie MPEG-[124].
Sie werden also in der Reihenfolge I0 P4 B1 B2 B3 kodiert, und alle B-Frames
werden auf Grundlage von I0 und P4 berechnet.
Mit dieser Option werden sie als I0 P4 B2 B1 B3 encodiert.
B2 ist das gleiche wie oben, jedoch wird B1 aus I0 and B2 berechnet, während B3
auf B2 und B4 basiert.
Das Ergebnis ist eine etwas bessere Komprimierung bei fast keinem
Geschwindigkeitsverlust.
Allerdings ist dies eine experimentelle Option: die Feinabstimmung fehlt noch,
und daher bringt sie möglicherweise keinen Vorteil.
Benötigt bframes >= 2.
Nachteil: Erhöht die Decodierungsverzögerung auf 2 Frames.
.
.TP
.B (no)deblock
Deblocking-Filter verwenden (Standard: an).
Da diese Option sehr wenig Zeit im Vergleich zum Qualitätsgewinn benötigt,
sollte sie nicht deaktiviert werden.
.
.TP
.B deblock=<\-6\-6>,<\-6\-6>
Der erste Parameter ist AlphaC0 (Standard: 0).
Dieser regelt Schwellenwerte für den H.264-Inloop-Deblocking-Filter.
Zunächst legt dieser Parameter den Höchstwert für die Änderung fest, den der
Filter auf jeden einzelnen Pixel anwenden darf.
Weiterhin beeinflusst dieser Parameter den Schwellenwert für den Unterschied,
der über die Kante hinaus gefiltert wird.
Positive Werte reduzieren blockförmige Strukturen, verwischen aber auch
Details.
.br
Der zweite Parameter ist Beta (Standard: 0).
Beeinflusst den Schwellwert für Details.
Sehr detailreiche Blöcke werden nicht gefiltert, da das Glätten durch den
Filter stärker auffallen würde als die ursprünglichen Blöcke.
.br
Die Standardeinstellung des Filters erreicht fast immer optimale Qualität,
daher ist es am besten, keine oder nur geringe Änderungen vorzunehmen.
Falls allerdings dein Quellmaterial schon Blöcke oder Rauschen aufweist und Du
diese entfernen möchtest, kannst Du den Wert etwas erhöhen.
.
.TP
.B (no)cabac
Verwende CABAC (Context-Adaptive Binary Arithmetic Coding) (Standard: an).
Verlangsamt geringfügig die Encodierung und Decodierung, spart aber für
gewöhnlich 10\-15% Bitrate.
Solange Du keinen großen Wert auf Geschwindigkeit bei der Decodierung legst,
solltest Du diese Option nicht deaktivieren.
.
.TP
.B qp_min=<1\-51> (ABR oder Modus mit zwei Durchläufen)
Minimaler Quantisierungsparameter, 10\-30 ist ein brauchbarer Bereich
(Standard: 10).
.
.TP
.B qp_max=<1\-51> (ABR oder Modus mit zwei Durchläufen)
Maximaler Quantisierungsparameter (Standard: 51)
.
.TP
.B qp_step=<1\-50> (ABR oder Modus mit zwei Durchläufen)
Maximaler Wert um den der Quantisierungsparameter zwischen Frames
erhöht/gesenkt werden kann (Standard: 4).
.
.TP
.B ratetol=<0.1\-100.0> (ABR oder Modus mit zwei Durchläufen)
Erlaubte Streuung der durchschnittlichen Bitrate (keine besonderen Einheiten)
.
.TP
.B vbv_maxrate=<Wert> (ABR oder Modus mit zwei Durchläufen)
Maximale lokale Bitrate in kBits/\:Sekunde (Standard: deaktiviert)
.
.TP
.B vbv_bufsize=<Wert> (ABR oder Modus mit zwei Durchläufen)
Mittelungsperiode für vbv_maxrate, in kBits
(Standard: keine, muss angegeben werden wenn vbv_maxrate aktiviert ist)
.
.TP
.B vbv_init=<0.0\-1.0> (ABR oder Modus mit zwei Durchläufen)
Anfängliche Pufferauslastung als Bruchteil von vbv_bufsize (Standard: 0.9)
.
.TP
.B ip_factor=<Wert>
Quantizer-Faktor zwischen Intra- und P-Frames (Standard: 1.4)
.
.TP
.B pb_factor=<Wert>
Quantizer-Faktor zwischen P- und B-Frames (Standard: 1.3)
.
.TP
.B qcomp=<0\-1> (ABR oder Modus mit zwei Durchläufen)
Komprimierung des Quantisierungsparameters (Standard: 0.6).
Ein niedrigerer Wert führt zu einer konstanteren Bitrate, während ein höherer
Wert zu einem konstanteren Quantisierungsparameter führt.
.
.TP
.B cplx_blur=<0\-999> (nur im Modus mit zwei Durchläufen)
Zeitliche Unschärfe der geschätzten Frame-Komplexität vor der
Kurvenkomprimierung (Standard: 20).
Niedrigere Werte ermöglichen einen volatileren Quantisierungsparameterwert,
höhere Werte forcieren sanftere Schwankungen.
cplx_blur stellt sicher, dass jeder Intra-Frame eine mit den nachfolgenden
P-Frames
vergleichbare Qualität hat.
Außerdem stellt diese Option sicher, dass abwechselnd hoch- und weniger
komplexe Frames (z.B. Animation mit wenigen fps)
keine Bits auf schwankende Quantizer verschwenden.
.
.TP
.B qblur=<0\-99> (nur im Modus mit zwei Durchläufen)
Zeitliche Unschärfe des Quantisierungsparameters nach der
Kurvenkomprimierung (Standard: 0.5).
Niedrigere Werte ermöglichen einen volatileren Quantisierungsparameterwert,
höhere Werte forcieren sanftere Schwankungen.
.
.TP
.B zones=<Zone0>[/<Zone1>[/...]]
Vom Benutzer festgelegte Qualität für besondere Abschnitte (Ende, Abspann,
\&...).
Jede Zone ist <Start-Frame>,<End-Frame>,<Option>, wobei Option die folgenden
Werte annehmen kann:
.PD 0
.RSs
.IPs "q=<0\-51>"
Quantisierungsparameter
.IPs "b=<0.01\-100.0>"
Bitraten-Multiplikator
.RE
.PD 1
.RS
.I Anmerkung:
Die Quantisierungsparameter-Option wird nicht streng forciert.
Sie betrifft nur die Planungsphase von ratecontrol und unterliegt der
Überlauf-Kompensation sowie qp_min/qp_max.
.RE
.
.TP
.B direct_pred=<Name>
Legt den Typ der Bewegungsvorhersage fest, der für direkte Markoblöcke in
B-Frames verwendet wird.
.PD 0
.RSs
.IPs none
Direkte Makroblöcke werden nicht genutzt.
.IPs spatial
Bewegungsvektoren werden über benachbarte Blöcke extrapoliert.
(Standard)
.IPs temporal
Bewegungsvektoren werden über den nachfolgenden P-Frame extrapoliert.
.IPs auto
Der Codec wählt für jeden Frame zwischen räumlicher und zeitlicher Vorhersage.
.RE
.PD 1
.RS
Zeitlich und räumlich haben in etwa die gleiche Geschwindigkeit und PSNR,
die Wahl zwischen beiden hängt vom Videoinhalt ab.
Auto ist etwas besser, jedoch langsamer.
Auto eignet sich vor allem bei Encodierung mit mehreren Durchläufen.
direct_pred=none ist sowohl langsamer als auch von schlechterer Qualität.
.RE
.
.TP
.B (no)weight_b
Gewichtete Berechnung in B-Frames verwenden.
Ohne diese Option messen bidirektional berechnete Makroblöcke jedem
Referenz-Frame gleiches Gewicht bei.
Mit dieser Option werden die Gewichtungen anhand der zeitlichen Position des
B-Frames im Verhältnis zu den Referenzen bestimmt.
Benötigt bframes > 1.
.
.TP
.B partitions=<Liste>
Aktiviere einige optionale Makroblock-Typen (Standard: p8x8,b8x8,i8x8,i4x4).
.PD 0
.RSs
.IPs p8x8
Aktiviere die Typen p16x8, p8x16, p8x8.
.IPs p4x4
Aktiviere die Typen p8x4, p4x8, p4x4.
p4x4 wird nur bei subq >= 5 empfohlen, und auch nur bei niedrigen Auflösungen.
.IPs b8x8
Aktiviere die Typen b16x8, b8x16, b8x8.
.IPs i8x8
Aktiviere Typ i8x8.
i8x8 hat keinen Einfluß, wenn 8x8dct nicht aktiviert ist.
.IPs i4x4
Aktiviere Typ i4x4.
.IPs all
Aktivere alle der oben gelisteten Typen.
.IPs none
Deaktiviere alle der oben gelisteten Typen.
.RE
.PD 1
.RS
Unabhängig von dieser Option werden die Makroblock-Typen p16x16, b16x16 und
i16x16 immer aktiviert.
.br
Die Kunst besteht darin, Typen und Größen zu finden, die einen
bestimmten Bereich des Bildes am besten beschreiben.
So wird ein weiter Kameraschwenk bei 16x16 Blöcken besser dargestellt,
während kleine, bewegliche Objekte besser mit kleinen Blöcken dargestellt
werden.
.RE
.
.TP
.B (no)8x8dct
Adaptive räumliche Transformationsgröße: Erlaubt Makroblöcken die Wahl
zwischen 4x4 und 8x8 DCT.
Erlaubt außerdem den Makroblock-Typ i8x8.
Ohne diese Option wird nur 4x4 DCT verwendet.
.
.TP
.B me=<Name>
Wählt den Vollpixel-Bewegungsschätzungs-Algorithmus.
.PD 0
.RSs
.IPs dia
Diamant-Suche, Radius 1 (schnell)
.IPs hex
Hexagon-Suche, Radius 2 (Standard)
.IPs umh
Ungerade Multi-Hexagon-Suche (langsam)
.IPs esa
Gründliche Suche (sehr langsam und nicht besser als umh)
.RE
.PD 1
.
.TP
.B me_range=<4\-64>
Radius der gründlichen bzw. Multi-Hexagon-Bewegungssuche (Standard: 16)
.
.TP
.B subq=<0\-9>
Anpassen der Verfeinerungsqualität von subpel.
Dieser Parameter kontrolliert das Gleichgewicht von Qualität und
Geschwindigkeit beim Prozess der Bewegungsschätzung.
subq=5 kann bis zu 10% besser als subq=1 komprimieren.
.PD 0
.RSs
.IPs 0
Wendet Vollpixel-Präzisionsbewegungsschätzung auf alle in Frage kommenden
Makroblock-Typen an, wählt dann den besten Typen anhand einer SATD-Metrik
(schneller als subq=1, nicht zu empfehlen, wenn du nicht ultra-schnelle
Encodierung brauchst).
.IPs 1
Macht das gleiche wie 0 und verfeinert die Bewegung dieses Typs auf schnelle
Viertelpixel-Präzision (schnell).
.IPs 2
Wendet Halbpixel-Präzisionsbewegungsschätzung auf alle in Frage kommenden
Makroblock-Typen an, wählt dann den besten Typen anhand einer SATD-Metrik und
verfeinert schließlich die
Bewegung dieses Typen auf schnelle Viertelpixel-Präzision.
.IPs 3
Wie 2, verwendet jedoch langsamere Viertelpixel-Verfeinerung.
.IPs 4
Wendet schnelle Viertelpixel-Präzisionsbewegungsschätzung auf alle in Frage
kommenden Makroblock-Typen an, wählt dann den besten Typen anhand einer
SATD-Metrik und schließt dann
die Viertelpixel-Verfeinerung für diesen Typen ab.
.IPs 5
Wendet die bestmögliche Viertelpixel-Präzisionsbewegungsschätzung auf alle in
Frage kommenden Makroblock-Typen an und wählt dann den besten Typen.
Außerdem werden anstatt die Vektoren von Vorwärts- und Rückwärtssuche
wiederzuverwenden die beiden Bewegungsvektoren, die in bidirektionalen
Makroblöcken verwendet werden, anhand einer SATD-Metrik verfeinert.
.IPs 6
Aktiviert Rate-Distortion-Optimierung von Makroblock-Typen in Intra- und
P-Frames an (Standard).
.IPs 7
Aktiviert Rate-Distortion-Optimierung von Makroblock-Typen in allen Frames.
.IPs 8
Aktiviert Rate-Distortion-Optimierung von Bewegungsvektoren und
Intra-Prediction-Modi in Intra- und P-Frames.
.IPs 9
Aktiviert Rate-Distortion-Optimierung von Bewegungsvektoren und
Intra-Prediction-Modi in allen Frames (am besten).
.RE
.PD 1
.RS
"alle in Frage kommenden" meint im obigen Zusammenhang nicht alle aktivierten
Typen; 4x4, 4x8, 8x4 werden nur probiert, wenn 8x8 besser als 16x16 ist.
.RE
.
.TP
.B (no)chroma_me
Berücksichtigt Chrominanz-Informationen während der Subpixel-Bewegungssuche.
(Standard: aktiviert).
Benötigt subq>=5.
.
.TP
.B (no)mixed_refs
Ermöglicht für jede 8x8- oder 16x8-Bewegungspartition die unabhängige Wahl
eines Referenz-Frames.
Ohne diese Option muss ein gesamter Makroblock dieselbe Referenz benutzen.
Benötigt frameref>1.
.
.TP
.B trellis=<0\-2> (nur bei Cabac)
Optimale Quantisierung der Rate-Distortion
.PD 0
.RSs
.IPs 0
deaktiviert (Standard)
.IPs 1
nur bei abschließender Encodierung aktiviert
.IPs 2
während allen Modus-Entscheidungen aktiviert (langsam, benötigt subq>=6)
.RE
.PD 1
.
.TP
.B psy-rd=rd[,trell]
Setzt die Stärke der psychovisuellen Optimierung.
.PD 0
.RSs
.IPs rd=<0.0\-10.0>
Optimierungsstärke (benötigt subq>=6) (Standard: 1.0)
.IPs trell=<0.0\-10.0>
Trellis (benötigt trellis, experimentell) (Standard: 0.0)
.RE
.PD 1
.
.
.TP
.B deadzone_inter=<0\-32>
Setzt die Größe der Inter-Luma-Quantisierungs-Deadzone für
nicht-Trellis-Quantisierung (Standard: 21).
Niedrigere Werte helfen dabei, feine Details und Körnung zu bewahren
(typischerweise nützlich bei Encodierungen mit hoher Bitrate/Qualität),
während höhere Werte dabei helfen, diese Details herauszufiltern, um Bits zu
sparen, die dafür auf andere Macroblöcke und Frames verwendet werden können
(typischerweise nützlich bei Encodierungen mit mangelnder Bitrate).
Es wird empfohlen, mit Feineinstellungen für deadzone_intra zu beginnen, bevor
du diesen Parameter verwendest.
.
.TP
.B deadzone_intra=<0\-32>
Setzt die Größe der Intra-Luma-Quantisierungs-Deadzone für
nicht-Trellis-Quantisierung (Standard: 11).
Diese Option hat dieselbe Wirkung wie deadzone_inter, bezieht sich aber auf
Intra-Frames.
Es wird empfohlen, mit Feineinstellungen für diese Option zu beginnen, bevor
du deadzone_inter änderst.
.
.TP
.B (no)fast_pskip
Führt in P-Frames eine frühe Sprungerkennung durch (Standard: aktiviert).
Dies verbessert die Geschwindigkeit normalerweise ohne zusätzliche Kosten,
kann manchmal jedoch zu Artefakten führen in Bereichen ohne Details, wie ein
Himmel.
.
.TP
.B nr=<0\-100000>
Rauschunterdrückung, 0 bedeutet deaktiviert.
100\-1000 ist ein sinnvoller Bereich für typischen Inhalt, du möchtest den
Wert aber vielleicht erhöhen bei etwas verrauschteren Inhalten (Standard: 0).
Da der Einfluß auf die Geschwindigkeit gering ist, möchtest du diese Methode
der Rauschunterdrückung mit Filtern wie denoise3d oder hqdn3d möglicherweise
vorziehen.
.
.TP
.B chroma_qp_offset=<\-12\-12>
Einen anderen Quantisierungsparameter für die Chrominanz im Vergleich zur
Helligkeit verwenden.
Brauchbare Werte liegen im Bereich <\-2\-2> (Standard: 0).
.
.TP
.B aq_mode=<0\-2>
Definiert, wie die adaptive Quantisierung (AQ) die Bits verteilt:
.PD 0
.RSs
.IPs 0
deaktiviert
.IPs 1
Vermeide es, Bits zwischen Frames zu bewegen.
.IPs 2
Bewege Bits zwischen Frames (Standard).
.RE
.PD 1
.
.TP
.B aq_strength=<positiver Fließkommawert>
Kontrolliert, wie stark die adaptive Quantisierung (AQ) Blockbildung und
Verwaschungen in flachen und texturierten Bereichen reduziert (Standard: 1.0).
Ein Wert von 0.5 wird zu schwacher AQ und weniger Details führen, während ein
Wert von 1.5 zu starker AQ und mehr Details führt.
.
.TP
.B cqm=<flat|jvt|<Dateiname>>
Verwendet entweder eine vom Benutzer vorgegebene Quantisierungsmatrix oder lädt
eine Matrixdatei im JM-Format.
.PD 0
.RSs
.IPs "flat\ "
Verwendet die vorgegebene Flache-16-Matrix (Standard).
.IPs "jvt\ \ "
Verwendet die JVT-Matrix.
.IPs <Dateiname>
Verwende die vorgegebene Matrixdatei im JM-Format.
.PD 1
.RE
.RS
.I ANMERKUNG:
Beim Verwenden der CMD.EXE von Windows können Probleme beim Parsen der
Kommandozeile
auftreten, wenn alle CQM-Listen verwendet werden sollen.
Das liegt an der Beschränkung der Kommandozeilenlänge.
In diesem Fall ist empfehlenswert, die Listeninhalte in eine CQM-Datei im
JM-Format zu packen und wie oben angegeben zu laden.
.RE
.
.TP
.B cqm4iy=<list> (siehe auch cqm)
Eigene 4x4 Intra-Luminanz-Matrix, angegeben als Liste von 16 kommagetrennten
Werten im Bereich von 1\-255.
.
.TP
.B cqm4ic=<list> (siehe auch cqm)
Eigene 4x4 Intra-Chrominanz-Matrix, angegeben als Liste von 16 kommagetrennten
Werten im Bereich von 1\-255.
.
.TP
.B cqm4py=<list> (siehe auch cqm)
Eigene 4x4 Inter-Luminanz-Matrix, angegeben als Liste von 16 kommagetrennten
Werten im Bereich von 1\-255.
.
.TP
.B cqm4pc=<list> (siehe auch cqm)
Eigene 4x4 Inter-Chrominanz-Matrix, angegeben als Liste von 16 kommagetrennten
Werten im Bereich von 1\-255.
.
.TP
.B cqm8iy=<list> (siehe auch cqm)
Eigene 8x8 Intra-Luminanz-Matrix, angegeben als Liste von 64 kommagetrennten
Werten im Bereich von 1\-255.
.
.TP
.B cqm8py=<list> (siehe auch cqm)
Eigene 8x8 Inter-Luminanz-Matrix, angegeben als Liste von 64 kommagetrennten
Werten im Bereich von 1\-255.
.
.TP
.B level_idc=<10\-51>
Legt die Ebene des Bitstroms fest, wie im Anhang A des H.264-Standards
beschrieben.
(Standard: 51 \- Ebene 5.1).
Wird benötigt, um dem Dekoder mitzuteilen, welche Funktionen er unterstützen
muss.
Verwende diesen Parameter nur, wenn Du weißt, was Du tust und wenn Du ihn
setzen musst.
.
.TP
.B threads=<0\-16>
Erstellt Threads, um parallel auf mehreren CPUs zu encodieren (Standard: 1).
Dies führt zu geringen Einbußen der Kompressionsqualität.
0 oder 'auto' weist x264 an, die verfügbare Anzahl CPUs zu erkennen und eine
entsprechende Anzahl Threads zu wählen.
.
.TP
.B (no)global_header
Bewirkt, dass SPS und PPS nur einmal bei Beginn des Bitstreams erscheinen
(Standard: deaktiviert).
Manche Wiedergabegeräte, wie die PSP, benötigen diese Option.
Das Standardverhalten veranlasst, dass SPS und PPS vor jedem IDR-Frame
wiederholt werden.
.
.TP
.B (no)interlaced
Behandle den Videoinhalt als interlaced.
.
.TP
.B log=<\-1\-3>
Einstellen, wieviel an Loginformationen auf dem Bildschirm ausgegeben wird.
.PD 0
.RSs
.IPs "\-1"
keine
.IPs " 0"
Nur Fehler ausgeben.
.IPs " 1"
Warnungen
.IPs " 2"
PSNR und andere Analyse-Statistiken nach der Encodierung ausgeben (Standard)
.IPs " 3"
PSNR, QP, Frame-Type, Größe und andere Statistiken für jeden Frame
.RE
.PD 1
.
.TP
.B (no)psnr
Gib PSNR-Statistiken aus.
.br
.I ANMERKUNG:
Die PSNR-Felder'Y', 'U', 'V' und 'Avg' in der Zusammenfassung  sind nicht
mathematisch exakt, sondern einfach die durchschnittliche PSNR pro Frame.
Sie werden nur zum Vergleich mit dem JM-Referenz-Codec beibehalten.
Für alle anderen Zwecke benutze bitte den PSNR 'Global' oder aber die
PSNRs pro Frame, die von log=3 ausgegeben werden.
.
.TP
.B (no)ssim
Gib die Ergebnisse der Structural Similarity Metric aus.
Dies ist eine Alternative zu PSNR, die unter Umständen besser mit der
wahrgenommenen Qualität des komprimierten Videos korrelliert.
.
.TP
.B (no)visualize
x264-Visualisierung während der Encodierung aktivieren.
Falls das x264 auf deinem System das unterstützt, wird während des
Encodierprozesses ein neues Fenster geöffnet, in dem x264 versuchen wird, eine
Übersicht darüber zu geben, wie jeder Block enkodiert wird.
Jeder Block-Typ in der Visualisierung wird wiefolgt eingefärbt:
.PD 0
.RSs
.IPs rot/pink
Intra-Block
.IPs "blau\ "
Inter-Block
.IPs grün
Skip-Block
.IPs gelb
B-Block
.RE
.PD 1
.RS
Diese Funktion sollte als experimentell betrachtet werden; sie kann in
zukünftigen Versionen ihr Verhalten ändern.
Insbesondere beruht sie darauf, dass x264 mit Unterstützung für
Visualisierungen kompiliert wurde.
Momentan ist es so, dass x264 nach jeder Encodierung und Visualisieren eines
Frames anhält, auf einen Tastendruck des Benutzers wartet und dann erst den
nächsten Frame enkodiert.
.RE
.
.
.SS xvfw (\-xvfwopts)
.
Encodierung mit Video for Windows Codecs ist hauptsächlich obsolet, es sei
denn, du möchtest mit irgendeinem obskuren Codec encodieren.
.
.TP
.B codec=<Name>
Der Name der Binärcodecdatei, mit der encodiert werden soll.
.
.TP
.B compdata=<Datei>
Der Name der Datei mit den Codec-Einstellungen (etwa firstpass.mcf), die
von vfw2menc erstellt wurde.
.
.
.SS MPEG Muxer (\-mpegopts)
.
Der MPEG Muxer kann 5 verschiedene Streamtypen generieren, wovon jeder
sinnvolle Standardparameter hat, die der Benutzer überschreiben kann.
Beim Generieren von MPEG-Dateien ist es generell sinnvoll, MEncoders Code zum
Überspringen von Frames zu benutzen (siehe \-noskip, \-mc sowie die Videofilter
harddup und softskip).
.PP
.I BEISPIEL:
.PD 0
.RSs
.IPs format=mpeg2:tsaf:vbitrate=8000
.RE
.PD 1
.
.TP
.B format=<mpeg1 | mpeg2 | xvcd | xsvcd | dvd | pes1 | pes2>
Streamformat (default: mpeg2).
pes1 und pes2 sind mangelhafte Formate (kein Paketheader und kein Padding),
VDR verwendet sie jedoch; wähle diese nicht, wenn du nicht genau weißt, was
du tust.
.
.TP
.B size=<bis zu 65535>
Paketgröße in Bytes; verändere diese nicht, wenn du nicht genau weißt, was du
tust (Standard: 2048).
.
.TP
.B muxrate=<int>
Nominale Mux-Rate in kBit/s, die in den Paket-Headern benutzt wird (Standard:
1800 kb/s).
Wird nach Bedarf aktualisiert, im Falle 'format=mpeg1' oder 'mpeg2'.
.
.TP
.B "tsaf\ \ \ "
Setzt Zeitstempel (timestamps) bei allen Frames, wenn möglich; empfohlen bei
format=dvd.
Wenn sich dvdauthor beschwert mit einer Meldung wie "..audio sector out of
range...", hast du diese Option vermutlich nicht aktiviert.
.
.TP
.B interleaving2"
Verwendet einen besseren Algorithmus für das Interleaving von Audio- und
Videopaketen, basierend auf dem Prinzip, dass der Muxer immer versuchen wird,
den Stream mit dem größten Prozentanteil des verfügbaren Platzes zu füllen.
.
.TP
.B vdelay=<1\-32760>
Initiale Zeit, um die das Video verzögert wird, in Millisekunden (Standard:
0), benutze dies, um Video bezüglich Audio zu verzögern.
Dies funktioniert nicht mit :drop.
.
.TP
.B adelay=<1\-32760>
Initiale Zeit, um die der Ton verzögert wird, in Millisekunden (Standard: 0),
benutze dies, um Ton bezüglich Video zu verzögern.
.
.TP
.B "drop\ \ \ "
Bei Benutzung mit vdelay verwirft der Muxer den Teil der Audiospur, der
angepasst wurde.
.
.
.TP
.B vwidth, vheight=<1\-4095>
Setzt Videobreite und -höhe, wenn das Video MPEG-1/2 ist.
.
.
.TP
.B vpswidth, vpsheight=<1\-4095>
Setzt Videobreite und -höhe bei Pan-und-Scan-Video bei MPEG-2.
.
.
.TP
.B vaspect=<1 | 4/3 | 16/9 | 221/100>
Setzt den Display-Aspekt für MPEG-1/2-Video.
Verwende diese Option nicht mit MPEG-1, oder der Aspekt wird völlig falsch sein.
.
.
.TP
.B vbitrate=<int>
Setzt die Videobitrate in kbit/s für MPEG-1/2-Video.
.
.
.TP
.B vframerate=<24000/1001 | 24 | 25 | 30000/1001 | 30 | 50 | 60000/1001 |
60 >
Setzt die Framerate bei MPEG-1/2-Video.
Diese Option wird ignoriert, wenn sie zusammen mit der Option telecine benutzt
wird.
.
.TP
.B telecine
Aktiviert 3:2-Pulldown-Soft-telecine-Modus: Der Muxer wird dafür
sorgen, dass der Videostream wie mit 30000/\:1001 fps encodiert aussieht.
Das funktioniert nur mit MPEG-2-Video, wenn die Framerate der Ausgabe
24000/\:1001 beträgt, konvertiere diese mit \-ofps, falls nötig.
Jede andere Framerate ist mit dieser Option inkompatibel.
.
.TP
.B film2pal
Aktiviert FILM zu PAL und NTSC zu PAL Soft-telecine-Modus: Der Muxer wird dafür
sorgen, dass der Videostream wie mit 25 fps encodiert aussieht.
Das funktioniert nur mit MPEG-2-Video, wenn die Framerate der Ausgabe
24000/\:1001 beträgt, konvertiere diese mit \-ofps, falls nötig.
Jede andere Framerate ist mit dieser Option inkompatibel.
.
.TP
.B tele_src und tele_dest
Ermöglicht beliebiges Telecining durch Verwendung des DGPulldown-Codes von
Donand Graft.
Du musst die originale und die erwünschte Framerate angeben; der Muxer wird
den Videostream dann so aussehen lassen, als wäre er mit gewünschten
Framerate encodiert worden.
Dies funktioniert bei MPEG-2 nur dann, wenn die Framerate der Eingabe kleiner
ist als die der Ausgabe und die Frameratenerhöhung <= 1.5 ist.
.sp 1
.RS
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs tele_src=25,tele_dest=30000/1001
Telecining von PAL zu NTSC
.RE
.PD 1
.
.TP
.B vbuf_size=<40\-1194>
Setzt die Größe des Puffers des Videodecoders in Kilobytes.
Gib diese nur an, wenn die Bitrate des Videostreams zu groß für das gewählte
Format ist und wenn du genau weißt, was du tust.
Ein zu hoch gewählter Wert kann zu einem nicht abspielbaren Film führen,
abhängig von den Fähigkeiten deines Players.
Beim Muxen von HDTV-Video sollte ein Wert von 400 ausreichen.
.
.TP
.B abuf_size=<4\-64>
Setzt die Größe des Puffers des Audiodecoders in Kilobytes.
Es gilt das gleiche Prinzip wie für vbuf_size.
.
.
.SS FFmpeg-libavformat-Demuxer (\-lavfdopts)
.
.TP
.B analyzeduration=<Wert>
Maximale Länge in Sekunden, die verwendet wird, um Streameigenschaften
zu analysieren.
.
.TP
.B format=<Wert>
Gib einen speziellen libavformat-Demuxer an.
.
.TP
.B o=<Schlüssel>=<Wert>[,<Schlüssel>=<Wert>[,...]]
Übergib AVOptions an den libavformat-Demuxer.
Beachte, ein Patch, um o= überflüssig zu machen und alle unbekannten Optionen
durch das AVOption-System zu übergeben, ist willkommen.
Eine komplette Liste der AVOptions findest du im FFmpeg-Handbuch.
Beachte, dass manche Optionen mit MEncoder-Optionen in Konflikt stehen
können.
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.PD 0
.IPs o=ignidx
.PD 1
.RE
.
.TP
.B probesize=<Wert>
Maximale Datenmenge, die während der Erkennungsphase untersucht wird.
Im Falle von MPEG-TS gibt dieser Wert die maximale Anzahl der zu scannenden
TS-Pakete an.
.
.TP
.B cryptokey=<Hex-String>
Verschlüsselungsschlüssel, den der Demuxer verwenden soll.
Dies sind die binären Rohdaten des Schlüssels in eine hexadezimale
Zeichenkette konvertiert.
.
.
.SS FFmpeg-libavformat-Muxer (\-lavfopts) (siehe auch \-of lavf)
.
.TP
.B delay=<Wert>
Momentan nur für MPEG[12] von Bedeutung: Maximal erlaubter Abstand in Sekunden
zwischen dem Referenzzeitgeber des Ausgabestreams (SCR) und des
Decodierungszeitstempels (DTS) für jeden vorhandenen Stream
(Verzögerung von Demuxing zu Decodierung).
Standardwert ist 0.7 (wie vom Standard von MPEG vorgegeben).
Höhere Werte erfordern größere Puffer und dürfen nicht verwendet werden.
.
.TP
.B format=<container_format>
Überschreibt das Containerformat, in welches geschrieben wird (Standard:
automatische Erkennung anhand der Dateiendung).
.PD 0
.RSs
.IPs "mpg\ \ "
MPEG-1-Systeme und MPEG-2 PS
.IPs "asf\ \ "
Advanced Streaming Format
.IPs "avi\ \ "
Audio Video Interleave Datei
.IPs "wav\ \ "
Waveform Audio
.IPs "swf\ \ "
Macromedia Flash
.IPs "flv\ \ "
Macromedia Flash Videodateien
.IPs "rm\ \ \ "
RealAudio und RealVideo
.IPs "au\ \ \ "
SUN AU-Format
.IPs "nut\ \ "
NUT offenes Containerformat (experimentell)
.IPs "mov\ \ "
QuickTime
.IPs "mp4\ \ "
MPEG-4-Format
.IPs "ipod\ "
MPEG-4-Format mit speziellen Header-Flags, die von der Apple
iPod-Firmware benötigt werden
.IPs "dv\ \ \ "
Sony Digital Video Container
.IPs "matroska\ \ \ "
Matroska
.RE
.PD 1
.TP
.B muxrate=<Rate>
Nominale Bitrate des Multiplex in Bits pro Sekunde;
momentan nur für MPEG[12] von Bedeutung.
Manchmal ist es nötig, diese zu erhöhen, um "Buffer Underflows" zu verweiden.
.
.TP
.B o=<Schlüssel>=<Wert>[,<Schlüssel>=<Wert>[,...]]
Übergib AVOptions an den libavformat-Muxer.
Beachte, ein Patch, um o= überflüssig zu machen und alle unbekannten Optionen
durch das AVOption-System zu übergeben, ist willkommen.
Eine komplette Liste der AVOptions findest du im FFmpeg-Handbuch.
Beachte, dass manche Optionen mit MEncoder-Optionen in Konflikt stehen
können.
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.PD 0
.IPs o=packetsize=100
.PD 1
.RE
.
.TP
.B packetsize=<Größe>
Größe, ausgedrückt in Bytes, des einheitlichen Pakets für das gewählte Format.
Beim Muxing zu MPEG[12]-Implementierungen sind die Standardwerte 2324 für
[S]VCD und 2048 für alle anderen Formate.
.
.TP
.B preload=<Abstand>
Momentan nur für MPEG[12] von Bedeutung: Initialer Abstand in Sekunden zwischen
dem Referenzzeitgeber des Ausgabestreams (SCR) und des
Decodierungszeitstempels (DTS) für jeden vorhandenen Stream
(Verzögerung von Demuxing zu Decodierung).
.
.
.
.\" --------------------------------------------------------------------------
.\" Umgebungsvariablen
.\" --------------------------------------------------------------------------
.
.SH UMGEBUNGSVARIABLEN
.
Es gibt einige Umgebungsvariablen, die benutzt werden können, um das Verhalten
von MPlayer und MEncoder zu steuern.
.
.TP
.B MPLAYER_CHARSET (siehe auch \-msgcharset)
Konvertiere Konsolenausgaben in den angegebenen Zeichensatz (Standard:
automatische Erkennung).
Der Wert "noconv" bedeutet keine Konvertierung.
.TP
.B MPLAYER_HOME
Verzeichnis, in dem MPlayer nach dem Benutzereinstellungen sucht.
.
.TP
.B MPLAYER_VERBOSE (siehe auch \-v und \-msglevel)
Setze das initiale Ausführlichkeitslevel quer durch alle
Benachrichtigungsmodule (Standard: 0).
Das resultierende Ausführlichkeitslevel entspricht dem von \-msglevel 5 plus
dem Wert von MPLAYER_VERBOSE.
.
.SS libaf:
.
.TP
.B LADSPA_PATH
Falls LADSPA_PATH gesetzt ist, wird dort der angegebenen Datei gesucht.
Ansonsten muss ein vollständiger Pfadname angegeben werden.
FIXME: Dies wird auch in der ladspa-Sektion erwähnt.
.
.SS libdvdcss:
.
.TP
.B DVDCSS_CACHE
Gibt das Verzeichnis an, in dem die Titelschlüssel gespeichert werden sollen.
Dies beschleunigt die entschlüsselung von DVDs, die im Cache sind.
Falls das Verzeichnis noch nicht existiert, wird es erzeugt und ein
nach dem Titel oder Herstellungsdatum der DVD benanntes Unterverzeichnis
angelegt.
Wenn DVDCSS_CACHE nicht gesetzt oder leer ist, wird die Standardeinstellung
benutzt, die unter Unix "${HOME}/.dvdcss/" und unter Win32
"C:\\Dokumente und Einstellungen\\$USER\\Anwendungsdaten\\dvdcss\\" ist.
Der spezielle Wert "off" deaktiviert den Cache.
.
.TP
.B DVDCSS_METHOD
Stellt die Authentifizierungs- und Entschlüsselungsmethode ein,
die libdvdcss zum Lesen verschlüsselter DVDs benutzt.
Mögliche Werte sind title, key oder disc.
.PD 0
.RSs
.IPs "key\ \ "
Standardeinstellung, libdvdcss benutzt einen Satz vorberechneter
Player-Schlüssel um zu Versuchen den Disc-Schlüssel zu bekommen.
Dies kann fehlschlagen, wenn das Laufwerk keinen der Player-Schlüssel
erkennt.
.IPs "disc\ "
Ausweichmethode, wenn key fehlgeschlagen ist.
Anstelle die Player-Schlüssel zu benutzen, knackt libdvdcss den
Disc-Schlüssel mit einem Brute-Force-Algorithmus.
Dieser Prozess ist CPU-Intensiv und benötigt 64MB Speicher für
temporäre Daten.
.IPs title
Wird benutzt, wenn die anderen Methoden fehlgeschlagen sind.
Es findet kein Schlüsselaustausch mit dem Laufwerk statt, an dessen
Stelle wird ein Kryptografischer Angriff benutzt um den Titel-Schlüssel
zu erraten.
In seltenen Fällen kann dies fehlschlagen, wenn nicht genug verschlüsselte
Daten auf der DVD sind um einen statistischen Angriff durchzuführen,
andererseits ist dies die einzige Möglichkeit um eine verschlüsselt
auf der Festplatte abgelegte oder mit nicht zur Laufwerksregion passende
DVD abzuspielen.
.RE
.PD 1
.
.TP
.B DVDCSS_RAW_DEVICE
Gibt die zu benutzende Rohdaten-Gerätedatei an.
Die genaue Syntax hängt vom verwendeten Betriebssystem ab,
z.B. wird uner Linux das raw(8)-Tool benutzt um diese
Gerätedatei aufzusetzen.
Beachte bitte, dass bei den meisten Betriebssystemen die Benutzung
von Rohdaten-Gerätedateien streng ausgerichtet Puffer benötigt:
Linux verlangt eine Ausrichtung auf 2048 Byte (die Größe eines DVD-Sektors).
.
.TP
.B DVDCSS_VERBOSE
Steuert die Ausführlichkeit der Meldungen von libdvdcss.
.PD 0
.RSs
.IPs 0
Keine Ausgaben.
.IPs 1
Gibt Fehlermeldungen auf stderr aus.
.IPs 2
Gibt Fehler- und Debugmeldungen auf stderr aus.
.RE
.PD 1
.
.TP
.B DVDREAD_NOKEYS
Überspringt das Ermitteln aller Schlüssel beim Start.
Momentan unbenutzt.
.
.TP
.B HOME
FIXME: Muss noch dokumentiert werden.
.
.SS libao2:
.
.TP
.B AO_SUN_DISABLE_SAMPLE_TIMING
FIXME: Muss noch dokumentiert werden.
.
.TP
.B AUDIODEV
FIXME: Muss noch dokumentiert werden.
.
.TP
.B AUDIOSERVER
Gibt den Network Audio System Server und Transporttyp an, zu dem der
nas-Audioausgabetreiber verbinden soll.
Falls AUDIOSERVER nicht gesetzt ist, wird DISPLAY benutzt.
Mögliche Werte für den Transporttyp sind tcp und unix.
Die Syntax ist tcp/<rechner>:<port>, <rechner>:<instanznummer>
oder [unix]:<instanznummer>.
Der NAS-Basisport ist 8000 und <instanznummer> wird dazugezählt.
.sp 1
.RS
.I BEISPIELE:
.RE
.PD 0
.RSs
.IPs AUDIOSERVER=rechner:0
Verbinde mit NAS-Server auf rechner mit Standardport und -Transporttyp.
.IPs AUDIOSERVER=tcp/rechner:8000
Verbinde mit auf port 8000 lauschendem NAS-Server auf rechner.
.IPs AUDIOSERVER=(unix)?:0
Verbinde mit NAS-Serverinstanz 0 auf localhost unter Benutzung von
unix domain sockets.
.RE
.PD 1
.
.TP
.B DISPLAY
FIXME: Muss noch dokumentiert werden.
.
.SS vidix:
.
.TP
.B VIDIX_CRT
FIXME: Muss noch dokumentiert werden.
.
.TP
.B VIDIXIVTVALPHA
Setze dies auf 'disable', um den VIDIX\-Treiber daran zu hindern, die
Einstellungen für das Alphablending zu kontrollieren.
Du kannst die Einstellungen selbst vornehmen mit 'ivtvfbctl'.
.
.SS osdep:
.
.TP
.B TERM
FIXME: Muss noch dokumentiert werden.
.
.SS libvo:
.
.TP
.B DISPLAY
FIXME: Muss noch dokumentiert werden.
.
.TP
.B FRAMEBUFFER
FIXME: Muss noch dokumentiert werden.
.
.TP
.B HOME
FIXME: Muss noch dokumentiert werden.
.
.SS libmpdemux:
.
.TP
.B HOME
FIXME: Muss noch dokumentiert werden.
.
.TP
.B HOMEPATH
FIXME: Muss noch dokumentiert werden.
.
.TP
.B http_proxy
FIXME: Muss noch dokumentiert werden.
.
.TP
.B LOGNAME
FIXME: Muss noch dokumentiert werden.
.
.TP
.B USERPROFILE
FIXME: Muss noch dokumentiert werden.
.
.SS GUI:
.
.TP
.B DISPLAY
Das Display des X-Servers, auf dem die GUI laufen soll.
.
.TP
.B HOME
Das persönliche Verzeichnis des Benutzers.
.
.SS libavformat:
.
.TP
.B AUDIO_FLIP_LEFT
FIXME: Muss noch dokumentiert werden.
.
.TP
.B BKTR_DEV
FIXME: Muss noch dokumentiert werden.
.
.TP
.B BKTR_FORMAT
FIXME: Muss noch dokumentiert werden.
.
.TP
.B BKTR_FREQUENCY
FIXME: Muss noch dokumentiert werden.
.
.TP
.B http_proxy
FIXME: Muss noch dokumentiert werden.
.
.TP
.B no_proxy
FIXME: Muss noch dokumentiert werden.
.
.
.
.\" --------------------------------------------------------------------------
.\" Dateien
.\" --------------------------------------------------------------------------
.
.SH DATEIEN
.
.TP
/usr/\:local/\:etc/\:mplayer/\:mplayer.conf
Systemweite Einstellungen für MPlayer
.
.TP
/usr/\:local/\:etc/\:mplayer/\:mencoder.conf
Systemweite Einstellungen für MEncoder
.
.TP
~/.mplayer/\:config
Benutzerspezifische Einstellungen für MPlayer
.
.TP
~/.mplayer/\:mencoder.conf
Benutzerspezifische Einstellungen für MEncoder
.
.TP
~/.mplayer/\:input.conf
Eingabebindungen (Siehe '\-input keylist' für eine vollständige Liste)
.
.TP
~/.mplayer/\:gui.conf
GUI-Konfigurationsdatei
.
.TP
~/.mplayer/\:gui.gain
Für Audio-Dateien, die keine Information zur Lautstärke-Anpassung (Replay
Gain) enthalten, kann man eine Zeile mit Verstärkung oder Verminderung und
Dateinamen (durch ein Leerzeichen getrennt) eintragen, z. B.
.br

+1.50 /home/ich/Musik/Lied.mp3
.
.TP
~/.mplayer/\:gui.history
GUI-Verzeichnisverlauf
.
.TP
~/.mplayer/\:gui.pl
GUI-Playliste
.
.TP
~/.mplayer/\:gui.url
GUI-URL-Liste
.
.TP
~/.mplayer/\:font/
Font-Verzeichnis (Es müssen eine font.desc-Datei und Dateien
mit .RAW-Erweiterung existieren)
.
.TP
~/.mplayer/\:DVDkeys/
zwischengespeicherte CSS-Schlüssel
.RE
.PD 1
.
.
.\" --------------------------------------------------------------------------
.\" Beispiele
.\" --------------------------------------------------------------------------
.
.SH BEISPIELE ZUM GEBRAUCH VON MPLAYER
.
.PP
.B Schnellstart für das Abspielen einer DVD:
.nf
mplayer dvd://1
.fi
.
.PP
.B Audio auf Japanisch mit englischen Untertiteln:
.nf
mplayer dvd://1 \-alang ja \-slang en
.fi
.
.PP
.B Spiele nur die Kapitel 5, 6, 7:
.nf
mplayer dvd://1 \-chapter 5\-7
.fi
.
.PP
.B Spiele nur die Titel 5, 6, 7:
.nf
mplayer dvd://5\-7
.fi
.
.PP
.B bei einer DVD mit mehreren Kameraperspektiven:
.nf
mplayer dvd://1 \-dvdangle 2
.fi
.
.PP
.B Abspielen von einem anderen DVD-Gerät:
.nf
mplayer dvd://1 \-dvd\-device /dev/\:dvd2
.fi
.
.PP
.B Spiele DVD-Videos direkt aus einem Verzeichnis mit VOB-Dateien:
.nf
mplayer dvd://1 \-dvd\-device /Pfad/\:zum/\:Verzeichnis/
.fi
.
.PP
.B Kopiere den Titel einer DVD auf die Festplatte, speichere die Datei unter
dem Namen "title1.vob":
.nf
mplayer dvd://1 \-dumpstream \-dumpfile title1.vob
.fi
.
.PP
.B Spiele eine DVD mit dvdnav vom Pfad /dev/sr1:
.nf
mplayer dvdnav:////dev/sr1
.fi
.
.PP
.B Streaming per HTTP:
.nf
mplayer http://mplayer.hq/example.avi
.fi
.
.PP
.B Streaming mit RTSP:
.nf
mplayer rtsp://server.example.com/streamName
.fi
.
.PP
.B Konvertiere Untertitel in das MPsub-Format:
.nf
mplayer dummy.avi \-sub source.sub \-dumpmpsub
.fi
.
.PP
.B Konvertiere Untertitel in das MPsub-Format, ohne dabei das Video anzuschauen:
.nf
mplayer /dev/\:zero \-rawvideo pal:fps=xx \-demuxer rawvideo \-vc null \-vo null
\-noframedrop \-benchmark \-sub source.sub \-dumpmpsub
.fi
.
.PP
.B Eingabe vom Standard-V4L-Gerät:
.nf
mplayer tv:// \-tv driver=v4l:width=640:height=480:outfmt=i420 \-vc rawi420
\-vo xv
.fi
.
.PP
.B Wiedergabe auf Zoran-Karten (alte Bauweise, veraltet):
.nf
mplayer \-vo zr \-vf scale=352:288 Datei.avi
.fi
.
.PP
.B Wiedergabe auf Zoran-Karten (neue Bauweise):
.nf
mplayer \-vo zr2 \-vf scale=352:288,zrmjpeg Datei.avi
.fi
.
.PP
.B Wiedergabe von DTS-CD mit Passthrough:
.nf
mplayer \-ac hwdts \-rawaudio format=0x2001 \-cdrom\-Gerät /dev/cdrom cdda://
.fi
.br
Du kannst auch \-afm hwac3 anstelle von \-ac hwdts verwenden.
Passe '/dev/cdrom' entsprechend dem CD-ROM-Gerät deines Systems an.
Wenn dein externer Receiver Decodierung von raw-DTS-Streams unterstützt,
kannst du diese direkt via cdda:// abspielen, ohne format, hwac3 oder hwdts
angeben zu müssen.
.
.PP
.B Spiele eine 6-kanalige AAC-Datei mit nur zwei Lautsprechern ab:
.nf
mplayer \-rawaudio on:format=0xff \-af
pan=6:.32:.39:.06:.17:-.17:.33:.32:.06:.39:-.17:.17:.33 adts_he-aac160_51.aac
.fi
.br
Du könntest etwas mit den Werten für pan experimentieren (z.B.\& mit einem
Wert multiplizieren), um die Lautstärke zu erhöhen oder Abschneiden von Sound
zu vermeiden.
.
.PP
.B Schachbrett-Invertierung mit dem geq-Filter:
.nf
mplayer \-vf geq='128+(p(X\\,Y)\-128)*(0.5\-gt(mod(X/SW\\,128)\\,64))*(0.5\-gt(mod(Y/SH\\,128)\\,64))*4'
.fi
.
.
.SH BEISPIELE ZUM GEBRAUCH VON MENCODER
.
.PP
.B Encodiere Titel Nr. 2 der DVD, aber nur ausgewählte Kapitel:
.nf
mencoder dvd://2 \-chapter 10\-15 \-o title2.avi \-oac copy \-ovc
lavc \-lavcopts vcodec=mpeg4
.fi
.
.PP
.B Encodiere Titel Nr. 2 der DVD und skaliere auf 640x480:
.nf
mencoder dvd://2 \-vf scale=640:480 \-o title2.avi \-oac copy \-ovc
lavc \-lavcopts vcodec=mpeg4
.fi
.
.PP
.B Encodiere Titel Nr. 2 der DVD und skaliere auf 512xHHH unter Beibehaltung des Höhen-/Breitenverhältnisses:
.nf
mencoder dvd://2 \-vf scale \-zoom \-xy 512 \-o title2.avi \-oac copy \-ovc
lavc \-lavcopts vcodec=mpeg4
.fi
.
.PP
.B Das gleiche, aber mit einer Bitrate von 1800kBit und optimierten Makroblocks:
.nf
mencoder dvd://2 \-o title2.avi \-oac copy \-ovc lavc \-lavcopts
vcodec=mpeg4:mbd=1:vbitrate=1800
.fi
.
.PP
.B Das gleiche, aber mit MJPEG-Kompression:
.nf
mencoder dvd://2 \-o title2.avi \-oac copy \-ovc lavc \-lavcopts
vcodec=mjpeg:mbd=1:vbitrate=1800
.fi
.
.PP
.B Encodiere alle .jpg-Dateien im aktuellen Verzeichnis:
.nf
mencoder "mf://*.jpg" \-mf fps=25 \-o output.avi \-ovc lavc \-lavcopts
vcodec=mpeg4
.fi
.
.PP
.B Encodiere aus einem Fernsehsignal (gib ein Format mit \-vf format an):
.nf
mencoder \-tv driver=v4l:width=640:height=480 tv:// \-o tv.avi \-ovc raw
.fi
.
.PP
.B Encodiere aus einer Pipe:
rar p test-SVCD.rar | mencoder \-ovc lavc \-lavcopts
vcodec=mpeg4:vbitrate=800 \-ofps 24 \-
.fi
.
.
.\" --------------------------------------------------------------------------
.\" Fehler, Autoren, Haftungsausschluss
.\" --------------------------------------------------------------------------
.
.SH FEHLER/\:BUGS
Keine Panik.
Berichte uns davon, wenn du einen findest, sei aber sicher, dass Du vorher die
ganze Dokumentation gelesen hast.
Achte auf Smilies. :)
Viele Fehler sind das Resultat eines fehlerhaften Setups oder falscher
Benutzung der Parameter.
Die Sektion über Fehlerberichterstattung in der Dokumentation
(http://www.mplayerhq.hu/\:DOCS/\:HTML/\:de/\:bugreports.html) beschreibt,
wie man nutzbringende Fehlerberichte
erstellt.
.
.
.
.SH AUTOREN
MPlayer wurde ursprünglich von Arpad Gereöffy geschrieben.
Siehe Datei AUTHORS für eine Liste einiger der vielen anderen Beitragenden.
.PP
MPlayer is (C) 2000\-2023 The MPlayer Team
.PP
Diese Manpage wurde zum größten Teil von Gabucino, Diego Biurrun und
Jonas Jermann geschrieben und von Moritz Bunkus und Sebastian Krämer
ins Deutsche übersetzt.
Sie wird gepflegt von Sebastian Krämer.
Schicke Mails die Manpage betreffend bitte an die MPlayer-DOCS-Mailingliste.
.\" Ende der Datei
